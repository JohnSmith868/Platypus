var platypus =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/recycle/recycle.js":
/*!*****************************************!*\
  !*** ./node_modules/recycle/recycle.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* global Array, console, Object */\r\n\r\nconst recycleProp = {\r\n        value: false,\r\n        writable: true\r\n    },\r\n    caches = {},\r\n    Container = function () {\r\n        this.contains = null;\r\n        this.previous = null;\r\n    };\r\n    \r\nlet containers = null; // link-list of cached, unused containers for caches.\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n    add: function (ClassObject, name, setUp, tearDown, mixinMethods, debug) {\r\n        var isArray = (ClassObject === Array),\r\n            cache = null;\r\n\r\n        if (!name) {\r\n            console.warn('Recycle: Must define a name for this cache.');\r\n            return null;\r\n        }\r\n        \r\n        if (caches[name]) {\r\n            if (ClassObject !== caches[name].ClassObject) {\r\n                console.warn('Recycle: There is already a cache named \"' + name + '\" that is being used for another object type.');\r\n            }\r\n            return caches[name];\r\n        }\r\n        \r\n        cache = caches[name] = {\r\n            ClassObject: ClassObject,\r\n            list: null,\r\n            setUp: null,\r\n            recycle: null,\r\n            pop: isArray ? function () {\r\n                var list = this.list,\r\n                    item = null;\r\n\r\n                if (list) {\r\n                    this.list = list.previous;\r\n                    item = list.contains;\r\n                    list.previous = containers;\r\n                    containers = list;\r\n                    return item;\r\n                } else {\r\n                    return [];\r\n                }\r\n            } : function () {\r\n                var list = this.list,\r\n                    item = null;\r\n\r\n                if (list) {\r\n                    this.list = list.previous;\r\n                    item = list.contains;\r\n                    list.previous = containers;\r\n                    containers = list;\r\n                    return item;\r\n                } else {\r\n                    return Object.create(this.ClassObject.prototype);\r\n                }\r\n            },\r\n            push: function (item) {\r\n                var available = containers;\r\n\r\n                if (available) {\r\n                    containers = available.previous;\r\n                } else {\r\n                    available = Object.create(Container.prototype);\r\n                }\r\n\r\n                available.previous = this.list;\r\n                this.list = available;\r\n                available.contains = item;\r\n            },\r\n            getLength: function () {\r\n                var i = 0,\r\n                    item = this.list;\r\n\r\n                while (item) {\r\n                    i += 1;\r\n                    item = item.previous;\r\n                }\r\n\r\n                return i;\r\n            }\r\n        };\r\n\r\n        // Handle object instantiation\r\n        if (setUp) {\r\n            cache.setUp = function () {\r\n                var newObject = this.pop();\r\n\r\n                setUp.apply(newObject, arguments);\r\n\r\n                return newObject;\r\n            };\r\n        } else if (isArray) {\r\n            cache.setUp = function () {\r\n                var arr = this.pop(),\r\n                    i = 0;\r\n        \r\n                for (i = 0; i < arguments.length; i++) {\r\n                    arr[i] = arguments[i];\r\n                }\r\n\r\n                return arr;\r\n            };\r\n        } else {\r\n            cache.setUp = cache.pop;\r\n        }\r\n\r\n        // Handle object release\r\n        if (tearDown) {\r\n            cache.recycle = function (item, ...args) {\r\n                tearDown.apply(item, ...args);\r\n                this.push(item);\r\n            };\r\n        } else if (isArray) {\r\n            cache.recycle = function (arr, depth) {\r\n                var i = 0;\r\n                \r\n                if (depth > 1) {\r\n                    i = arr.length;\r\n                    depth -= 1;\r\n                    while (i--) {\r\n                        this.recycle(arr[i], depth);\r\n                    }\r\n                }\r\n                arr.length = 0;\r\n                this.push(arr);\r\n            };\r\n        } else {\r\n            cache.recycle = cache.push;\r\n        }\r\n\r\n        // Add debug wrapper if needed\r\n        if (debug) {\r\n            cache.setUp = function (cacheSetUp, ...args) {\r\n                var newObject = cacheSetUp(...args);\r\n\r\n                if (typeof newObject.recycled === 'undefined') {\r\n                    Object.defineProperty(newObject, 'recycled', recycleProp);\r\n                } else {\r\n                    newObject.recycled = false;\r\n                }\r\n\r\n                return newObject;\r\n            }.bind(cache, cache.setUp.bind(cache));\r\n\r\n            cache.recycle = function (recycle, instance, ...args) {\r\n                if (instance.recycled) {\r\n                    console.warn('Recycle: WHOA! I have already been recycled!', instance);\r\n                } else {\r\n                    instance.recycled = true;\r\n                    recycle(instance, ...args);\r\n                }\r\n            }.bind(cache, cache.recycle.bind(cache));\r\n\r\n            if (isArray) {\r\n                cache.recycle = function (recycle, instance, ...args) {\r\n                    if (!Array.isArray(instance)) {\r\n                        console.warn('Recycle: Adding a non-Array to the array cache!');\r\n                    }\r\n                    recycle(instance, ...args);\r\n                }.bind(cache, cache.recycle.bind(cache));\r\n            }\r\n        }\r\n\r\n        if (mixinMethods) {\r\n            Object.defineProperties(ClassObject, {\r\n                setUp: {\r\n                    value: cache.setUp.bind(cache)\r\n                },\r\n                recycle: {\r\n                    value: cache.recycle.bind(cache)\r\n                }\r\n            });\r\n            Object.defineProperty(ClassObject.prototype, 'recycle', {\r\n                value: function (...args) {\r\n                    cache.recycle(this, ...args);\r\n                }\r\n            });\r\n        }\r\n\r\n        return cache;\r\n    },\r\n\r\n    cache: caches\r\n});\r\n\n\n//# sourceURL=webpack://platypus/./node_modules/recycle/recycle.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://platypus/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, version, description, license, main, module, url, logo, repository, scripts, dependencies, devDependencies, engine, default */
/***/ (function(module) {

eval("module.exports = {\"name\":\"platypus\",\"version\":\"1.0.0\",\"description\":\"Platypus Docs\",\"license\":\"MIT\",\"main\":\"lib/platypus.js\",\"module\":\"src/index.js\",\"url\":\"https://github.com/PBS-KIDS/Platypus\",\"logo\":\"assets/platypus-title.png\",\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/PBS-KIDS/Platypus\"},\"scripts\":{\"test\":\"grunt jasmine:src\",\"start\":\"webpack-dev-server --env.dev\",\"build:release\":\"webpack --env.prod\",\"build:debug\":\"webpack --env.dev\"},\"dependencies\":{\"@tweenjs/tween.js\":\"^18.3.1\",\"pixi-sound\":\"^3.0.3\",\"pixi-spine\":\"^2.1.4\",\"pixi.js\":\"5.2.0\",\"recycle\":\"https://github.com/gopherwood/recycle.git#master\",\"springroll\":\"2.0.3\"},\"devDependencies\":{\"grunt\":\"^0.4.5\",\"grunt-contrib-compress\":\"^0.13.0\",\"grunt-contrib-concat\":\"^1.0.1\",\"grunt-contrib-copy\":\"^0.8.0\",\"grunt-contrib-jasmine\":\"^1.1.0\",\"grunt-contrib-uglify\":\"^0.9.1\",\"grunt-contrib-yuidoc\":\"^0.8.0\",\"lodash\":\"^3.10.0\",\"pako\":\"^0.2.8\",\"webpack\":\"^4.35.2\",\"webpack-cli\":\"^3.3.5\"},\"engine\":\"node >= 0.10.22\"};\n\n//# sourceURL=webpack://platypus/./package.json?");

/***/ }),

/***/ "./src/AABB.js":
/*!*********************!*\
  !*** ./src/AABB.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\r\n * This class defines an axis-aligned bounding box (AABB) which is used during the collision process to determine if two objects are colliding. This is used in a few places including [CollisionBasic](platypus.components.CollisionBasic.html) and [[Collision-Shape]].\r\n *\r\n * @namespace platypus\r\n * @class AABB\r\n * @constructor\r\n * @param x {number} The x position of the AABB. The x is always located in the center of the object.\r\n * @param y {number} The y position of the AABB. The y is always located in the center of the object.\r\n * @param width {number} The width of the AABB.\r\n * @param height {number} The height of the AABB.\r\n * @return {platypus.AABB} Returns the new aabb object.\r\n */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var AABB = function (x, y, width, height) {\r\n            if (x instanceof AABB) {\r\n                this.set(x);\r\n            } else {\r\n                this.empty = true;\r\n                this.setAll(x, y, width, height);\r\n            }\r\n        },\r\n        proto = AABB.prototype;\r\n    \r\n    /**\r\n     * Sets all of the properties of the AABB.\r\n     *\r\n     * @method setAll\r\n     * @param x {number} The x position of the AABB. The x is always located in the center of the object.\r\n     * @param y {number} The y position of the AABB. The y is always located in the center of the object.\r\n     * @param width {number} The width of the AABB.\r\n     * @param height {number} The height of the AABB.\r\n     * @chainable\r\n     */\r\n    proto.setAll = function (x, y, width, height) {\r\n        this.empty = false;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.resize(width, height);\r\n        return this;\r\n    };\r\n    \r\n    /**\r\n     * Sets bounds of the AABB.\r\n     *\r\n     * @method setBounds\r\n     * @param left {number} The left side of the AABB.\r\n     * @param top {number} The top side of the AABB.\r\n     * @param right {number} The right side of the AABB.\r\n     * @param bottom {number} The bottom side of the AABB.\r\n     * @chainable\r\n     */\r\n    proto.setBounds = function (left, top, right, bottom) {\r\n        this.empty = false;\r\n        this.x = (right + left) / 2;\r\n        this.y = (top + bottom) / 2;\r\n        this.resize(right - left, bottom - top);\r\n        return this;\r\n    };\r\n    \r\n    /**\r\n     * Sets the AABB values to those of the provided AABB.\r\n     *\r\n     * @method set\r\n     * @param aabb {platypus.AABB} The AABB to copy values.\r\n     * @chainable\r\n     */\r\n    proto.set = function (aabb) {\r\n        /**\r\n         * Whether the AABB encloses a valid space.\r\n         *\r\n         * @property empty\r\n         * @type boolean\r\n         */\r\n        this.empty = aabb.empty;\r\n        \r\n        /**\r\n         * The x position of the AABB. The x is always located in the center of the object.\r\n         *\r\n         * @property x\r\n         * @type number\r\n         */\r\n        this.x = aabb.x;\r\n        \r\n        /**\r\n         * The y position of the AABB. The y is always located in the center of the object.\r\n         *\r\n         * @property y\r\n         * @type number\r\n         */\r\n        this.y = aabb.y;\r\n        \r\n        /**\r\n         * The width of the AABB.\r\n         *\r\n         * @property width\r\n         * @type number\r\n         */\r\n        this.width  = aabb.width;\r\n        \r\n        /**\r\n         * The height of the AABB.\r\n         *\r\n         * @property height\r\n         * @type number\r\n         */\r\n        this.height = aabb.height;\r\n        \r\n        /**\r\n         * Half the width of the AABB.\r\n         *\r\n         * @property halfWidth\r\n         * @type number\r\n         */\r\n        this.halfWidth = aabb.halfWidth;\r\n        \r\n        /**\r\n         * Half the height of the AABB.\r\n         *\r\n         * @property halfHeight\r\n         * @type number\r\n         */\r\n        this.halfHeight = aabb.halfHeight;\r\n        \r\n        /**\r\n         * The x-position of the left edge of the AABB.\r\n         *\r\n         * @property left\r\n         * @type number\r\n         */\r\n        this.left = aabb.left;\r\n        \r\n        /**\r\n         * The x-position of the right edge of the AABB.\r\n         *\r\n         * @property right\r\n         * @type number\r\n         */\r\n        this.right = aabb.right;\r\n        \r\n        /**\r\n         * The y-position of the top edge of the AABB.\r\n         *\r\n         * @property top\r\n         * @type number\r\n         */\r\n        this.top = aabb.top;\r\n        \r\n        /**\r\n         * The y-position of the bottom edge of the AABB.\r\n         *\r\n         * @property bottom\r\n         * @type number\r\n         */\r\n        this.bottom = aabb.bottom;\r\n        \r\n        return this;\r\n    };\r\n    \r\n    /**\r\n     * Returns a string listing AABB dimensions.\r\n     *\r\n     * @method toString\r\n     * @return String\r\n     */\r\n    proto.toString = function () {\r\n        return '[AABB: ' + this.width + 'x' + this.height + ' (' + this.x + ', ' + this.y + ')]';\r\n    };\r\n\r\n    /**\r\n     * Resets all the values in the AABB so that the AABB can be reused.\r\n     *\r\n     * @method reset\r\n     * @chainable\r\n     */\r\n    proto.reset = function () {\r\n        this.empty = true;\r\n        return this;\r\n    };\r\n    \r\n    /**\r\n     * Resizes the AABB.\r\n     *\r\n     * @method resize\r\n     * @param width {number} The new width of the AABB\r\n     * @param height {number} The new height of the AABB\r\n     * @chainable\r\n     */\r\n    proto.resize = function (width, height) {\r\n        var w = width || 0,\r\n            h = height || 0,\r\n            hw = w / 2,\r\n            hh = h / 2;\r\n        \r\n        this.width  = w;\r\n        this.height = h;\r\n        this.halfWidth = hw;\r\n        this.halfHeight = hh;\r\n        if (typeof this.x === 'number') {\r\n            this.left = -hw + this.x;\r\n            this.right = hw + this.x;\r\n        } else {\r\n            this.empty = true;\r\n        }\r\n        if (typeof this.y === 'number') {\r\n            this.top = -hh + this.y;\r\n            this.bottom = hh + this.y;\r\n        } else {\r\n            this.empty = true;\r\n        }\r\n        return this;\r\n    };\r\n    \r\n    /**\r\n     * Changes the size and position of the bounding box so that it contains the current area and the area described in the incoming AABB.\r\n     *\r\n     * @method include\r\n     * @param aabb {platypus.AABB} The AABB whose area will be included in the area of the current AABB.\r\n     * @chainable\r\n     */\r\n    proto.include = function (aabb) {\r\n        if (this.empty) {\r\n            this.set(aabb);\r\n        } else {\r\n            if (this.left > aabb.left) {\r\n                this.left = aabb.left;\r\n            }\r\n            if (this.right < aabb.right) {\r\n                this.right = aabb.right;\r\n            }\r\n            if (this.top > aabb.top) {\r\n                this.top = aabb.top;\r\n            }\r\n            if (this.bottom < aabb.bottom) {\r\n                this.bottom = aabb.bottom;\r\n            }\r\n            \r\n            this.width      = this.right  - this.left;\r\n            this.height     = this.bottom - this.top;\r\n            this.halfWidth  = this.width / 2;\r\n            this.halfHeight = this.height / 2;\r\n            this.x          = this.left + this.halfWidth;\r\n            this.y          = this.top  + this.halfHeight;\r\n        }\r\n        \r\n        return this;\r\n    };\r\n    \r\n    /**\r\n     * Moves the AABB to the specified location.\r\n     *\r\n     * @method move\r\n     * @param x {number} The new x position of the AABB.\r\n     * @param y {number} The new y position of the AABB.\r\n     * @chainable\r\n     */\r\n    proto.move = function (x, y) {\r\n        this.moveX(x);\r\n        this.moveY(y);\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Moves the AABB to the specified location.\r\n     *\r\n     * @method moveX\r\n     * @param x {number} The new x position of the AABB.\r\n     * @chainable\r\n     */\r\n    proto.moveX = function (x) {\r\n        this.x = x;\r\n        this.left   = -this.halfWidth + x;\r\n        this.right  = this.halfWidth + x;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Moves the AABB to the specified location.\r\n     *\r\n     * @method moveY\r\n     * @param y {number} The new y position of the AABB.\r\n     * @chainable\r\n     */\r\n    proto.moveY = function (y) {\r\n        this.y = y;\r\n        this.top    = -this.halfHeight + y;\r\n        this.bottom = this.halfHeight + y;\r\n        return this;\r\n    };\r\n    \r\n    /**\r\n     * Moves the AABB to the specified location.\r\n     *\r\n     * @method moveXBy\r\n     * @param deltaX {number} The change in x position of the AABB.\r\n     * @chainable\r\n     */\r\n    proto.moveXBy = function (deltaX) {\r\n        return this.moveX(this.x + deltaX);\r\n    };\r\n\r\n    /**\r\n     * Moves the AABB to the specified location.\r\n     *\r\n     * @method moveYBy\r\n     * @param deltaY {number} The change in y position of the AABB.\r\n     * @chainable\r\n     */\r\n    proto.moveYBy = function (deltaY) {\r\n        return this.moveY(this.y + deltaY);\r\n    };\r\n\r\n    /**\r\n     * Expresses whether this AABB matches the provided AABB.\r\n     *\r\n     * @method equals\r\n     * @param aabb {platypus.AABB} The AABB to check against.\r\n     * @return {Boolean} Returns `true` if the AABB's match.\r\n     * @since 0.7.5\r\n     */\r\n    proto.equals = function (aabb) {\r\n        return !this.empty && !aabb.empty && (this.left === aabb.left) && (this.top === aabb.top) && (this.right === aabb.right) && (this.bottom === aabb.bottom);\r\n    };\r\n\r\n    /**\r\n     * Expresses whether this AABB contains the given AABB.\r\n     *\r\n     * @method contains\r\n     * @param aabb {platypus.AABB} The AABB to check against\r\n     * @return {boolean} Returns `true` if this AABB contains the other AABB.\r\n     */\r\n    proto.contains = function (aabb) {\r\n        return (aabb.top >= this.top) && (aabb.bottom <= this.bottom) && (aabb.left >= this.left) && (aabb.right <= this.right);\r\n    };\r\n    \r\n    /**\r\n     * Expresses whether this AABB contains the given point.\r\n     *\r\n     * @method containsVector\r\n     * @param vector {platypus.Vector} The vector to check.\r\n     * @return {boolean} Returns `true` if this AABB contains the vector.\r\n     */\r\n    proto.containsVector = function (vector) {\r\n        return this.containsPoint(vector.x, vector.y);\r\n    };\r\n    \r\n    /**\r\n     * Expresses whether this AABB contains the given point.\r\n     *\r\n     * @method containsPoint\r\n     * @param x {number} The x-axis value.\r\n     * @param y {number} The y-axis value.\r\n     * @return {boolean} Returns `true` if this AABB contains the point.\r\n     * @since 0.7.5\r\n     */\r\n    proto.containsPoint = function (x, y) {\r\n        return (y >= this.top) && (y <= this.bottom) && (x >= this.left) && (x <= this.right);\r\n    };\r\n    \r\n    /**\r\n     * Expresses whether this AABB collides with the given AABB. This is similar to `intersects` but returns true for overlapping only, not touching edges.\r\n     *\r\n     * @method collides\r\n     * @param aabb {platypus.AABB} The AABB to check against\r\n     * @return {boolean} Returns `true` if this AABB collides with the other AABB.\r\n     * @since 0.7.4\r\n     */\r\n    proto.collides = function (aabb) {\r\n        return (aabb.bottom > this.top) && (aabb.top < this.bottom) && (aabb.right > this.left) && (aabb.left < this.right);\r\n    };\r\n\r\n    /**\r\n     * Expresses whether this AABB collides with the given point. This is an exclusive version of containsPoint.\r\n     *\r\n     * @method collidesPoint\r\n     * @param x {number} The x-axis value.\r\n     * @param y {number} The y-axis value.\r\n     * @return {boolean} Returns `true` if this AABB collides with the point.\r\n     * @since 0.11.0\r\n     */\r\n    proto.collidesPoint = function (x, y) {\r\n        return (y > this.top) && (y < this.bottom) && (x > this.left) && (x < this.right);\r\n    };\r\n    \r\n    /**\r\n     * Expresses whether this AABB intersects the given AABB. This is similar to `collides` but returns true for overlapping or touching edges.\r\n     *\r\n     * @method intersects\r\n     * @param aabb {platypus.AABB} The AABB to check against\r\n     * @return {boolean} Returns `true` if this AABB intersects the other AABB.\r\n     */\r\n    proto.intersects = function (aabb) {\r\n        return (aabb.bottom >= this.top) && (aabb.top <= this.bottom) && (aabb.right >= this.left) && (aabb.left <= this.right);\r\n    };\r\n\r\n    /**\r\n     * Returns the area of the intersection. If the AABB's do not intersect, `0` is returned.\r\n     *\r\n     * @method getIntersectionArea\r\n     * @param aabb {AABB} The AABB this AABB intersects with.\r\n     * @return {Number} Returns the area of the intersected AABB's.\r\n     */\r\n    proto.getIntersectionArea = function (aabb) {\r\n        var max    = Math.max,\r\n            min    = Math.min;\r\n        \r\n        if (this.intersects(aabb)) {\r\n            return (min(this.bottom, aabb.bottom) - max(this.top,  aabb.top)) * (min(this.right,  aabb.right) - max(this.left, aabb.left));\r\n        } else {\r\n            return 0;\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Returns an AABB from cache or creates a new one if none are available.\r\n     *\r\n     * @method AABB.setUp\r\n     * @return {platypus.AABB} The instantiated AABB.\r\n     * @since 0.7.3\r\n     */\r\n    /**\r\n     * Returns a AABB back to the cache.\r\n     *\r\n     * @method AABB.recycle\r\n     * @param aabb {platypus.AABB} The AABB to be recycled.\r\n     * @since 0.7.3\r\n     */\r\n    /**\r\n     * Relinquishes properties of the AABB and recycles it.\r\n     *\r\n     * @method recycle\r\n     * @since 0.7.3\r\n     */\r\n    recycle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(AABB, 'AABB', AABB, null, true, config__WEBPACK_IMPORTED_MODULE_0___default.a.dev);\r\n    \r\n    return AABB;\r\n}());\n\n//# sourceURL=webpack://platypus/./src/AABB.js?");

/***/ }),

/***/ "./src/ActionState.js":
/*!****************************!*\
  !*** ./src/ActionState.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Data.js */ \"./src/Data.js\");\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StateMap.js */ \"./src/StateMap.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\r\n * This class defines an action state based on one or more inputs. This is used by [EntityController](platypus.components.EntityController.html) to produce event messages listing whether a particular action is \"triggered\", \"pressed\", and/or \"released\".\r\n *\r\n * @namespace platypus\r\n * @class ActionState\r\n * @constructor\r\n * @param event {String} The name of the event to trigger on the Entity.\r\n * @param states {Object} A list of key/value pairs describing what states should be `true` or `false` on the Entity for this action to be triggered.\r\n * @param trigger {Function} The function to be called if one or more inputs are active and the current state of the Entity is valid.\r\n * @return {ActionState} Returns the new ActionState object.\r\n * @since 0.6.8\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var ActionState = function (event, states, trigger) {\r\n            /**\r\n             * The name of the event to trigger on the Entity.\r\n             *\r\n             * @property event\r\n             * @type String\r\n             */\r\n            this.event     = event;\r\n\r\n            /**\r\n             * The function to call if the ActionState is active.\r\n             *\r\n             * @property trigger\r\n             * @type Function\r\n             */\r\n            this.trigger   = trigger;\r\n            \r\n            /**\r\n             * Whether any of the ActionState's inputs are active.\r\n             *\r\n             * @property active\r\n             * @type Boolean\r\n             */\r\n            this.active    = false;\r\n\r\n            /**\r\n             * Whether any of the ActionState's inputs were active last update.\r\n             *\r\n             * @property wasActive\r\n             * @type Boolean\r\n             */\r\n            this.wasActive = false;\r\n\r\n            /**\r\n             * Whether the Entity's state is valid for this ActionState.\r\n             *\r\n             * @property valid\r\n             * @type Boolean\r\n             */\r\n            this.valid     = true;\r\n\r\n            /**\r\n             * Whether the Entity's state was valid for this ActionState last update.\r\n             *\r\n             * @property wasValid\r\n             * @type Boolean\r\n             */\r\n            this.wasValid  = true;\r\n\r\n            /**\r\n             * The state of the Entity that is valid for this ActionState.\r\n             *\r\n             * @property states\r\n             * @type platypus.StateMap\r\n             */\r\n            this.states = _StateMap_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(states);\r\n\r\n            /**\r\n             * The list of input toggles to track control input.\r\n             *\r\n             * @property inputs\r\n             * @type Array\r\n             */\r\n            this.inputs = _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp();\r\n\r\n            /**\r\n             * The message that is passed to the Entity if the ActionState is active.\r\n             *\r\n             * @property stateSummary\r\n             * @type platypus.Data\r\n             */\r\n            this.stateSummary = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(\r\n                \"pressed\",   false,\r\n                \"released\",  false,\r\n                \"triggered\", false\r\n            );\r\n        },\r\n        orArray = function (element) {\r\n            return element;\r\n        },\r\n        proto = ActionState.prototype;\r\n\r\n    /**\r\n     * Updates the state of the action by checking the state of the Entity and whether any inputs are active.\r\n     *\r\n     * @method update\r\n     * @param state {Object} The Entity's `state` property to compare against the ActionState's valid state.\r\n     * @return {Boolean} Whether the ActionState is triggered, pressed, or released.\r\n     */\r\n    proto.update = function (state) {\r\n        var ss = this.stateSummary;\r\n        \r\n        this.valid     = state.includes(this.states);\r\n        this.active    = this.inputs.some(orArray);\r\n        \r\n        ss.pressed     = this.valid && this.active;\r\n        ss.released    = this.wasActive && ((!this.valid && this.wasValid) || (this.valid && !this.active));\r\n        ss.triggered   = this.valid && this.active && !this.wasActive;\r\n        \r\n        this.wasValid  = this.valid;\r\n        this.wasActive = this.active;\r\n        \r\n        return ss.pressed || ss.released || ss.triggered;\r\n    };\r\n    \r\n    /**\r\n     * Triggers events on the Entity related to the ActionState's state. This is necessarily separate from the `update` method since triggered events could affect entity state. The messages have the following form and are only triggered if one of the values is `true`:\r\n     *\r\n     *     {\r\n     *         \"triggered\": true,\r\n     *         \"pressed\": true,\r\n     *         \"released\": false\r\n     *     }\r\n     *\r\n     * Here is a mapping of the various event messages depending on the ActionState's state.\r\n     *\r\n     *     ActionState State:\r\n     *          wasValid:  0 0 0 0  0 0 0 0  1 1 1 1  1 1 1 1\r\n     *             valid:  0 0 0 0  1 1 1 1  0 0 0 0  1 1 1 1\r\n     *         wasActive:  0 0 1 1  0 0 1 1  0 0 1 1  0 0 1 1\r\n     *            active:  0 1 0 1  0 1 0 1  0 1 0 1  0 1 0 1\r\n     *     Events:\r\n     *         triggered:  0 0 0 0  0 1 0 0  0 0 0 0  0 1 0 0\r\n     *           pressed:  0 0 0 0  0 1 0 1  0 0 0 0  0 1 0 1\r\n     *          released:  0 0 0 0  0 0 1 0  0 0 1 1  0 0 1 0\r\n     *\r\n     * @method resolve\r\n     */\r\n    proto.resolve = function () {\r\n        this.trigger(this.event, this.stateSummary);\r\n    };\r\n    \r\n    /**\r\n     * Returns an ActionState from cache or creates a new one if none are available.\r\n     *\r\n     * @method ActionState.setUp\r\n     * @return {platypus.ActionState} The instantiated ActionState.\r\n     * @since 0.7.1\r\n     */\r\n    /**\r\n     * Returns an ActionState back to the cache. Prefer the ActionState's recycle method since it recycles property objects as well.\r\n     *\r\n     * @method ActionState.recycle\r\n     * @param {platypus.ActionState} The ActionState to be recycled.\r\n     * @since 0.7.1\r\n     */\r\n    /**\r\n     * Relinquishes properties of the ActionState and recycles it.\r\n     *\r\n     * @method recycle\r\n     * @since 0.7.1\r\n     */\r\n    recycle__WEBPACK_IMPORTED_MODULE_4__[\"default\"].add(ActionState, 'ActionState', ActionState, function () {\r\n        this.states.recycle();\r\n        this.stateSummary.recycle();\r\n        _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].recycle(this.inputs);\r\n    }, true, config__WEBPACK_IMPORTED_MODULE_3___default.a.dev);\r\n\r\n    return ActionState;\r\n}());\n\n//# sourceURL=webpack://platypus/./src/ActionState.js?");

/***/ }),

/***/ "./src/Async.js":
/*!**********************!*\
  !*** ./src/Async.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\r\n * This class defines an asynchronous set up wherein multiple calls can be made and a final function will be run once the calls are completed. Something like `Promise.all` but better for avoiding garbage collection.\r\n *\r\n * @namespace platypus\r\n * @class Async\r\n * @constructor\r\n * @param functions {Array} An array of functions where each function accepts a `callback` parameter and runs `callback()` on completion to notify the completion of the call.\r\n * @param callback {Function} The function to run once the list of functions has finished.\r\n * @return {platypus.Async} Returns the new Async object.\r\n * @since 0.10.0\r\n */\r\n/*global clearTimeout, setTimeout */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var callback = function (finalCB) {\r\n            this.increment -= 1;\r\n            if (!this.increment) {\r\n                this.resolve = finalCB;\r\n                this.timeout = setTimeout(finalCB, 0); //ensure async to keep code flow consistent.\r\n            }\r\n        },\r\n        final = function (callback) {\r\n            this.resolve = null;\r\n            callback();\r\n            this.recycle();\r\n        },\r\n        Async = function (arr, finalCallback) {\r\n            const finalCB = final.bind(this, finalCallback),\r\n                length = arr.length;\r\n\r\n            if (!length) {\r\n                this.resolve = finalCB;\r\n                this.timeout = setTimeout(finalCB, 0); //ensure async to keep code flow consistent.\r\n            } else {\r\n                const cb = callback.bind(this, finalCB);\r\n                let i = 0;\r\n\r\n                this.increment = length;\r\n                this.resolve = null;\r\n\r\n                for (i = 0; i < length; i++) {\r\n                    arr[i](cb);\r\n                }\r\n            }\r\n        };\r\n\r\n    Async.prototype.attemptResolution = function () {\r\n        if (this.resolve) {\r\n            clearTimeout(this.timeout);\r\n            this.resolve();\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Returns an Async from cache or creates a new one if none are available.\r\n     *\r\n     * @method Async.setUp\r\n     * @return {platypus.Async} The instantiated Async.\r\n     */\r\n    /**\r\n     * Returns an Async back to the cache.\r\n     *\r\n     * @method Async.recycle\r\n     * @param async {platypus.Async} The Async to be recycled.\r\n     */\r\n    /**\r\n     * Relinquishes properties of the Async and recycles it.\r\n     *\r\n     * @method recycle\r\n     */\r\n    recycle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(Async, 'Async', Async, function () {\r\n        this.increment = 0;\r\n        this.resolve = null;\r\n        this.timeout = 0;\r\n    }, true, config__WEBPACK_IMPORTED_MODULE_0___default.a.dev);\r\n\r\n    return Async;\r\n}());\n\n//# sourceURL=webpack://platypus/./src/Async.js?");

/***/ }),

/***/ "./src/CollisionData.js":
/*!******************************!*\
  !*** ./src/CollisionData.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\r\n * CollisionData holds collision data passed to entities during collisions with other entities. This class is primarily used by the [\"HandlerCollision\"](\"HandlerCollision\"%20Component.html) Component to trigger messages on child entities as collision occur.\r\n *\r\n * @namespace platypus\r\n * @class CollisionData\r\n * @constructor\r\n * @param occurredOrData {Boolean|CollisionData} Whether this represents an actual collision between two shapes. If a CollisionData instance is provided, the instance's full set of values are copied.\r\n * @param direction {Number} 1 or -1 to define the direction of the collision.\r\n * @param position {Number} A positive number describing position along the line of collision direction.\r\n * @param deltaMovement {Number} A positive number describing the magnitude of overlap.\r\n * @param aABB {platypus.AABB} An AABB of the colliding shape.\r\n * @param thisShape {platypus.Shape} The moving shape.\r\n * @param thatShape {platypus.Shape} The stationary shape being collided with.\r\n * @param vector {platypus.Vector} The vector describing the contact point.\r\n * @param stuck {Number} The amount of unwarranted overlap if shapes start in a collided position before moving.\r\n * @return {platypus.CollisionData} Returns the new CollisionData object.\r\n */\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var CollisionData = function (occurredOrData) {\r\n            if (!this.vector) {\r\n                this.vector = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\r\n            }\r\n            if (occurredOrData instanceof CollisionData) {\r\n                this.copy(occurredOrData);\r\n            } else {\r\n                this.set.apply(this, arguments);\r\n            }\r\n        },\r\n        proto = CollisionData.prototype;\r\n    \r\n    /**\r\n     * Sets all of the properties of the CollisionData.\r\n     *\r\n     * @method set\r\n     * @param occurred {Boolean} Whether this represents an actual collision between two shapes.\r\n     * @param direction {Number} 1 or -1 to define the direction of the collision.\r\n     * @param position {Number} A positive number describing position along the line of collision direction.\r\n     * @param deltaMovement {Number} A positive number describing the magnitude of overlap.\r\n     * @param aABB {platypus.AABB} An AABB of the colliding shape.\r\n     * @param thisShape {platypus.Shape} The moving shape.\r\n     * @param thatShape {platypus.Shape} The stationary shape being collided with.\r\n     * @param vector {platypus.Vector} The vector describing the contact point.\r\n     * @param stuck {Number} The amount of unwarranted overlap if shapes start in a collided position before moving.\r\n     * @since 0.8.7\r\n     */\r\n    proto.set = function (occurred, direction, position, deltaMovement, aABB, thisShape, thatShape, vector, stuck) {\r\n        this.occurred = occurred || false;\r\n        this.direction = direction || null;\r\n        this.position = position || null;\r\n        this.deltaMovement = deltaMovement || null;\r\n        this.aABB = aABB || null;\r\n        this.thisShape = thisShape || null;\r\n        this.thatShape = thatShape || null;\r\n        this.vector.set(vector);\r\n        this.stuck  = stuck || 0;\r\n    };\r\n\r\n    /**\r\n     * Sets all of the properties of the CollisionData to match those of the provided CollisionData object.\r\n     *\r\n     * @method copy\r\n     * @param dataToCopy {CollisionData} The object values to copy.\r\n     */\r\n    proto.copy = function (dataToCopy) {\r\n        this.occurred         = dataToCopy.occurred;\r\n        this.direction         = dataToCopy.direction;\r\n        this.position         = dataToCopy.position;\r\n        this.deltaMovement     = dataToCopy.deltaMovement;\r\n        this.aABB             = dataToCopy.aABB;\r\n        this.thisShape      = dataToCopy.thisShape;\r\n        this.thatShape      = dataToCopy.thatShape;\r\n        this.vector.setVector(dataToCopy.vector);\r\n        this.stuck          = dataToCopy.stuck;\r\n    };\r\n\r\n    /**\r\n     * Returns an collisionData from cache or creates a new one if none are available.\r\n     *\r\n     * @method CollisionData.setUp\r\n     * @return {platypus.CollisionData} The instantiated CollisionData.\r\n     * @since 0.8.7\r\n     */\r\n    /**\r\n     * Returns a collisionData back to the cache.\r\n     *\r\n     * @method CollisionData.recycle\r\n     * @param collisionData {platypus.CollisionData} The collisionData to be recycled.\r\n     * @since 0.8.7\r\n     */\r\n    /**\r\n     * Relinquishes properties of the collisionData and recycles it.\r\n     *\r\n     * @method recycle\r\n     * @since 0.8.7\r\n     */\r\n    recycle__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(CollisionData, 'CollisionData', CollisionData, null, true, config__WEBPACK_IMPORTED_MODULE_1___default.a.dev);\r\n    \r\n    return CollisionData;\r\n}());\n\n//# sourceURL=webpack://platypus/./src/CollisionData.js?");

/***/ }),

/***/ "./src/CollisionDataContainer.js":
/*!***************************************!*\
  !*** ./src/CollisionDataContainer.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\r\n * CollisionDataContainer holds lists of CollisionData passed to entities during collisions with other entities. This class is primarily used by the [\"HandlerCollision\"](\"HandlerCollision\"%20Component.html) Component to trigger messages on child entities as collisions occur.\r\n *\r\n * @namespace platypus\r\n * @class CollisionDataContainer\r\n * @constructor\r\n * @return {platypus.CollisionDataContainer} Returns the new aabb object.\r\n */\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var CollisionDataContainer = function () {\r\n            if (!this.xData && !this.yData) {\r\n                this.xData = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                this.yData = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                this.xDeltaMovement = Infinity;\r\n                this.yDeltaMovement = Infinity;\r\n            } else {\r\n                this.reset();\r\n            }\r\n        },\r\n        proto = CollisionDataContainer.prototype;\r\n    \r\n    /**\r\n     * Adds a CollisionData object to the container's X-axis if the movement distance is less than or equal to collision data collected so far.\r\n     *\r\n     * @method tryToAddX\r\n     * @param collisionData {platypus.CollisionData} The collision data to add.\r\n     * @return {Boolean} Whether the collision data was added.\r\n     */\r\n    proto.tryToAddX = function (collisionData) {\r\n        if (collisionData.deltaMovement > this.xDeltaMovement) {\r\n            return false;\r\n        } else if (collisionData.deltaMovement < this.xDeltaMovement) {\r\n            this.resetX(collisionData.deltaMovement);\r\n        }\r\n\r\n        this.xData.push(collisionData);\r\n\r\n        return true;\r\n    };\r\n    \r\n    /**\r\n     * Adds a CollisionData object to the container's Y-axis if the movement distance is less than or equal to collision data collected so far.\r\n     *\r\n     * @method tryToAddY\r\n     * @param collisionData {platypus.CollisionData} The collision data to add.\r\n     * @return {Boolean} Whether the collision data was added.\r\n     */\r\n    proto.tryToAddY = function (collisionData) {\r\n        if (collisionData.deltaMovement > this.yDeltaMovement) {\r\n            return false;\r\n        } else if (collisionData.deltaMovement < this.yDeltaMovement) {\r\n            this.resetY(collisionData.deltaMovement);\r\n        }\r\n        \r\n        this.yData.push(collisionData);\r\n        \r\n        return true;\r\n    };\r\n    \r\n    /**\r\n     * Resets the X and Y axes.\r\n     *\r\n     * @method reset\r\n     */\r\n    proto.reset = function () {\r\n        this.resetX(Infinity);\r\n        this.resetY(Infinity);\r\n    };\r\n    \r\n    /**\r\n     * Resets the X axis.\r\n     *\r\n     * @param delta {Number} The delta value of the X-axis.\r\n     * @method resetX\r\n     * @since 0.8.7\r\n     */\r\n    proto.resetX = function (delta) {\r\n        var xData = this.xData,\r\n            i = xData.length;\r\n        \r\n        while (i--) {\r\n            xData[i].recycle();\r\n        }\r\n        xData.length = 0;\r\n        this.xDeltaMovement = delta;\r\n    };\r\n    \r\n    /**\r\n     * Resets the Y axis.\r\n     *\r\n     * @param delta {Number} The delta value of the Y-axis.\r\n     * @method resetY\r\n     * @since 0.8.7\r\n     */\r\n    proto.resetY = function (delta) {\r\n        var yData = this.yData,\r\n            i = yData.length;\r\n        \r\n        while (i--) {\r\n            yData[i].recycle();\r\n        }\r\n        yData.length = 0;\r\n        this.yDeltaMovement = delta;\r\n    };\r\n    \r\n    /**\r\n     * Returns an CollisionDataContainer from cache or creates a new one if none are available.\r\n     *\r\n     * @method CollisionDataContainer.setUp\r\n     * @return {platypus.CollisionDataContainer} The instantiated CollisionDataContainer.\r\n     * @since 0.8.7\r\n     */\r\n    /**\r\n     * Returns a CollisionDataContainer back to the cache.\r\n     *\r\n     * @method CollisionDataContainer.recycle\r\n     * @param CollisionDataContainer {platypus.CollisionDataContainer} The CollisionDataContainer to be recycled.\r\n     * @since 0.8.7\r\n     */\r\n    /**\r\n     * Relinquishes properties of the CollisionDataContainer and recycles it.\r\n     *\r\n     * @method recycle\r\n     * @since 0.8.7\r\n     */\r\n    recycle__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(CollisionDataContainer, 'CollisionDataContainer', CollisionDataContainer, null, true, config__WEBPACK_IMPORTED_MODULE_1___default.a.dev);\r\n\r\n    return CollisionDataContainer;\r\n}());\n\n//# sourceURL=webpack://platypus/./src/CollisionDataContainer.js?");

/***/ }),

/***/ "./src/CollisionShape.js":
/*!*******************************!*\
  !*** ./src/CollisionShape.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\r\n * This class defines a collision shape, which defines the 'space' an entity occupies in the collision system. Currently only rectangle and circle shapes can be created. Collision shapes include an axis-aligned bounding box (AABB) that tightly wraps the shape. The AABB is used for initial collision checks.\r\n *\r\n * @namespace platypus\r\n * @class CollisionShape\r\n * @constructor\r\n * @param owner {platypus.Entity} The entity that uses this shape.\r\n * @param definition {Object} This is an object of key/value pairs describing the shape.\r\n * @param definition.x {number} The x position of the shape. The x is always located in the center of the object.\r\n * @param definition.y {number} The y position of the shape. The y is always located in the center of the object.\r\n * @param [definition.type=\"rectangle\"] {String} The type of shape this is. Currently this can be either \"rectangle\" or \"circle\".\r\n * @param [definition.width] {number} The width of the shape if it's a rectangle.\r\n * @param [definition.height] {number} The height of the shape if it's a rectangle.\r\n * @param [definition.radius] {number} The radius of the shape if it's a circle.\r\n * @param [definition.offsetX] {number} The x offset of the collision shape from the owner entity's location.\r\n * @param [definition.offsetY] {number} The y offset of the collision shape from the owner entity's location.\r\n * @param [definition.regX] {number} The registration x of the collision shape with the owner entity's location if offsetX is not provided.\r\n * @param [definition.regY] {number} The registration y of the collision shape with the owner entity's location if offsetX is not provided.\r\n * @param collisionType {String} A string describing the collision type of this shape.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var circleRectCollision = function (circle, rect) {\r\n            var rectAabb         = rect.aABB,\r\n                hh = rectAabb.halfHeight,\r\n                hw = rectAabb.halfWidth,\r\n                abs = Math.abs,\r\n                pow = Math.pow,\r\n                shapeDistanceX = abs(circle.x - rect.x),\r\n                shapeDistanceY = abs(circle.y - rect.y),\r\n                radius = circle.radius;\r\n            \r\n            /* This checks the following in order:\r\n                - Is the x or y distance between shapes less than half the width or height respectively of the rectangle? If so, we know they're colliding.\r\n                - Is the x or y distance between the shapes greater than the half width/height plus the radius of the circle? Then we know they're not colliding.\r\n                - Otherwise, we check the distance between a corner of the rectangle and the center of the circle. If that distance is less than the radius of the circle, we know that there is a collision; otherwise there is not.\r\n            */\r\n            return (shapeDistanceX < hw) || (shapeDistanceY < hh) || ((shapeDistanceX < (hw + radius)) && (shapeDistanceY < (hh + radius)) && ((pow((shapeDistanceX - hw), 2) + pow((shapeDistanceY - hh), 2)) < pow(radius, 2)));\r\n        },\r\n        collidesCircle = function (shape) {\r\n            var pow = Math.pow;\r\n            \r\n            return this.aABB.collides(shape.aABB) && (\r\n                ((shape.type === 'rectangle') && circleRectCollision(this, shape)) ||\r\n                ((shape.type === 'circle')    && ((pow((this.x - shape.x), 2) + pow((this.y - shape.y), 2)) <= pow((this.radius + shape.radius), 2)))\r\n            );\r\n        },\r\n        collidesDefault = function () {\r\n            return false;\r\n        },\r\n        collidesRectangle = function (shape) {\r\n            return this.aABB.collides(shape.aABB) && (\r\n                (shape.type === 'rectangle') ||\r\n                ((shape.type === 'circle') && circleRectCollision(shape, this))\r\n            );\r\n        },\r\n        CollisionShape = function (owner, definition, collisionType) {\r\n            var regX = definition.regX,\r\n                regY = definition.regY,\r\n                width = definition.width || definition.radius * 2 || 0,\r\n                height = definition.height || definition.radius * 2 || 0,\r\n                radius = definition.radius || 0,\r\n                type = definition.type || 'rectangle';\r\n\r\n            // If this shape is recycled, the vectors will already be in place.\r\n            if (!this.initialized) {\r\n                this.initialized = true;\r\n                _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].assign(this, 'offset', 'offsetX', 'offsetY');\r\n                _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].assign(this, 'position', 'x', 'y');\r\n                _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].assign(this, 'size', 'width', 'height');\r\n                this.aABB = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\r\n            }\r\n\r\n            this.owner = owner;\r\n            this.collisionType = collisionType;\r\n            this.type = type;\r\n            this.subType = '';\r\n            \r\n            /**\r\n             * Determines whether shapes collide.\r\n             *\r\n             * @method collides\r\n             * @param shape {platypus.CollisionShape} The shape to check against for collision.\r\n             * @return {Boolean} Whether the shapes collide.\r\n             * @since 0.7.4\r\n             */\r\n            if (type === 'circle') {\r\n                width = height = radius * 2;\r\n                this.collides = collidesCircle;\r\n            } else if (type === 'rectangle') {\r\n                this.collides = collidesRectangle;\r\n            } else {\r\n                this.collides = collidesDefault;\r\n            }\r\n            this.size.setXYZ(width, height);\r\n            this.radius = radius;\r\n\r\n            if (typeof regX !== 'number') {\r\n                regX = width / 2;\r\n            }\r\n            if (typeof regY !== 'number') {\r\n                regY = height / 2;\r\n            }\r\n            this.offset.setXYZ(definition.offsetX || ((width  / 2) - regX), definition.offsetY || ((height / 2) - regY));\r\n\r\n            if (owner) {\r\n                this.position.setXYZ(owner.x, owner.y).add(this.offset);\r\n            } else {\r\n                this.position.setXYZ(definition.x, definition.y).add(this.offset);\r\n            }\r\n\r\n            this.aABB.setAll(this.x, this.y, width, height);\r\n        },\r\n        proto = CollisionShape.prototype;\r\n\r\n    /**\r\n     * Updates the location of the shape and AABB. The position you send should be that of the owner, the offset of the shape is added inside the function.\r\n     *\r\n     * @method update\r\n     * @param ownerX {number} The x position of the owner.\r\n     * @param ownerY {number} The y position of the owner.\r\n     */\r\n    proto.update = function (ownerX, ownerY) {\r\n        var x = ownerX + this.offsetX,\r\n            y = ownerY + this.offsetY;\r\n\r\n        this.position.setXYZ(x, y);\r\n        this.aABB.move(x, y);\r\n    };\r\n    \r\n    /**\r\n     * Move the shape's x position.\r\n     *\r\n     * @method moveX\r\n     * @param x {number} The x position to which the shape should be moved.\r\n     */\r\n    proto.moveX = function (x) {\r\n        this.x = x;\r\n        this.aABB.moveX(x);\r\n    };\r\n    \r\n    /**\r\n     * Move the shape's y position.\r\n     *\r\n     * @method moveY\r\n     * @param y {number} The y position to which the shape should be moved.\r\n     */\r\n    proto.moveY = function (y) {\r\n        this.y = y;\r\n        this.aABB.moveY(y);\r\n    };\r\n\r\n    /**\r\n     * Move the shape's x and y position.\r\n     *\r\n     * @method moveXY\r\n     * @param x {number} The x position to which the shape should be moved.\r\n     * @param y {number} The y position to which the shape should be moved.\r\n     * @since 0.11.2\r\n     */\r\n    proto.moveXY = function (x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.aABB.move(x, y);\r\n    };\r\n    \r\n    /**\r\n     * Returns the axis-aligned bounding box of the shape.\r\n     *\r\n     * @method getAABB\r\n     * @return {platypus.AABB} The AABB of the shape.\r\n     */\r\n    proto.getAABB = function () {\r\n        return this.aABB;\r\n    };\r\n    \r\n    /**\r\n     * Set the shape's position as if the entity's x position is in a certain location.\r\n     *\r\n     * @method setXWithEntityX\r\n     * @param entityX {number} The x position of the entity.\r\n     */\r\n    proto.setXWithEntityX = function (entityX) {\r\n        this.x = entityX + this.offsetX;\r\n        this.aABB.moveX(this.x);\r\n    };\r\n    \r\n    /**\r\n     * Set the shape's position as if the entity's y position is in a certain location.\r\n     *\r\n     * @method setYWithEntityY\r\n     * @param entityY {number} The y position of the entity.\r\n     */\r\n    proto.setYWithEntityY = function (entityY) {\r\n        this.y = entityY + this.offsetY;\r\n        this.aABB.moveY(this.y);\r\n    };\r\n    \r\n    /**\r\n     * Transform the shape using a matrix transformation.\r\n     *\r\n     * @method multiply\r\n     * @param matrix {Array} A matrix used to transform the shape.\r\n     */\r\n    proto.multiply = function (m) {\r\n        var pos = this.position,\r\n            own = this.owner.position;\r\n        \r\n        pos.subtractVector(own);\r\n        \r\n        pos.multiply(m);\r\n        this.offset.multiply(m);\r\n        this.size.multiply(m);\r\n        \r\n        pos.addVector(own);\r\n        this.width  = Math.abs(this.width);\r\n        this.height = Math.abs(this.height);\r\n        \r\n        this.aABB.setAll(this.x, this.y, this.width, this.height);\r\n    };\r\n\r\n    /**\r\n     * Expresses whether this shape contains the given point.\r\n     *\r\n     * @method containsPoint\r\n     * @param x {number} The x-axis value.\r\n     * @param y {number} The y-axis value.\r\n     * @return {boolean} Returns `true` if this shape contains the point.\r\n     * @since 0.11.0\r\n     */\r\n    proto.containsPoint = function (x, y) {\r\n        var pow = Math.pow;\r\n\r\n        return this.aABB.containsPoint(x, y) && (\r\n            (this.type === 'rectangle') ||\r\n            ((this.type === 'circle') && ((pow((this.x - x), 2) + pow((this.y - y), 2)) <= pow(this.radius, 2)))\r\n        );\r\n    };\r\n    \r\n    /**\r\n    * Returns a JSON object describing the collision shape.\r\n    *\r\n    * @method toJSON\r\n    * @return {Object} Returns a JSON definition that can be used to recreate the collision shape.\r\n    * @since 0.11.0\r\n    **/\r\n    proto.toJSON = function () {\r\n        var json = {},\r\n            width = this.size.width,\r\n            height = this.size.height;\r\n\r\n        if (width / 2 !== this.regX) {\r\n            json.regX = this.regX;\r\n        }\r\n        if (height / 2 !== this.regY) {\r\n            json.regY = this.regY;\r\n        }\r\n        if (this.offset.x !== ((width / 2) - this.regX)) {\r\n            json.offsetX = this.offset.x;\r\n        }\r\n        if (this.offset.y !== ((height / 2) - this.regY)) {\r\n            json.offsetY = this.offset.y;\r\n        }\r\n        if (this.type === 'circle') {\r\n            json.radius = this.radius;\r\n        } else {\r\n            json.width = width;\r\n            json.height = height;\r\n        }\r\n        json.type = this.type;\r\n\r\n        return json;\r\n    };\r\n\r\n    /**\r\n     * Returns an CollisionShape from cache or creates a new one if none are available.\r\n     *\r\n     * @method CollisionShape.setUp\r\n     * @return {platypus.CollisionShape} The instantiated CollisionShape.\r\n     * @since 0.7.4\r\n     */\r\n    /**\r\n     * Returns a CollisionShape back to the cache.\r\n     *\r\n     * @method CollisionShape.recycle\r\n     * @param {platypus.CollisionShape} The CollisionShape to be recycled.\r\n     * @since 0.7.4\r\n     */\r\n    /**\r\n     * Relinquishes properties of the CollisionShape and recycles it.\r\n     *\r\n     * @method recycle\r\n     * @since 0.7.4\r\n     */\r\n    recycle__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(CollisionShape, 'CollisionShape', CollisionShape, null, true, config__WEBPACK_IMPORTED_MODULE_2___default.a.dev);\r\n    \r\n    return CollisionShape;\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/CollisionShape.js?");

/***/ }),

/***/ "./src/Component.js":
/*!**************************!*\
  !*** ./src/Component.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Data.js */ \"./src/Data.js\");\n/**\r\n * This is the extendable Component class. Typically specific component classes should be created using `platypus.createComponentClass()`. This method accepts component definitions and creates component classes that can be used to create components by entities.  It adds properties and methods that are common to all components so that component definitions can focus on unique properties and methods.\r\n *\r\n * To create an extended component class, use the following syntax:\r\n *\r\n *      platypus.createComponentClass(componentDefinition, prototype);\r\n *\r\n *  * `componentDefinition` is list of key/value pairs that describe the component's behavior.\r\n *  * `prototype` is an optional prototype that this component extends.\r\n * See [component-template.js](\"component-template\"%20Component.html) for an example componentDefinition that can be sent into this component class factory.\r\n *\r\n * @namespace platypus\r\n * @class Component\r\n * @static\r\n */\r\n/*global platypus */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var getAssetList = function () {\r\n            return _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n        },\r\n        Component = function (type, owner) {\r\n            this.type = type;\r\n            this.owner = owner;\r\n            this.publicMethods = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\r\n            this.listener = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\r\n                \"events\", _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                \"messages\", _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp()\r\n            );\r\n        },\r\n        proto = Component.prototype;\r\n    \r\n    /**\r\n     * Returns a string describing the component.\r\n     *\r\n     * @method toString\r\n     * @return {String} Returns the component type as a string of the form \"[Component ComponentType]\".\r\n     **/\r\n    proto.toString = function () {\r\n        return \"[Component \" + this.type + \"]\";\r\n    };\r\n\r\n    /**\r\n     * Returns a JSON object describing the component.\r\n     *\r\n     * @method toJSON\r\n     * @return {Object} Returns a JSON definition that can be used to recreate the component.\r\n     * @since 0.11.0\r\n     **/\r\n    proto.toJSON = null; // defined in factory.js\r\n\r\n    /**\r\n     * This method cleans up listeners and methods that this component added to the entity. It should never be called by the component itself. Call this.owner.removeComponent(this) instead.\r\n     *\r\n     * @method destroy\r\n     * @private\r\n     */\r\n    proto.destroy = function () {\r\n        var func = '';\r\n        \r\n        if (this.listener) {\r\n            // Handle component's destroy method before removing messaging and methods.\r\n            if (this._destroy) {\r\n                this._destroy();\r\n            }\r\n            \r\n            // Now remove event listeners and methods.\r\n            for (func in this.publicMethods) {\r\n                if (this.publicMethods.hasOwnProperty(func)) {\r\n                    this.removeMethod(func);\r\n                }\r\n            }\r\n            this.publicMethods.recycle();\r\n            \r\n            this.removeEventListeners();\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.listener.events);\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.listener.messages);\r\n            this.listener.recycle();\r\n            this.listener = null;\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * This method removes multiple event listeners from the entity.\r\n     *\r\n     * @method removeEventListeners\r\n     * @param [listeners] {Array} The list of listeners to remove. If not supplied, all event listeners are removed.\r\n     * @private\r\n     */\r\n    proto.removeEventListeners = function (listeners) {\r\n        var i = 0,\r\n            events   = null,\r\n            messages = null;\r\n        \r\n        if (!listeners) {\r\n            events   = this.listener.events;\r\n            messages = this.listener.messages;\r\n            for (i = 0; i < events.length; i++) {\r\n                this.owner.off(events[i], messages[i]);\r\n            }\r\n            events.length = 0;\r\n            messages.length = 0;\r\n        } else {\r\n            for (i = 0; i < listeners.length; i++) {\r\n                this.removeEventListener(listeners[i]);\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * This method adds an event listener to the entity.\r\n     *\r\n     * @method addEventListener\r\n     * @param event {String} The event that this component should listen for.\r\n     * @param callback {Function} The handler for the event.\r\n     * @return handler {Function} A reference to the bound handler.\r\n     * @private\r\n     */\r\n    proto.addEventListener = function (event, callback, priority) {\r\n        var handler = callback.bind(this);\r\n        \r\n        this.listener.events.push(event);\r\n        this.listener.messages.push(handler);\r\n        this.owner.on(event, handler, priority);\r\n\r\n        return handler;\r\n    };\r\n    \r\n    /**\r\n     * This method adds a method to the entity.\r\n     *\r\n     * @method addMethod\r\n     * @param name {String} The name of the method. For example, if name is \"turnYellow\", the method is accessible on the entity as `entity.turnYellow()`.\r\n     * @param func {Function} The function describing the method.\r\n     * @private\r\n     */\r\n    proto.addMethod = function (name, func) {\r\n        if (this.owner[name]) {\r\n            platypus.debug.warn(this.owner.type + ': Entity already has a method called \"' + name + '\". Method not added.');\r\n        } else {\r\n            this.owner[name] = function () {\r\n                return func.apply(this, arguments);\r\n            }.bind(this);\r\n            this.publicMethods[name] = func;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * This method removes an event listener from the entity.\r\n     *\r\n     * @method removeEventListener\r\n     * @param event {String} The event for which to remove a listener.\r\n     * @param callback {Function} The listener to remove. If not supplied, all event listeners for the provided event are removed.\r\n     * @private\r\n     */\r\n    proto.removeEventListener = function (event, callback) {\r\n        var i = 0,\r\n            events   = this.listener.events,\r\n            messages = this.listener.messages;\r\n        \r\n        for (i = events.length - 1; i >= 0; i--) {\r\n            if ((events[i] === event) && (!callback || (messages[i] === callback))) {\r\n                this.owner.off(event, messages[i]);\r\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.listener.events, i);\r\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.listener.messages, i);\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * This method removes a method from the entity.\r\n     *\r\n     * @method removeMethod\r\n     * @param name {String} The name of the method to be removed.\r\n     * @private\r\n     */\r\n    proto.removeMethod = function (name) {\r\n        if (!this.owner[name]) {\r\n            platypus.debug.warn(this.owner.type + ': Entity does not have a method called \"' + name + '\".');\r\n        } else {\r\n            delete this.owner[name];\r\n        }\r\n        delete this.publicMethods[name];\r\n    };\r\n\r\n    /**\r\n     * This method can be overwritten to provide the list of assets this component requires. This method is invoked when the list of game scenes is created to determine assets for each scene.\r\n     *\r\n     * @method getAssetList\r\n     * @param definition {Object} The definition for the component.\r\n     * @param properties {Object} The properties of the Entity.\r\n     * @param defaultProperties {Object} The default properties of the Entity.\r\n     * @return {Array} A list of the necessary assets to load.\r\n     */\r\n    Component.getAssetList = getAssetList;\r\n\r\n    /**\r\n     * This method can be overwritten to provide the list of assets this component requires. This method is invoked when the list of game scenes is created to determine assets for each scene.\r\n     *\r\n     * @method getLateAssetList\r\n     * @param data {Object} Scene data that affects the list of assets.\r\n     * @return {Array} A list of the necessary assets to load.\r\n     */\r\n    Component.getLateAssetList = getAssetList;\r\n    \r\n    return Component;\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/Component.js?");

/***/ }),

/***/ "./src/Data.js":
/*!*********************!*\
  !*** ./src/Data.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\r\n * This class defines a generic data object to use for messaging. It includes recycle methods to encourage reuse.\r\n *\r\n * @namespace platypus\r\n * @class Data\r\n * @constructor\r\n * @return {Data} Returns the new Data object.\r\n * @since 0.7.1\r\n */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var\r\n        Data = function (first) {\r\n            var i = arguments.length,\r\n                key = '';\r\n            \r\n            if (first) {\r\n                if (typeof first === 'string') {\r\n                    if (i % 2) {\r\n                        this[i] = null;\r\n                        i -= 1;\r\n                    }\r\n                    while (i) {\r\n                        this[arguments[i - 2]] = arguments[i - 1];\r\n                        i -= 2;\r\n                    }\r\n                } else {\r\n                    for (key in first) {\r\n                        if (first.hasOwnProperty(key)) {\r\n                            this[key] = first[key];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    \r\n    /**\r\n     * Returns Data from cache or creates a new one if none are available.\r\n     *\r\n     * @method Data.setUp\r\n     * @return {platypus.Data} The instantiated Data.\r\n     * @since 0.7.1\r\n     */\r\n    /**\r\n     * Returns Data back to the cache. Prefer the Data's recycle method since it recycles property objects as well.\r\n     *\r\n     * @method Data.recycle\r\n     * @param {platypus.Data} The Data to be recycled.\r\n     * @since 0.7.1\r\n     */\r\n    /**\r\n     * Relinquishes Data properties and recycles it.\r\n     *\r\n     * @method recycle\r\n     * @since 0.7.1\r\n     */\r\n    recycle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(Data, 'Data', Data, function () {\r\n        var key = '';\r\n        \r\n        for (key in this) {\r\n            if (this.hasOwnProperty(key)) {\r\n                delete this[key];\r\n            }\r\n        }\r\n    }, true, config__WEBPACK_IMPORTED_MODULE_0___default.a.dev);\r\n    \r\n    return Data;\r\n}());\n\n//# sourceURL=webpack://platypus/./src/Data.js?");

/***/ }),

/***/ "./src/DataMap.js":
/*!************************!*\
  !*** ./src/DataMap.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polyfills_Map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfills/Map.js */ \"./src/polyfills/Map.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\r\n * This class defines a generic iterable data object. It behaves similarly to Map but maintains a list of keys as an Array. It includes recycle methods to encourage reuse.\r\n *\r\n * @namespace platypus\r\n * @class DataMap\r\n * @constructor\r\n * @return dataMap {platypus.DataMap} Returns the new DataMap object.\r\n * @uses Map\r\n * @since 0.8.0\r\n */\r\n/* global window */\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var Map = window.Map,\r\n        mapSet = function (keys, key, value) {\r\n            if (this.get(key) !== value) {\r\n                if (!this.has(key)) {\r\n                    keys.push(key);\r\n                }\r\n                this.set(key, value);\r\n            }\r\n            return value;\r\n        },\r\n        mapDelete = function (keys, key) {\r\n            var i = keys.indexOf(key),\r\n                value = this.get(key);\r\n            \r\n            if (i >= 0) {\r\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"greenSplice\"])(keys, i);\r\n                this.delete(key);\r\n            }\r\n            \r\n            return value;\r\n        },\r\n        mapClear = function (keys) {\r\n            var i = keys.length;\r\n            \r\n            while (i--) {\r\n                this.delete(keys[i]);\r\n            }\r\n            keys.length = 0;\r\n        },\r\n        mapToJSON = function (keys) {\r\n            var i = keys.length,\r\n                json = {};\r\n            \r\n            while (i--) {\r\n                json[keys[i]] = this.get(keys[i]);\r\n            }\r\n\r\n            return json;\r\n        },\r\n        mapMethods = {\r\n            get: {\r\n                value: null\r\n            },\r\n            has: {\r\n                value: null\r\n            },\r\n            keys: {\r\n                value: null\r\n            },\r\n            set: {\r\n                value: null\r\n            },\r\n            delete: {\r\n                value: null\r\n            },\r\n            clear: {\r\n                value: null\r\n            },\r\n            toJSON: {\r\n                value: null\r\n            }\r\n        },\r\n        DataMap = function (first) {\r\n            var i = arguments.length,\r\n                key = '',\r\n                keys = null,\r\n                map = null,\r\n                mm = null;\r\n            \r\n            if (!this.map) {\r\n                mm = mapMethods;\r\n                map = this.map = new Map();\r\n                \r\n                /**\r\n                 * Tracks keys on this object to make iteration faster.\r\n                 *\r\n                 * @property keys\r\n                 * @type Array\r\n                 * @default []\r\n                 */\r\n                keys = mm.keys.value = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n                \r\n                /**\r\n                 * Returns the value of the provided key.\r\n                 *\r\n                 * @method get\r\n                 * @param key {String} The key to lookup.\r\n                 * @return value {any} The value of the provded key.\r\n                 */\r\n                mm.get.value = map.get.bind(map);\r\n                \r\n                /**\r\n                 * Determines whether the provided key is available on this DataMap.\r\n                 *\r\n                 * @method has\r\n                 * @param key {String} The key to lookup.\r\n                 * @return value {Boolean} Whether the key is listed in this DataMap.\r\n                 */\r\n                mm.has.value = map.has.bind(map);\r\n                \r\n                /**\r\n                 * Sets a value to a key in the DataMap.\r\n                 *\r\n                 * @method set\r\n                 * @param key {String} The key to associate with the provided value.\r\n                 * @param value {any} The value to be stored by the DataMap.\r\n                 * @return value {any} The value passed in is returned for chaining.\r\n                 */\r\n                mm.set.value = mapSet.bind(map, keys);\r\n                \r\n                /**\r\n                 * Deletes a key (and value) from the DataMap.\r\n                 *\r\n                 * @method delete\r\n                 * @param key {String} The key to delete from the DataMap.\r\n                 * @return value {any} The value of the key is returned.\r\n                 */\r\n                mm.delete.value = mapDelete.bind(map, keys);\r\n                \r\n                /**\r\n                 * Clears out of keys (and values) from the DataMap.\r\n                 *\r\n                 * @method clear\r\n                 */\r\n                mm.clear.value = mapClear.bind(map, keys);\r\n                            \r\n                /**\r\n                 * Returns a JSON object describing the component.\r\n                 *\r\n                 * @method toJSON\r\n                 * @return {Object} Returns a JSON definition that can be used to recreate the component.\r\n                 * @since 0.11.0\r\n                 **/\r\n                mm.toJSON.value = mapToJSON.bind(map, keys);\r\n                \r\n                Object.defineProperties(this, mm);\r\n            }\r\n            \r\n            if (first) {\r\n                keys = first.keys;\r\n\r\n                if (typeof first === 'string') {\r\n                    if (i % 2) {\r\n                        i -= 1;\r\n                        this.set(arguments[i], null);\r\n                    }\r\n                    while (i) {\r\n                        i -= 2;\r\n                        this.set(arguments[i], arguments[i + 1]);\r\n                    }\r\n                } else if (keys) {\r\n                    i = keys.length;\r\n                    while (i--) {\r\n                        this.set(keys[i], first.get(keys[i]));\r\n                    }\r\n                } else {\r\n                    for (key in first) {\r\n                        if (first.hasOwnProperty(key)) {\r\n                            this.set(key, first[key]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n    /**\r\n     * Returns DataMap from cache or creates a new one if none are available.\r\n     *\r\n     * @method DataMap.setUp\r\n     * @return dataMap {platypus.DataMap} The instantiated DataMap.\r\n     */\r\n    /**\r\n     * Returns DataMap back to the cache. Prefer the DataMap's recycle method since it recycles property objects as well.\r\n     *\r\n     * @method DataMap.recycle\r\n     * @param dataMap {platypus.DataMap} The DataMap to be recycled.\r\n     */\r\n    /**\r\n     * Relinquishes DataMap properties and recycles it.\r\n     *\r\n     * @method recycle\r\n     */\r\n    recycle__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(DataMap, 'DataMap', DataMap, function () {\r\n        this.clear();\r\n    }, true, config__WEBPACK_IMPORTED_MODULE_2___default.a.dev);\r\n    \r\n    return DataMap;\r\n}());\n\n//# sourceURL=webpack://platypus/./src/DataMap.js?");

/***/ }),

/***/ "./src/Entity.js":
/*!***********************!*\
  !*** ./src/Entity.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Async_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Async.js */ \"./src/Async.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Data.js */ \"./src/Data.js\");\n/* harmony import */ var _Messenger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Messenger.js */ \"./src/Messenger.js\");\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./StateMap.js */ \"./src/StateMap.js\");\n/**\r\n * The Entity object acts as a container for components, facilitates communication between components and other game objects, and includes properties set by components to maintain a current state. The entity object serves as the foundation for most of the game objects in the platypus engine.\r\n *\r\n * ## JSON Definition Example\r\n     {\r\n         \"id\": \"entity-id\",\r\n         // \"entity-id\" becomes `entity.type` once the entity is created.\r\n      \r\n         \"components\": [\r\n         // This array lists one or more component definition objects\r\n      \r\n             {\"type\": \"example-component\"}\r\n            // The component objects must include a \"type\" property corresponding to a component to load, but may also include additional properties to customize the component in a particular way for this entity.\r\n         ],\r\n      \r\n         \"properties\": {\r\n         // This object lists properties that will be attached directly to this entity.\r\n      \r\n             \"x\": 240\r\n             // For example, `x` becomes `entity.x` on the new entity.\r\n         }\r\n     }\r\n *\r\n * @namespace platypus\r\n * @class Entity\r\n * @constructor\r\n * @extends Messenger\r\n * @param [definition] {Object} Base definition for the entity.\r\n * @param [definition.id] {Object} This declares the type of entity and will be stored on the Entity as `entity.type` after instantiation.\r\n * @param [definition.components] {Object} This lists the components that should be attached to this entity.\r\n * @param [definition.properties] {Object} [definition.properties] This is a list of key/value pairs that are added directly to the Entity as `entity.key = value`.\r\n * @param [instanceDefinition] {Object} Specific instance definition including properties that override the base definition properties.\r\n * @param [instanceDefinition.properties] {Object} This is a list of key/value pairs that are added directly to the Entity as `entity.key = value`.\r\n * @param [callback] {Function} A function to run once all of the components on the Entity have been loaded. The first parameter is the entity itself.\r\n * @param [parent] {Entity} Presets the parent of the entity so that the parent entity is available during component instantiation. Overrides `parent` in properties definitions.\r\n * @return {Entity} Returns the new entity made up of the provided components.\r\n**/\r\n\r\n/*global platypus */\r\n\r\n\r\n\r\n\r\n\r\n        \r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var componentInit = function (Component, componentDefinition, callback) {\r\n            this.addComponent(new Component(this, componentDefinition, callback));\r\n        },\r\n        entityIds = {};\r\n\r\n    class Entity extends _Messenger_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\r\n        constructor (definition, instanceDefinition, callback, parent) {\r\n            var i                    = 0,\r\n                componentDefinition  = null,\r\n                componentInits       = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                def                  = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(definition),\r\n                componentDefinitions = def.components,\r\n                defaultProperties    = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(def.properties),\r\n                instance             = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(instanceDefinition),\r\n                instanceProperties   = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(instance.properties),\r\n                savedEvents          = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                savedMessages        = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n\r\n            // Set properties of messenger on this entity.\r\n            super();\r\n\r\n            this.components  = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.type = def.id || 'none';\r\n\r\n            this.id = instance.id || instanceProperties.id;\r\n            if (this.id) { // check to make sure auto-ids don't overlap.\r\n                if (this.id.search(this.type + '-') === 0) {\r\n                    i = parseInt(this.id.substring(this.id.search('-') + 1), 10);\r\n                    if (!isNaN(i) && (!entityIds[this.type] || (entityIds[this.type] <= i))) {\r\n                        entityIds[this.type] = i + 1;\r\n                    }\r\n                }\r\n            } else {\r\n                if (!entityIds[this.type]) {\r\n                    entityIds[this.type] = 0;\r\n                }\r\n                this.id = this.type + '-' + entityIds[this.type];\r\n                entityIds[this.type] += 1;\r\n            }\r\n\r\n            this.setProperty(defaultProperties); // This takes the list of properties in the JSON definition and appends them directly to the object.\r\n            this.setProperty(instanceProperties); // This takes the list of options for this particular instance and appends them directly to the object.\r\n            this.on('set-property', function (keyValuePairs) {\r\n                this.setProperty(keyValuePairs);\r\n            }.bind(this));\r\n\r\n            this.state = _StateMap_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(this.state); //starts with no state information. This expands with boolean value properties entered by various logic components.\r\n            this.lastState = _StateMap_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(); //This is used to determine if the state of the entity has changed.\r\n            \r\n            if (parent) {\r\n                this.parent = parent;\r\n            }\r\n\r\n            this.trigger = this.triggerEvent = function (event, message) {\r\n                savedEvents.push(event);\r\n                savedMessages.push(message);\r\n\r\n                return -1; // Message has not been delivered yet.\r\n            };\r\n            \r\n            if (componentDefinitions) {\r\n                for (i = 0; i < componentDefinitions.length; i++) {\r\n                    componentDefinition = componentDefinitions[i];\r\n                    if (componentDefinition) {\r\n                        if (componentDefinition.type) {\r\n                            if (platypus.components[componentDefinition.type]) {\r\n                                componentInits.push(componentInit.bind(this, platypus.components[componentDefinition.type], componentDefinition));\r\n                            } else {\r\n                                platypus.debug.warn('Entity \"' + this.type + '\": Component \"' + componentDefinition.type + '\" is not defined.', componentDefinition);\r\n                            }\r\n                        } else if (componentDefinition.id) { // \"type\" not specified, so we create the component directly.\r\n                            componentInits.push(componentInit.bind(this, platypus.createComponentClass(componentDefinition), null));\r\n                        } else if (typeof componentDefinition === 'function') {\r\n                            componentInits.push(componentInit.bind(this, componentDefinition, null));\r\n                        } else {\r\n                            platypus.debug.warn('Entity \"' + this.type + '\": Component must have an `id` or `type` value.', componentDefinition);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.loadingComponents = _Async_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(componentInits, function () {\r\n                this.loadingComponents = null;\r\n\r\n                // Trigger saved events that were being fired during component addition.\r\n                delete this.trigger;\r\n                delete this.triggerEvent;\r\n                for (i = 0; i < savedEvents.length; i++) {\r\n                    this.trigger(savedEvents[i], savedMessages[i]);\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(savedEvents);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(savedMessages);\r\n\r\n                /**\r\n                 * The entity triggers `load` on itself once all the properties and components have been attached, notifying the components that all their peer components are ready for messages.\r\n                 *\r\n                 * @event load\r\n                 */\r\n                this.triggerEvent('load');\r\n\r\n                if (callback) {\r\n                    callback(this);\r\n                }\r\n            }.bind(this));\r\n            \r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(componentInits);\r\n            def.recycle();\r\n            defaultProperties.recycle();\r\n            instance.recycle();\r\n            instanceProperties.recycle();\r\n        }\r\n\r\n        /**\r\n        * Returns a string describing the entity.\r\n        *\r\n        * @method toString\r\n        * @return {String} Returns the entity type as a string of the form \"[Entity entity-type]\".\r\n        **/\r\n        toString () {\r\n            return \"[Entity \" + this.type + \"]\";\r\n        }\r\n        \r\n        /**\r\n        * Returns a JSON object describing the entity.\r\n        *\r\n        * @method toJSON\r\n        * @param includeComponents {Boolean} Whether the returned JSON should list components. Defaults to `false` to condense output since components are generally defined in `platypus.game.settings.entities`, but may be needed for custom-constructed entities not so defined.\r\n        * @return {Object} Returns a JSON definition that can be used to recreate the entity.\r\n        * @since 0.11.0\r\n        **/\r\n        toJSON (includeComponents) {\r\n            var components = this.components,\r\n                definition = {\r\n                    properties: {\r\n                        id: this.id,\r\n                        state: this.state.toJSON()\r\n                    }\r\n                },\r\n                i = 0,\r\n                json = null,\r\n                properties = definition.properties;\r\n            \r\n            if (includeComponents) {\r\n                definition.id = this.type;\r\n                definition.components = [];\r\n            } else {\r\n                definition.type = this.type;\r\n            }\r\n\r\n            for (i = 0; i < components.length; i++) {\r\n                json = components[i].toJSON(properties);\r\n                if (includeComponents && json) {\r\n                    definition.components.push(json);\r\n                }\r\n            }\r\n\r\n            return definition;\r\n        }\r\n        \r\n        /**\r\n        * Attaches the provided component to the entity.\r\n        *\r\n        * @method addComponent\r\n        * @param {platypus.Component} component Must be an object that functions as a Component.\r\n        * @return {platypus.Component} Returns the same object that was submitted.\r\n        **/\r\n        addComponent (component) {\r\n            this.components.push(component);\r\n\r\n            /**\r\n             * The entity triggers `component-added` on itself once a component has been attached, notifying other components of their peer component.\r\n             *\r\n             * @event component-added\r\n             * @param {platypus.Component} component The added component.\r\n             * @param {String} component.type The type of component.\r\n             **/\r\n            this.triggerEvent('component-added', component);\r\n            return component;\r\n        }\r\n        \r\n        /**\r\n        * Removes the mentioned component from the entity.\r\n        *\r\n        * @method removeComponent\r\n        * @param {Component} component Must be a [[Component]] attached to the entity.\r\n        * @return {Component} Returns the same object that was submitted if removal was successful; otherwise returns false (the component was not found attached to the entity).\r\n        **/\r\n        removeComponent (component) {\r\n            var i = 0;\r\n            \r\n            /**\r\n             * The entity triggers `component-removed` on itself once a component has been removed, notifying other components of their peer component's removal.\r\n             *\r\n             * @event component-removed\r\n             * @param {Component} component The removed component.\r\n             * @param {String} component.type The type of component.\r\n             **/\r\n            if (typeof component === 'string') {\r\n                for (i = 0; i < this.components.length; i++) {\r\n                    if (this.components[i].type === component) {\r\n                        component = this.components[i];\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.components, i);\r\n                        this.triggerEvent('component-removed', component);\r\n                        component.destroy();\r\n                        return component;\r\n                    }\r\n                }\r\n            } else {\r\n                for (i = 0; i < this.components.length; i++) {\r\n                    if (this.components[i] === component) {\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.components, i);\r\n                        this.triggerEvent('component-removed', component);\r\n                        component.destroy();\r\n                        return component;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            return false;\r\n        }\r\n        \r\n        /**\r\n        * This method sets one or more properties on the entity.\r\n        *\r\n        * @param {Object} properties A list of key/value pairs to set as properties on the entity.\r\n        * @method setProperty\r\n        **/\r\n        setProperty (properties) {\r\n            var index = '';\r\n            \r\n            for (index in properties) { // This takes a list of properties and appends them directly to the object.\r\n                if (properties.hasOwnProperty(index)) {\r\n                    this[index] = properties[index];\r\n                }\r\n            }\r\n        }\r\n        \r\n        /**\r\n        * This method removes all components from the entity.\r\n        *\r\n        * @method destroy\r\n        **/\r\n        destroy () {\r\n            var components = this.components,\r\n                i = 0,\r\n                length = components.length;\r\n            \r\n            if (!this._destroyed) {\r\n                for (i = 0; i < length; i++) {\r\n                    components[i].destroy();\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(components);\r\n                this.components = null;\r\n                \r\n                this.state.recycle();\r\n                this.state = null;\r\n                \r\n                this.lastState.recycle();\r\n                this.lastState = null;\r\n                \r\n                super.destroy();\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Returns all of the assets required for this Entity. This method calls the corresponding method on all components to determine the list of assets.\r\n         *\r\n         * @method getAssetList\r\n         * @param definition {Object} The definition for the Entity.\r\n         * @param properties {Object} Properties for this instance of the Entity.\r\n         * @return {Array} A list of the necessary assets to load.\r\n         */\r\n        static getAssetList (def, props) {\r\n            var i = 0,\r\n                component = null,\r\n                arr = null,\r\n                assets = null,\r\n                definition = null;\r\n            \r\n            if (def.type) {\r\n                definition = platypus.game.settings.entities[def.type];\r\n                if (!definition) {\r\n                    platypus.debug.warn('Entity \"' + def.type + '\": This entity is not defined.', def);\r\n                    return assets;\r\n                }\r\n                return Entity.getAssetList(definition, def.properties);\r\n            }\r\n            \r\n            assets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n\r\n            for (i = 0; i < def.components.length; i++) {\r\n                component = def.components[i] && def.components[i].type && platypus.components[def.components[i].type];\r\n                if (component) {\r\n                    arr = component.getAssetList(def.components[i], def.properties, props);\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\r\n                }\r\n            }\r\n            \r\n            return assets;\r\n        }\r\n        \r\n        /**\r\n         * Returns all of the assets required for this Entity. This method calls the corresponding method on all components to determine the list of assets.\r\n         *\r\n         * @method getLateAssetList\r\n         * @param definition {Object} The definition for the Entity.\r\n         * @param data {Object} Scene data that affects asset list.\r\n         * @return {Array} A list of the necessary assets to load.\r\n         */\r\n        static getLateAssetList (def, props, data) {\r\n            var i = 0,\r\n                component = null,\r\n                arr = null,\r\n                assets = null;\r\n            \r\n            if (def.type) {\r\n                return Entity.getLateAssetList(platypus.game.settings.entities[def.type], props, data);\r\n            }\r\n            \r\n            assets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n\r\n            for (i = 0; i < def.components.length; i++) {\r\n                component = def.components[i] && def.components[i].type && platypus.components[def.components[i].type];\r\n                if (component) {\r\n                    arr = component.getLateAssetList(def.components[i], def.properties, props, data);\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\r\n                }\r\n            }\r\n            \r\n            return assets;\r\n        };\r\n    }\r\n    \r\n    return Entity;\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/Entity.js?");

/***/ }),

/***/ "./src/Game.js":
/*!*********************!*\
  !*** ./src/Game.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var springroll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! springroll */ \"springroll\");\n/* harmony import */ var springroll__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(springroll__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Messenger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Messenger.js */ \"./src/Messenger.js\");\n/* harmony import */ var _Scene_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Scene.js */ \"./src/Scene.js\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! pixi-sound */ \"pixi-sound\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(pixi_sound__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _Storage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Storage.js */ \"./src/Storage.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tweenjs/tween.js */ \"@tweenjs/tween.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _sayHello_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sayHello.js */ \"./src/sayHello.js\");\n/**\r\n * This class is used to create the `platypus.game` object and loads the Platypus game as described by the game configuration files.\r\n *\r\n * @namespace platypus\r\n * @class Game\r\n * @constructor\r\n * @param definition {Object} Collection of configuration settings, typically from config.json.\r\n * @param applicationInstance {springroll.Application} The Spring Roll application that the Platypus game is in.\r\n * @param [onFinishedLoading] {Function} An optional function to run once the game has begun.\r\n * @return {platypus.Game} Returns the instantiated game.\r\n */\r\n/* global document, platypus, window */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var XMLHttpRequest = window.XMLHttpRequest,\r\n        getJSON = function (path, callback) {\r\n            var xhr = new XMLHttpRequest();\r\n            \r\n            xhr.open('GET', path, true);\r\n            xhr.responseType = 'text';\r\n            xhr.onload = function () {\r\n                var obj = null;\r\n                \r\n                if (xhr.status === 200) {\r\n                    try {\r\n                        obj = JSON.parse(xhr.responseText);\r\n                    } catch (e) {\r\n                        platypus.debug.warn('Error parsing \"' + path + '\": ' + e.message);\r\n                    }\r\n                } else {\r\n                    platypus.debug.warn('Error opening \"' + path + '\": ' + xhr.description);\r\n                }\r\n                \r\n                callback(obj);\r\n            };\r\n            xhr.send();\r\n        },\r\n        loadJSONLinks = function (obj, callback) {\r\n            var i = 0,\r\n                key = '',\r\n                callbacks = 0,\r\n                resolve = function () {\r\n                    callbacks -= 1;\r\n                    if (!callbacks) {\r\n                        callback(obj);\r\n                    }\r\n                },\r\n                assign = function (obj, i, callback) {\r\n                    loadJSONLinks(obj[i], function (result) {\r\n                        obj[i] = result;\r\n                        callback(result);\r\n                    });\r\n                };\r\n            \r\n            if (obj) {\r\n                if (Array.isArray(obj)) {\r\n                    callbacks = obj.length;\r\n                    if (callbacks) {\r\n                        for (i = 0; i < obj.length; i++) {\r\n                            assign(obj, i, resolve);\r\n                        }\r\n                    } else {\r\n                        callback(obj);\r\n                    }\r\n                    return;\r\n                } else if (typeof obj === 'object') {\r\n                    if (obj.src && (obj.src.length > 5) && (obj.src.substring(obj.src.length - 5).toLowerCase() === '.json')) {\r\n                        loadJSONLinks(obj.src, function (result) {\r\n                            if (obj.src !== result) {\r\n                                obj = result;\r\n                            }\r\n                            callback(obj);\r\n                        });\r\n                    } else {\r\n                        for (key in obj) {\r\n                            if (obj.hasOwnProperty(key)) {\r\n                                callbacks += 1;\r\n                            }\r\n                        }\r\n                        if (callbacks) {\r\n                            for (key in obj) {\r\n                                if (obj.hasOwnProperty(key)) {\r\n                                    assign(obj, key, resolve);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            callback(obj);\r\n                        }\r\n                    }\r\n                    return;\r\n                } else if ((typeof obj === 'string') && (obj.length > 5) && (obj.substring(obj.length - 5).toLowerCase() === '.json')) {\r\n                    getJSON(obj, function (result) {\r\n                        if (typeof result === 'object') {\r\n                            loadJSONLinks(result, callback);\r\n                        } else {\r\n                            callback(result);\r\n                        }\r\n                    });\r\n                    return;\r\n                }\r\n            }\r\n            \r\n            callback(obj);\r\n        },\r\n        load = function (scene, data) {\r\n            var id = '',\r\n                sceneInstance = null;\r\n            \r\n            if (!scene) {\r\n                platypus.debug.warn('Game: A scene id or scene definition must be provided to load a scene.');\r\n                return;\r\n            } else if (typeof scene === 'string') {\r\n                if (!this.scenes[scene]) {\r\n                    platypus.debug.warn('Game: A scene with the id \"' + scene + '\" has not been defined in the game settings.');\r\n                    return;\r\n                }\r\n                this.scenes[scene].data = data; //sets data to send to next scene.\r\n                id = scene;\r\n            } else {\r\n                id = scene.id = scene.id || \"new-scene\";\r\n                sceneInstance = new _Scene_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](new pixi_js__WEBPACK_IMPORTED_MODULE_1__[\"Container\"](), scene);\r\n                sceneInstance.data = data;\r\n                this.scenes[id] = sceneInstance;\r\n                this.stage.addChild(sceneInstance.panel);\r\n            }\r\n\r\n            if (this.isTransitioning) {\r\n                return;\r\n            }\r\n\r\n            this.outgoingScene = this.currentScene;\r\n            this.incomingScene = this.scenes[id];\r\n\r\n            if (!this.outgoingScene) {\r\n                this.incomingScene.trigger('load-scene', () => {\r\n                    this.incomingScene.trigger('show-scene');\r\n                });\r\n            } else {\r\n                this.outgoingScene.trigger('exit-scene', () => {\r\n                    this.incomingScene.trigger('load-scene', () => {\r\n                        this.incomingScene.trigger('show-scene');\r\n                    });\r\n                });\r\n            }\r\n        },\r\n        setUpFPS = function (ticker, canvas) {\r\n            var framerate = document.createElement(\"div\"),\r\n                framerateTimer = 0;\r\n\r\n            framerate.id = \"framerate\";\r\n            framerate.innerHTML = \"FPS: 00.000\";\r\n            canvas.parentNode.insertBefore(framerate, canvas);\r\n\r\n            ticker.add(function () {\r\n                framerateTimer += this.deltaMS;\r\n\r\n                // Only update the framerate every second\r\n                if (framerateTimer >= 1000) {\r\n                    framerate.innerHTML = \"FPS: \" + this.FPS.toFixed(3);\r\n                    framerateTimer = 0;\r\n                }\r\n            }.bind(ticker));\r\n        };\r\n\r\n    class Game extends _Messenger_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\r\n        constructor (definition, options, onFinishedLoading) {\r\n            var displayOptions = options.display || {},\r\n                load = function (displayOptions, settings) {\r\n                    var id = '',\r\n                        scene  = '',\r\n                        scenes = {},\r\n                        ticker = pixi_js__WEBPACK_IMPORTED_MODULE_1__[\"Ticker\"].shared;\r\n                        \r\n                    platypus.game = this; //Make this instance the only Game instance.\r\n                    \r\n                    this.currentScene = null;\r\n                    this.settings = settings;\r\n                    this.stage = new pixi_js__WEBPACK_IMPORTED_MODULE_1__[\"Container\"]();\r\n                    this.renderer = new pixi_js__WEBPACK_IMPORTED_MODULE_1__[\"Renderer\"]({\r\n                        width: this.canvas.width,\r\n                        height: this.canvas.height,\r\n                        view: this.canvas,\r\n                        transparent: !!displayOptions.transparent,\r\n                        antialias: !!displayOptions.antiAlias,\r\n                        preserveDrawingBuffer: !!displayOptions.preserveDrawingBuffer,\r\n                        clearBeforeRender: !!displayOptions.clearView,\r\n                        backgroundColor: displayOptions.backgroundColor || 0,\r\n                        autoResize: false\r\n                    });\r\n                    this.scaleManager = new springroll__WEBPACK_IMPORTED_MODULE_0__[\"ScaleManager\"]({\r\n                        width: this.canvas.width,\r\n                        height: this.canvas.height\r\n                    });\r\n                    this.scaleManager.enable(({width, height/*, ratio*/}) => {\r\n                        var renderer = this.renderer;\r\n\r\n                        renderer.resize(width, height);\r\n                        renderer.render(this.stage); // to prevent flickering from canvas adjustment.\r\n                    });\r\n\r\n                    // Create Game Scenes.\r\n                    for (scene in settings.scenes) {\r\n                        if (settings.scenes.hasOwnProperty(scene)) {\r\n                            id = settings.scenes[scene].id = settings.scenes[scene].id || scene;\r\n                            scenes[id] = new _Scene_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](new pixi_js__WEBPACK_IMPORTED_MODULE_1__[\"Container\"](), settings.scenes[scene]);\r\n                        }\r\n                    }\r\n                    this.scenes = scenes;\r\n                    \r\n                    if (onFinishedLoading) {\r\n                        onFinishedLoading(this);\r\n                    }\r\n\r\n                    if (!settings.hideHello) {\r\n                        Object(_sayHello_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(this);\r\n                    }\r\n\r\n                    platypus.debug.general(\"Game config loaded.\", settings);\r\n\r\n                    //Add Debug tools\r\n                    window.getEntityById = function (id) {\r\n                        return this.getEntityById(id);\r\n                    }.bind(this);\r\n    \r\n                    window.getEntitiesByType = function (type) {\r\n                        return this.getEntitiesByType(type);\r\n                    }.bind(this);\r\n                    \r\n                    window.getVisibleSprites = function (c, a) {\r\n                        var i = 0;\r\n                        \r\n                        a = a || _utils_array_js__WEBPACK_IMPORTED_MODULE_7__[\"arrayCache\"].setUp();\r\n                        c = c || this.stage;\r\n                        \r\n                        if (!c.texture && c.visible) {\r\n                            for (i = 0; i < c.children.length; i++) {\r\n                                window.getVisibleSprites(c.children[i], a);\r\n                            }\r\n                            return a;\r\n                        } else if (c.visible) {\r\n                            a.push(c);\r\n                            return a;\r\n                        }\r\n                        return a;\r\n                    }.bind(this);\r\n\r\n                    this.ticker = ticker;\r\n                    this.tickInstance = this.tick.bind(this, ticker, {\r\n                        delta: 0, // standard, backwards-compatible parameter for `deltaMS`\r\n                        deltaMS: 0, // MS from last frame (matches above)\r\n                        deltaTime: 0 // PIXI ticker frame value\r\n                    });\r\n\r\n                    // START GAME!\r\n                    ticker.add(this.tickInstance);\r\n                    this.paused = false;\r\n\r\n                    if (config__WEBPACK_IMPORTED_MODULE_8___default.a.dev) {\r\n                        setUpFPS(ticker, this.canvas);\r\n                    }\r\n                };\r\n            \r\n            super();\r\n\r\n            if (!definition) {\r\n                platypus.debug.warn('No game definition is supplied. Game not created.');\r\n                return;\r\n            }\r\n\r\n            this.options = options;\r\n\r\n            // Get or set canvas.\r\n            if (options.canvasId) {\r\n                this.canvas = window.document.getElementById(options.canvasId);\r\n            }\r\n            if (!this.canvas) {\r\n                this.canvas = window.document.createElement('canvas');\r\n                window.document.body.appendChild(this.canvas);\r\n                if (options.canvasId) {\r\n                    this.canvas.setAttribute('id', options.canvasId);\r\n                }\r\n            }\r\n            this.canvas.width = this.canvas.offsetWidth;\r\n            this.canvas.height = this.canvas.offsetHeight;\r\n\r\n            this.springroll = (function () {\r\n                const\r\n                    springroll = new springroll__WEBPACK_IMPORTED_MODULE_0__[\"Application\"]({\r\n                        features: options.features || {\r\n                            sfx: true,\r\n                            vo: true,\r\n                            music: true,\r\n                            sound: true\r\n                        }\r\n                    }),\r\n                    state = springroll.state;\r\n\r\n                state.pause.subscribe(function (current) {\r\n                    if (current) {\r\n                        if (!this.paused) {\r\n                            this.ticker.remove(this.tickInstance);\r\n                            this.paused = true;\r\n                            pixi_sound__WEBPACK_IMPORTED_MODULE_4___default.a.pauseAll();\r\n                        }\r\n                    } else {\r\n                        if (this.paused) {\r\n                            this.ticker.add(this.tickInstance);\r\n                            this.paused = false;\r\n                            pixi_sound__WEBPACK_IMPORTED_MODULE_4___default.a.resumeAll();\r\n                        }\r\n                    }\r\n                }.bind(this));\r\n                \r\n                state.soundVolume.subscribe(function (current) {\r\n                    /* SR seems to trigger this too aggressively. We rely on the others instead.\r\n                    if (current) {\r\n                        Sound.muteAll();\r\n                    } else {\r\n                        Sound.unmuteAll();\r\n                    } */\r\n                });\r\n                \r\n                state.musicVolume.subscribe((current) => {\r\n                    if (current) {\r\n                        this.triggerOnChildren('mute-music');\r\n                    } else {\r\n                        this.triggerOnChildren('unmute-music');\r\n                    }\r\n                });\r\n                \r\n                state.voVolume.subscribe(function (current) {\r\n                    // toggleChannelMute('vo', 'mutedBySR', 'mutedBySRGlobal', current);\r\n                    // toggleChannelMute('tutorial', 'mutedBySR', 'mutedBySRGlobal', current);\r\n                });\r\n                \r\n                state.sfxVolume.subscribe(function (current) {\r\n                    // toggleChannelMute('sfx', 'mutedBySR', 'mutedBySRGlobal', current);\r\n                });\r\n\r\n                this.storage = new _Storage_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](springroll, options);\r\n\r\n                return springroll;\r\n            }.bind(this))();\r\n\r\n            if (typeof definition === 'string') {\r\n                loadJSONLinks(definition, load.bind(this, displayOptions));\r\n            } else {\r\n                load.bind(this)(displayOptions, definition);\r\n            }\r\n        }\r\n        \r\n        /**\r\n        * This method causes the game to tick once. It's called by the SpringRoll Application.\r\n        *\r\n        * @method tick\r\n        * @param tickMessage {Object} Event tracking tick data.\r\n        * @param ticker {PIXI.Ticker} The ticker being used to set the game tick.\r\n        * @param deltaTime {number} The time elapsed since the last tick.\r\n        **/\r\n        tick (ticker, tickMessage, deltaTime) {\r\n            tickMessage.delta = tickMessage.deltaMS = ticker.deltaMS;\r\n            tickMessage.deltaTime = deltaTime;\r\n\r\n            _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_6___default.a.update();\r\n            this.triggerOnChildren('tick', tickMessage);\r\n            this.renderer.render(this.stage);\r\n        }\r\n\r\n        /**\r\n        * This method triggers an event on the scene if there is a current scene.\r\n        *\r\n        * @method triggerEventOnChildren\r\n        **/\r\n        triggerOnChildren (...args) {\r\n            if (this.currentScene) {\r\n                this.currentScene.triggerOnChildren(...args);\r\n            }\r\n        }\r\n        \r\n        /**\r\n        * Loads a scene.\r\n        *\r\n        * @method loadScene\r\n        * @param sceneId {String} The scene to load.\r\n        * @param transition=\"instant\" {String} What type of transition to make. Currently there are: 'fade-to-black', 'crossfade', and 'instant'.\r\n        * @param data {Object} A list of key/value pairs describing options or settings for the loading scene.\r\n        * @param preloading=false {boolean} Whether the scene should appear immediately or just be loaded and not shown.\r\n        **/\r\n        loadScene (scene, data) {\r\n            // Delay load so it doesn't end a scene mid-tick.\r\n            window.setTimeout(load.bind(this, scene, data), 1);\r\n        }\r\n        \r\n        /**\r\n        * This method will return the first entity it finds with a matching id.\r\n        *\r\n        * @method getEntityById\r\n        * @param {string} id The entity id to find.\r\n        * @return {platypus.Entity} Returns the entity that matches the specified entity id.\r\n        **/\r\n        getEntityById (id) {\r\n            if (this.currentScene) {\r\n                return this.currentScene.getEntityById(id);\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        /**\r\n        * This method will return all game entities that match the provided type.\r\n        *\r\n        * @method getEntitiesByType\r\n        * @param {String} type The entity type to find.\r\n        * @return entities {Array} Returns the entities that match the specified entity type.\r\n        **/\r\n        getEntitiesByType (type) {\r\n            if (this.currentScene) {\r\n                return this.currentScene.getEntitiesByType(type);\r\n            } else {\r\n                return _utils_array_js__WEBPACK_IMPORTED_MODULE_7__[\"arrayCache\"].setUp();\r\n            }\r\n        }\r\n        \r\n        /**\r\n        * This method destroys the game.\r\n        *\r\n        * @method destroy\r\n        **/\r\n        destroy () {\r\n        }\r\n    }\r\n    \r\n    return Game;\r\n}());\n\n//# sourceURL=webpack://platypus/./src/Game.js?");

/***/ }),

/***/ "./src/Messenger.js":
/*!**************************!*\
  !*** ./src/Messenger.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_1__);\n/**\r\n * The Messenger object facilitates communication between components and other game objects. Messenger is currently used by [Entity](platypus.Entity.html) and [EntityContainer](platypus.components.EntityContainer).\r\n *\r\n * @namespace platypus\r\n * @class Messenger\r\n */\r\n/* global platypus, window */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var debug = config__WEBPACK_IMPORTED_MODULE_1___default.a.dev,\r\n        perfTools = debug && window.performance && window.performance.mark && window.performance.measure && window.performance, // End with this to set perfTools to window.performance\r\n        runBoth = function (f1, f2) {\r\n            return function () {\r\n                f1.apply(this, arguments);\r\n                f2.apply(this, arguments);\r\n            };\r\n        };\r\n\r\n    class Messenger {\r\n        constructor () {\r\n            this._listeners = {};\r\n            this._destroyed = false;\r\n            this.loopCheck = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n        }\r\n\r\n        get destroyed () {\r\n            return this._destroyed;\r\n        }\r\n\r\n        /**\r\n         * Add an event listener. The parameters for the listener functions depend on the event.\r\n         *\r\n         * @method on\r\n         * @param name {String} The type of event.\r\n         * @param callback {Function} The callback function when event is triggered.\r\n         */\r\n        on (name, callback) {\r\n            var listener = this._listeners[name] = this._listeners[name] || [];\r\n\r\n            if (this._destroyed) return;\r\n\r\n            if (listener.indexOf(callback) === -1) {\r\n                listener.push(callback);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Remove the event listener\r\n         *\r\n         * @method off\r\n         * @param name {String} The type of event; if no name is specifed remove all listeners.\r\n         * @param callback {Function} The listener function.\r\n         */\r\n        off (name, callback) {\r\n            var listener = this._listeners[name],\r\n                index = 0;\r\n\r\n            if (this._destroyed) return;\r\n\r\n            // remove all\r\n            if (typeof name === 'undefined') {\r\n                this._listeners = {};\r\n            } else {\r\n                // remove all listeners for that event\r\n                if (typeof callback === 'undefined') {\r\n                    listener.length = 0;\r\n                } else {\r\n                    //remove single listener\r\n                    index = listener.indexOf(callback);\r\n                    if (index !== -1) {\r\n                        listener.splice(index, 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns a string describing the Messenger as \"[Messenger object]\".\r\n         *\r\n         * @method toString\r\n         * @return String\r\n         */\r\n        toString () {\r\n            return \"[Messenger Object]\";\r\n        }\r\n\r\n        /**\r\n         * This method is used by both internal components and external entities to trigger messages. When triggered, Messenger checks through bound handlers to run as appropriate. This handles multiple event structures: \"\", [], and {}\r\n         *\r\n         * @method trigger\r\n         * @param event {String|Array|Object} This is the message(s) to process. This can be a string, an object containing an \"event\" property (and optionally a \"message\" property, overriding the value below), or an array of the same.\r\n         * @param value {*} This is a message object or other value to pass along to event handler.\r\n         * @param debug {boolean} This flags whether to output message contents and subscriber information to the console during game development. A \"value\" object parameter (above) will also set this flag if value.debug is set to true.\r\n         * @return {number} The number of handlers for the triggered message.\r\n         */\r\n        trigger (events, message, debug) {\r\n            var args = null,\r\n                i = 0,\r\n                count = 0,\r\n                msg = message,\r\n                indexOf = 0,\r\n                splitEvents = null;\r\n            \r\n            if (typeof events === 'string') {\r\n                indexOf = events.indexOf(\" \");\r\n                if (indexOf === -1) {\r\n                    return this.triggerEvent.apply(this, arguments);\r\n                } else {\r\n                    splitEvents = events.split(\" \");\r\n                    args = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(arguments);\r\n                    for (i = 0; i < splitEvents.length; i++) {\r\n                        args[0] = splitEvents[i];\r\n                        count += this.triggerEvent.apply(this, args);\r\n                    }\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(args);\r\n                    return count;\r\n                }\r\n            } else if (Array.isArray(events)) {\r\n                args = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(arguments);\r\n                for (i = 0; i < events.length; i++) {\r\n                    args[0] = events[i];\r\n                    count += this.trigger.apply(this, args);\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(args);\r\n                return count;\r\n            } else if (events.event) {\r\n                if (typeof events.message !== 'undefined') {\r\n                    msg = events.message;\r\n                }\r\n                return this.triggerEvent(events.event, msg, events.debug || debug);\r\n            } else {\r\n                platypus.debug.warn('Event incorrectly formatted: must be string, array, or object containing an \"event\" property.', events);\r\n                return 0;\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * This method is used by both internal components and external entities to trigger messages on this entity. When triggered, entity checks through bound handlers to run as appropriate. This method is identical to Spring Roll's [EventDispatcher.trigger](http://springroll.io/SpringRoll/docs/classes/springroll.EventDispatcher.html#method_trigger), but uses alternative Array methods to alleviate excessive GC.\r\n         *\r\n         * @method triggerEvent\r\n         * @param event {String} This is the message to process.\r\n         * @param [value] {*} This is a message object or other value to pass along to event handler.\r\n         * @param [value.debug] {boolean} This flags whether to output message contents and subscriber information to the console during game development.\r\n         * @return {number} The number of handlers for the triggered message.\r\n         */\r\n        triggerEvent (type) {\r\n            var count = 0,\r\n                i = 0,\r\n                listener = null,\r\n                listeners = this._listeners,\r\n                args = null;\r\n            \r\n            if (!this._destroyed && listeners.hasOwnProperty(type) && (listeners[type])) {\r\n                // copy the listeners array; reusing `listeners` variable\r\n                listeners = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(listeners[type]);\r\n\r\n                if (arguments.length > 1) {\r\n                    args = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(arguments);\r\n                    args.shift();\r\n                }\r\n\r\n                count = i = listeners.length;\r\n                while (i--) {\r\n                    listener = listeners[i];\r\n                    if (listener._eventDispatcherOnce) {\r\n                        delete listener._eventDispatcherOnce;\r\n                        this.off(type, listener);\r\n                    }\r\n                    listener.apply(this, args);\r\n                }\r\n                \r\n                if (args) {\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(args);\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(listeners);\r\n            }\r\n            \r\n            return count;\r\n        }\r\n        \r\n        /**\r\n         * This method returns all the messages that this entity is concerned about.\r\n         *\r\n         * @method getMessageIds\r\n         * @return {Array} An array of strings listing all the messages for which this Messenger has handlers.\r\n         */\r\n        getMessageIds () {\r\n            return Object.keys(this._listeners);\r\n        }\r\n        \r\n        /**\r\n         * This method relinguishes Messenger properties\r\n         *\r\n         * @method destroy\r\n         * @since 0.7.1\r\n         */\r\n        destroy () {\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.loopCheck);\r\n            this.loopCheck = null;\r\n            this._destroyed = true;\r\n            this._listeners = null;\r\n        }\r\n\r\n        static mixin (ClassObject) {\r\n            var key = '',\r\n                fromProto = Messenger.prototype,\r\n                toProto = ClassObject.prototype,\r\n                methods = Object.getOwnPropertyNames(fromProto),\r\n                i = methods.length;\r\n\r\n            while (i--) {\r\n                key = methods[i];\r\n                if (key !== 'constructor') {\r\n                    if (toProto[key]) {\r\n                        toProto[key] = runBoth(toProto[key], fromProto[key]);\r\n                    } else {\r\n                        toProto[key] = fromProto[key];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        static initialize (object) {\r\n            object._listeners = {};\r\n            object._destroyed = false;\r\n            object.loopCheck = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n        }\r\n    }\r\n\r\n    // Add logging checks for development mode.\r\n    if (debug) {\r\n        Messenger.prototype._triggerEvent = Messenger.prototype.triggerEvent;\r\n        Messenger.prototype.triggerEvent = function (event, value) {\r\n            var i = 0,\r\n                debugLimit = 5,\r\n                debugLogging = value && value.debug,\r\n                debugCount = 0,\r\n                count = 0;\r\n            \r\n            // Debug logging.\r\n            if (debugLogging || this.debug) {\r\n                for (i = 0; i < this.loopCheck.length; i++) {\r\n                    if (this.loopCheck[i] === event) {\r\n                        debugCount += 1;\r\n                        if (debugCount > debugLimit) {\r\n                            throw \"Endless loop detected for '\" + event + \"'.\";\r\n                        } else {\r\n                            platypus.debug.warn(\"Event '\" + event + \"' is nested inside another '\" + event + \"' event.\");\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.loopCheck.push(event);\r\n                if (perfTools) {\r\n                    perfTools.mark(\"a\");\r\n                }\r\n                count = this._triggerEvent.apply(this, arguments);\r\n                if (perfTools) {\r\n                    perfTools.mark(\"b\");\r\n                    perfTools.measure(this.type + \":\" + event, 'a', 'b');\r\n                }\r\n                this.loopCheck.length = this.loopCheck.length - 1;\r\n                if (debugLogging) {\r\n                    if (count) {\r\n                        platypus.debug.olive('Entity \"' + this.type + '\": Event \"' + event + '\" has ' + count + ' subscriber' + ((count > 1) ? 's' : '') + '.', value);\r\n                    } else {\r\n                        platypus.debug.warn('Entity \"' + this.type + '\": Event \"' + event + '\" has no subscribers.', value);\r\n                    }\r\n                }\r\n                return count;\r\n            } else {\r\n                return this._triggerEvent.apply(this, arguments);\r\n            }\r\n        };\r\n    }\r\n    \r\n    return Messenger;\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/Messenger.js?");

/***/ }),

/***/ "./src/PIXIAnimation.js":
/*!******************************!*\
  !*** ./src/PIXIAnimation.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Data.js */ \"./src/Data.js\");\n/**\r\n * This class plays animation sequences of frames and mimics the syntax required for creating CreateJS Sprites, allowing CreateJS Sprite Sheet definitions to be used with pixiJS.\r\n *\r\n * @class PIXIAnimation\r\n * @extends PIXI.Sprite\r\n */\r\n/*global platypus */\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var MAX_KEY_LENGTH_PER_IMAGE = 128,\r\n        animationCache = {},\r\n        baseTextureCache = {},\r\n        doNothing = function () {},\r\n        emptyFrame = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"].EMPTY,\r\n        regex = /[\\[\\]{},-]/g,\r\n        getBaseTextures = function (images) {\r\n            var i = 0,\r\n                bts = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\r\n                asset = null,\r\n                assetCache = platypus.assetCache,\r\n                btCache = baseTextureCache,\r\n                path = null;\r\n            \r\n            for (i = 0; i < images.length; i++) {\r\n                path = images[i];\r\n                if (typeof path === 'string') {\r\n                    if (!btCache[path]) {\r\n                        asset = assetCache.get(path);\r\n                        if (!asset) {\r\n                            platypus.debug.warn('\"' + path + '\" is not a loaded asset.');\r\n                            break;\r\n                        }\r\n                        btCache[path] = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"BaseTexture\"](asset);\r\n                    }\r\n                    bts.push(btCache[path]);\r\n                } else {\r\n                    bts.push(new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"BaseTexture\"](path));\r\n                }\r\n            }\r\n            \r\n            return bts;\r\n        },\r\n        getTexturesCacheId = function (spriteSheet) {\r\n            var i = 0;\r\n            \r\n            if (spriteSheet.id) {\r\n                return spriteSheet.id;\r\n            }\r\n            \r\n            for (i = 0; i < spriteSheet.images.length; i++) {\r\n                if (typeof spriteSheet.images[i] !== 'string') {\r\n                    return '';\r\n                }\r\n            }\r\n            \r\n            spriteSheet.id = JSON.stringify(spriteSheet).replace(regex, '');\r\n\r\n            return spriteSheet.id;\r\n        },\r\n        getDefaultAnimation = function (length, textures) {\r\n            var frames = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\r\n                i = 0;\r\n            \r\n            for (i = 0; i < length; i++) {\r\n                frames.push(textures[i] || emptyFrame);\r\n            }\r\n            return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                \"id\", \"default\",\r\n                \"frames\", frames,\r\n                \"next\", \"default\",\r\n                \"speed\", 1\r\n            );\r\n        },\r\n        standardizeAnimations = function (def, textures) {\r\n            var animation = '',\r\n                anims = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(),\r\n                i = 0,\r\n                frames = null,\r\n                key = '';\r\n            \r\n            for (key in def) {\r\n                if (def.hasOwnProperty(key)) {\r\n                    animation = def[key];\r\n                    frames = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"greenSlice\"])(animation.frames);\r\n                    i = frames.length;\r\n                    while (i--) {\r\n                        frames[i] = textures[frames[i]] || emptyFrame;\r\n                    }\r\n                    anims[key] = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                        \"id\", key,\r\n                        \"frames\", frames,\r\n                        \"next\", animation.next,\r\n                        \"speed\", animation.speed\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (!anims.default) {\r\n                // Set up a default animation that plays through all frames\r\n                anims.default = getDefaultAnimation(textures.length, textures);\r\n            }\r\n            \r\n            return anims;\r\n        },\r\n        getAnimations = function (spriteSheet) {\r\n            var i = 0,\r\n                anims    = null,\r\n                frame    = null,\r\n                frames   = spriteSheet.frames,\r\n                images   = spriteSheet.images,\r\n                textures = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\r\n                bases    = getBaseTextures(images);\r\n\r\n            // Set up texture for each frame\r\n            for (i = 0; i < frames.length; i++) {\r\n                frame = frames[i];\r\n                textures.push(new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"](bases[frame[4]], new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Rectangle\"](frame[0], frame[1], frame[2], frame[3]), null, null, 0, new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]((frame[5] || 0) / frame[2], (frame[6] || 0) / frame[3])));\r\n            }\r\n\r\n            // Set up animations\r\n            anims = standardizeAnimations(spriteSheet.animations, textures);\r\n\r\n            // Set up a default animation that plays through all frames\r\n            if (!anims.default) {\r\n                anims.default = getDefaultAnimation(textures.length, textures);\r\n            }\r\n            \r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(bases);\r\n            \r\n            return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                \"textures\", textures,\r\n                \"animations\", anims\r\n            );\r\n        },\r\n        cacheAnimations = function (spriteSheet, cacheId) {\r\n            var i = 0,\r\n                anims    = null,\r\n                frame    = null,\r\n                frames   = spriteSheet.frames,\r\n                images   = spriteSheet.images,\r\n                textures = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\r\n                bases    = getBaseTextures(images);\r\n\r\n            // Set up texture for each frame\r\n            for (i = 0; i < frames.length; i++) {\r\n                frame = frames[i];\r\n                textures.push(new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"](bases[frame[4]], new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Rectangle\"](frame[0], frame[1], frame[2], frame[3]), null, null, 0, new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]((frame[5] || 0) / frame[2], (frame[6] || 0) / frame[3])));\r\n            }\r\n\r\n            // Set up animations\r\n            anims = standardizeAnimations(spriteSheet.animations, textures);\r\n\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(bases);\r\n            \r\n            return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                \"textures\", textures,\r\n                \"animations\", anims,\r\n                \"viable\", 1,\r\n                \"cacheId\", cacheId\r\n            );\r\n        },\r\n        PIXIAnimation = function (spriteSheet, animation) {\r\n            var FR = 60,\r\n                cacheId = getTexturesCacheId(spriteSheet),\r\n                cache = (cacheId ? animationCache[cacheId] : null),\r\n                speed = (spriteSheet.framerate || FR) / FR;\r\n\r\n            let animationCount = 0;\r\n            \r\n            if (!cacheId) {\r\n                cache = getAnimations(spriteSheet);\r\n            } else if (!cache) {\r\n                cache = animationCache[cacheId] = cacheAnimations(spriteSheet, cacheId);\r\n                this.cacheId = cacheId;\r\n            } else {\r\n                cache.viable += 1;\r\n                this.cacheId = cacheId;\r\n            }\r\n\r\n            pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"].call(this); //, cache.textures[0].texture\r\n        \r\n            /**\r\n            * @private\r\n            */\r\n            this._animations = {};\r\n            for (const key in cache.animations) {\r\n                if (cache.animations[key].frames.length === 1) {\r\n                    this._animations[key] = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"](cache.animations[key].frames[0]);\r\n                } else {\r\n                    const anim = this._animations[key] = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"AnimatedSprite\"](cache.animations[key].frames);\r\n\r\n                    anim.animationSpeed = speed * cache.animations[key].speed;\r\n                    anim.onComplete = anim.onLoop = function (animation, properties) {\r\n                        if (this.onComplete) {\r\n                            this.onComplete(animation);\r\n                        }\r\n                        if (properties.next) {\r\n                            this.gotoAndPlay(properties.next);\r\n                        }\r\n                    }.bind(this, key, cache.animations[key]);\r\n                    anim.updateAnchor = true;\r\n                }\r\n                animationCount += 1;\r\n            }\r\n            \r\n            this._animation = null;\r\n        \r\n            /**\r\n            * The speed that the PIXIAnimation will play at. Higher is faster, lower is slower\r\n            *\r\n            * @member {number}\r\n            * @default 1\r\n            */\r\n            this.animationSpeed = speed;\r\n\r\n            /**\r\n             * The currently playing animation name.\r\n             *\r\n             * @property currentAnimation\r\n             * @default \"\"\r\n             * @type String\r\n             * @since 0.9.2\r\n             */\r\n            this.currentAnimation = null;\r\n        \r\n            /**\r\n            * Indicates if the PIXIAnimation is currently playing\r\n            *\r\n            * @member {boolean}\r\n            * @readonly\r\n            */\r\n            this.playing = false;\r\n            \r\n            this._visible = true;\r\n            \r\n            this._updating = false;\r\n\r\n            /*\r\n            * Updates the object transform for rendering\r\n            * @private\r\n            */\r\n            this.update = doNothing;\r\n\r\n            // Set up initial playthrough.\r\n            this.gotoAndPlay(animation);\r\n        },\r\n        prototype = PIXIAnimation.prototype = Object.create(pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"].prototype);\r\n    \r\n    PIXIAnimation.prototype.constructor = PIXIAnimation;\r\n    \r\n    Object.defineProperties(prototype, {\r\n        /**\r\n        * The visibility of the sprite.\r\n        *\r\n        * @property visible\r\n        * @memberof PIXI.DisplayObject#\r\n        */\r\n        visible: {\r\n            get: function () {\r\n                return this._visible;\r\n            },\r\n            set: function (value) {\r\n                this._visible = value;\r\n            }\r\n        },\r\n        \r\n        /**\r\n        * The PIXIAnimations paused state. If paused, the animation doesn't update.\r\n        *\r\n        * @property paused\r\n        */\r\n        paused: {\r\n            get: function () {\r\n                return !this.playing;\r\n            },\r\n            set: function (value) {\r\n                if ((value && this.playing) || (!value && !this.playing)) {\r\n                    this.playing = !value;\r\n                }\r\n            }\r\n        }\r\n    \r\n    });\r\n    \r\n    /**\r\n    * Stops the PIXIAnimation\r\n    *\r\n    */\r\n    prototype.stop = function () {\r\n        this.paused = true;\r\n    };\r\n    \r\n    /**\r\n    * Plays the PIXIAnimation\r\n    *\r\n    */\r\n    prototype.play = function () {\r\n        this.paused = false;\r\n    };\r\n    \r\n    /**\r\n    * Stops the PIXIAnimation and goes to a specific frame\r\n    *\r\n    * @param frameNumber {number} frame index to stop at\r\n    */\r\n    prototype.gotoAndStop = function (animation) {\r\n        this.stop();\r\n        if (this._animation && this._animation.stop) {\r\n            this._animation.stop();\r\n        }\r\n    \r\n        this._animation = this._animations[animation];\r\n        if (!this._animation) {\r\n            this._animation = this._animations.default;\r\n        }\r\n        this.removeChildren();\r\n        this.addChild(this._animation);\r\n    };\r\n    \r\n    /**\r\n    * Goes to a specific frame and begins playing the PIXIAnimation\r\n    *\r\n    * @method gotoAndPlay\r\n    * @param animation {string} The animation to begin playing.\r\n    * @param [restart = true] {Boolean} Whether to restart the animation if it's currently playing.\r\n    */\r\n    prototype.gotoAndPlay = function (animation, restart) {\r\n        if ((this.currentAnimation !== animation) || (restart !== false)) {\r\n            if (this._animation && this._animation.stop) {\r\n                this._animation.stop();\r\n            }\r\n            this._animation = this._animations[animation];\r\n            this.currentAnimation = animation;\r\n            if (!this._animation) {\r\n                this._animation = this._animations.default;\r\n                this.currentAnimation = 'default';\r\n            }\r\n            this.removeChildren();\r\n            this.addChild(this._animation);\r\n        }\r\n        \r\n        if (this._animation.play) {\r\n            this._animation.play();\r\n        }\r\n        this.play();\r\n    };\r\n    \r\n    /**\r\n    * Returns whether a particular animation is available.\r\n    *\r\n    * @method has\r\n    * @param animation {string} The animation to check.\r\n    * @since 0.9.0\r\n    */\r\n    prototype.has = function (animation) {\r\n        return !!this._animations[animation];\r\n    };\r\n    \r\n    /**\r\n     * Stops the PIXIAnimation and destroys it\r\n     *\r\n     * @method destroy\r\n     */\r\n    prototype.destroy = function () {\r\n        var key = '';\r\n        \r\n        this.stop();\r\n        if (this._animation && this._animation.stop) {\r\n            this._animation.stop();\r\n        }\r\n        pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"].prototype.destroy.call(this);\r\n        if (this.cacheId) {\r\n            animationCache[this.cacheId].viable -= 1;\r\n            if (animationCache[this.cacheId].viable <= 0) {\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(animationCache[this.cacheId].textures);\r\n                for (key in animationCache[this.cacheId].animations) {\r\n                    if (animationCache[this.cacheId].animations.hasOwnProperty(key)) {\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(animationCache[this.cacheId].animations[key].frames);\r\n                    }\r\n                }\r\n                delete animationCache[this.cacheId];\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * This method makes sure that all the base textures are in the gpu to prevent framerate lurches later due to loading base textures as their textures appear.\r\n     *\r\n     * @method PIXIAnimation.preloadBaseTextures\r\n     * @param renderer {PIXI.WebGLRenderer}\r\n     */\r\n    PIXIAnimation.preloadBaseTextures = function (renderer) {\r\n        var btCache = baseTextureCache,\r\n            key = '';\r\n        \r\n        if (renderer.updateTexture) {\r\n            for (key in btCache) {\r\n                if (btCache.hasOwnProperty(key)) {\r\n                    renderer.updateTexture(btCache[key]);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * This method cleans out all PIXIAnimation baseTextures at the end of a scene.\r\n     *\r\n     * @method PIXIAnimation.unloadBaseTextures\r\n     */\r\n    PIXIAnimation.unloadBaseTextures = function (renderer) {\r\n        var btCache = baseTextureCache,\r\n            key = '';\r\n        \r\n        for (key in btCache) {\r\n            if (btCache.hasOwnProperty(key) && btCache[key]) {\r\n                btCache[key].destroy();\r\n                btCache[key] = null;\r\n            }\r\n        }\r\n\r\n        pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"utils\"].clearTextureCache();\r\n    };\r\n    \r\n    PIXIAnimation.EmptySpriteSheet = {\r\n        framerate: 60,\r\n        frames: [],\r\n        images: [],\r\n        animations: {},\r\n        recycleSpriteSheet: function () {\r\n            // We don't recycle this sprite sheet.\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * This method formats a provided value into a valid PIXIAnimation Sprite Sheet. This includes accepting the EaselJS spec, strings mapping to Platypus sprite sheets, or arrays of either.\r\n     *\r\n     * @method formatSpriteSheet\r\n     * @param spriteSheet {String|Array|Object} The value to cast to a valid Sprite Sheet.\r\n     * @return {Object}\r\n     * @since 0.8.4\r\n     */\r\n    PIXIAnimation.formatSpriteSheet = (function () {\r\n        var imageParts = /([\\w-]+)\\.(\\w+)$/,\r\n            addAnimations = function (source, destination, speedRatio, firstFrameIndex, id) {\r\n                var key = '';\r\n                \r\n                for (key in source) {\r\n                    if (source.hasOwnProperty(key)) {\r\n                        if (destination[key]) {\r\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(destination[key].frames);\r\n                            destination[key].recycle();\r\n                            platypus.debug.olive('PIXIAnimation \"' + id + '\": Overwriting duplicate animation for \"' + key + '\".');\r\n                        }\r\n                        destination[key] = formatAnimation(key, source[key], speedRatio, firstFrameIndex);\r\n                    }\r\n                }\r\n            },\r\n            addFrameObject = function (source, destination, firstImageIndex, bases) {\r\n                var i = 0,\r\n                    fw = source.width,\r\n                    fh = source.height,\r\n                    rx = source.regX || 0,\r\n                    ry = source.regY || 0,\r\n                    w = 0,\r\n                    h = 0,\r\n                    x = 0,\r\n                    y = 0;\r\n                \r\n                for (i = 0; i < bases.length; i++) {\r\n                    \r\n                    // Subtract the size of a frame so that margin slivers aren't returned as frames.\r\n                    w = bases[i].realWidth - fw;\r\n                    h = bases[i].realHeight - fh;\r\n                    \r\n                    for (y = 0; y <= h; y += fh) {\r\n                        for (x = 0; x <= w; x += fw) {\r\n                            destination.push([x, y, fw, fh, i + firstImageIndex, rx, ry]);\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            addFrameArray = function (source, destination, firstImageIndex) {\r\n                var frame = null,\r\n                    i = 0;\r\n                \r\n                for (i = 0; i < source.length; i++) {\r\n                    frame = source[i];\r\n                    destination.push(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(\r\n                        frame[0],\r\n                        frame[1],\r\n                        frame[2],\r\n                        frame[3],\r\n                        frame[4] + firstImageIndex,\r\n                        frame[5],\r\n                        frame[6]\r\n                    ));\r\n                }\r\n            },\r\n            createId = function (images) {\r\n                var i = images.length,\r\n                    id = '',\r\n                    segment = '',\r\n                    separator = '';\r\n\r\n                while (i--) {\r\n                    segment = images[i].src || images[i];\r\n                    id += separator + segment.substring(0, MAX_KEY_LENGTH_PER_IMAGE);\r\n                    separator = ',';\r\n                }\r\n\r\n                return id;\r\n            },\r\n            format = function (source, destination) {\r\n                var bases = null,\r\n                    dAnims = destination.animations,\r\n                    dImages = destination.images,\r\n                    dFR = destination.framerate || 60,\r\n                    dFrames = destination.frames,\r\n                    i = 0,\r\n                    images = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\r\n                    firstImageIndex = dImages.length,\r\n                    firstFrameIndex = dFrames.length,\r\n                    sAnims = source.animations,\r\n                    sImages = source.images,\r\n                    sFR = source.framerate || 60,\r\n                    sFrames = source.frames;\r\n                \r\n                // Set up id\r\n                if (destination.id) {\r\n                    destination.id += ';' + (source.id || createId(source.images));\r\n                } else {\r\n                    destination.id = source.id || createId(source.images);\r\n                }\r\n                \r\n                // Set up images array\r\n                for (i = 0; i < sImages.length; i++) {\r\n                    images.push(formatImages(sImages[i]));\r\n                    dImages.push(images[i]);\r\n                }\r\n\r\n                // Set up frames array\r\n                if (Array.isArray(sFrames)) {\r\n                    addFrameArray(sFrames, dFrames, firstImageIndex);\r\n                } else {\r\n                    bases = getBaseTextures(images);\r\n                    addFrameObject(sFrames, dFrames, firstImageIndex, bases);\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(bases);\r\n                }\r\n                \r\n                // Set up animations object\r\n                addAnimations(sAnims, dAnims, sFR / dFR, firstFrameIndex, destination.id);\r\n                \r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(images);\r\n                \r\n                return destination;\r\n            },\r\n            formatAnimation = function (key, animation, speedRatio, firstFrameIndex) {\r\n                var i = 0,\r\n                    first = 0,\r\n                    frames = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\r\n                    last = 0;\r\n                \r\n                if (typeof animation === 'number') {\r\n                    frames.push(animation + firstFrameIndex);\r\n                    return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                        \"frames\", frames,\r\n                        \"next\", key,\r\n                        \"speed\", speedRatio\r\n                    );\r\n                } else if (Array.isArray(animation)) {\r\n                    first = animation[0] || 0;\r\n                    last = (animation[1] || first) + 1 + firstFrameIndex;\r\n                    first += firstFrameIndex;\r\n                    for (i = first; i < last; i++) {\r\n                        frames.push(i);\r\n                    }\r\n                    return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                        \"frames\", frames,\r\n                        \"next\", animation[2] || key,\r\n                        \"speed\", (animation[3] || 1) * speedRatio\r\n                    );\r\n                } else {\r\n                    for (i = 0; i < animation.frames.length; i++) {\r\n                        frames.push(animation.frames[i] + firstFrameIndex);\r\n                    }\r\n                    return _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                        \"frames\", frames,\r\n                        \"next\", animation.next || key,\r\n                        \"speed\", (animation.speed || 1) * speedRatio\r\n                    );\r\n                }\r\n            },\r\n            formatImages = function (name) {\r\n                var match = false;\r\n                \r\n                if (typeof name === 'string') {\r\n                    match = name.match(imageParts);\r\n\r\n                    if (match) {\r\n                        return match[1];\r\n                    }\r\n                }\r\n\r\n                return name;\r\n            },\r\n            recycle = function () {\r\n                var animations = this.animations,\r\n                    key = '';\r\n                \r\n                for (key in animations) {\r\n                    if (animations.hasOwnProperty(key)) {\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(animations[key].frames);\r\n                    }\r\n                    animations[key].recycle();\r\n                }\r\n                \r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.frames, 2);\r\n                this.frames = null;\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.images);\r\n                this.images = null;\r\n                this.recycle();\r\n            },\r\n            merge = function (spriteSheets, destination) {\r\n                var i = spriteSheets.length,\r\n                    ss = null;\r\n                \r\n                while (i--) {\r\n                    ss = spriteSheets[i];\r\n                    if (typeof ss === 'string') {\r\n                        ss = platypus.game.settings.spriteSheets[ss];\r\n                    }\r\n                    if (ss) {\r\n                        format(ss, destination);\r\n                    }\r\n                }\r\n                \r\n                return destination;\r\n            };\r\n        \r\n        return function (spriteSheet) {\r\n            var response = PIXIAnimation.EmptySpriteSheet,\r\n                ss = spriteSheet;\r\n            \r\n            if (typeof ss === 'string') {\r\n                ss = platypus.game.settings.spriteSheets[spriteSheet];\r\n            }\r\n            \r\n            if (ss) {\r\n                response = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                    \"animations\", _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(),\r\n                    \"framerate\", 60,\r\n                    \"frames\", _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\r\n                    \"id\", '',\r\n                    \"images\", _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\r\n                    \"recycleSpriteSheet\", recycle\r\n                );\r\n                    \r\n                if (Array.isArray(ss)) {\r\n                    return merge(ss, response);\r\n                } else if (ss) {\r\n                    return format(ss, response);\r\n                }\r\n            }\r\n\r\n            return response;\r\n        };\r\n    }());\r\n\r\n    return PIXIAnimation;\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/PIXIAnimation.js?");

/***/ }),

/***/ "./src/Scene.js":
/*!**********************!*\
  !*** ./src/Scene.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Async_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Async.js */ \"./src/Async.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Data.js */ \"./src/Data.js\");\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _Messenger_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Messenger.js */ \"./src/Messenger.js\");\n/* harmony import */ var _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PIXIAnimation.js */ \"./src/PIXIAnimation.js\");\n/**\r\n * This class is instantiated by [Game](platypus.Game.html) and contains one or more entities as layers. Each layer [Entity](platypus.Entity.html) handles a unique aspect of the scene. For example, one layer might contain the game world, while another layer contains the game interface. Generally there is only a single scene loaded at any given moment.\r\n * ## JSON Definition\r\n *     {\r\n *         \"layers\":[\r\n *         // Required array listing the entities that should be loaded as scene layers. These can be actual entity JSON definitions as shown in Entity or references to entities by using the following specification.\r\n *\r\n *             {\r\n *                 \"type\": \"entity-id\",\r\n *                 // This value maps to an entity definition with a matching \"id\" value as shown in Entity and will load that definition.\r\n *\r\n *                 \"properties\": {\"x\": 400}\r\n *                 // Optional. If properties are passed in this reference, they override the entity definition's properties of the same name.\r\n *             }\r\n *         ],\r\n *\r\n *         \"assets\": []\r\n *         // Optional list of assets this scene requires.\r\n *     }\r\n * @namespace platypus\r\n * @class Scene\r\n * @constructor\r\n * @extends platypus.Messenger\r\n * @param Stage {PIXI.Container} Object where the scene displays layers.\r\n * @param {Object} [definition] Base definition for the scene, including one or more layers with both properties and components as shown above under \"JSON Definition Example\".\r\n * @param {String} [definition.id] This declares the id of the scene.\r\n * @param {Array} [definition.layers] This lists the layers that comprise the scene.\r\n * @param {Array} [definition.assets] This lists the assets that this scene requires.\r\n * @return {Scene} Returns the new scene made up of the provided layers.\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var fn = /^(?:\\w+:\\/{2}\\w+(?:\\.\\w+)*\\/?)?(?:[\\/.]*?(?:[^?]+)?\\/)?(?:([^\\/?]+)\\.(\\w+|{\\w+(?:,\\w+)*}))(?:\\?\\S*)?$/,\r\n        folders = {\r\n            png: 'images',\r\n            jpg: 'images',\r\n            jpeg: 'images',\r\n            ogg: 'audio',\r\n            mp3: 'audio',\r\n            m4a: 'audio',\r\n            wav: 'audio',\r\n            \"{ogg,mp3}\": 'audio'\r\n        },\r\n        unloadAssets = function (lateAssets) {\r\n            var i = lateAssets.length,\r\n                id = '',\r\n                img = null,\r\n                lateAsset = null;\r\n\r\n            while (i--) {\r\n                lateAsset = lateAssets[i];\r\n                id = lateAsset.id;\r\n                img = platypus.assetCache.get(id);\r\n                if (img) {\r\n                    img.src = '';\r\n                    platypus.assetCache.delete(id);\r\n                } // TODO: Unload audio.\r\n                lateAsset.recycle();\r\n            }\r\n            \r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(lateAssets);\r\n        },\r\n        filterAssets = (function () {\r\n            var isDuplicate = function (id, preload) {\r\n                var j = preload.length;\r\n\r\n                while (j--) {\r\n                    if (preload[j].id === id) {\r\n                        return true;\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            };\r\n\r\n            return function (assets, preload) {\r\n                var asset = null,\r\n                    cache = platypus.assetCache,\r\n                    filteredAssets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                    i = assets.length;\r\n\r\n                while (i--) {\r\n                    asset = formatAsset(assets[i]);\r\n                    if (cache.get(asset.id) || isDuplicate(asset.id, preload)) {\r\n                        asset.recycle();\r\n                    } else {\r\n                        filteredAssets.push(asset);\r\n                    }\r\n                }\r\n\r\n                return filteredAssets;\r\n            };\r\n        }()),\r\n        formatAsset = function (asset) {\r\n            var match = asset.match(fn),\r\n                a = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                    'id', asset,\r\n                    'src', (platypus.game.options[folders[match[2].toLowerCase()]] || '') + asset\r\n                );\r\n            \r\n            //TODO: Make this behavior less opaque.\r\n            if (match) {\r\n                a.id = match[1];\r\n            } else {\r\n                platypus.debug.warn('Scene: A listed asset should provide the entire file path.');\r\n            }\r\n            \r\n            return a;\r\n        },\r\n        releaseHold = function (callback) {\r\n            var holds = this.holds;\r\n\r\n            holds.count -= 1;\r\n            if (!holds.count) { // All holds have been released\r\n                holds.recycle();\r\n                this.holds = null;\r\n                callback();\r\n            }\r\n        },\r\n        layerInit = function (layerDefinition, properties, callback) {\r\n            this.layers.push(new _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](layerDefinition, {\r\n                properties: properties\r\n            }, callback));\r\n        },\r\n        loadScene = function (callback) {\r\n            var i = 0,\r\n                key = '',\r\n                layerInits = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                layers = this.layerDefinitions,\r\n                supportedLayer = true,\r\n                layerDefinition = false,\r\n                properties = null,\r\n                messages = null;\r\n                \r\n            this.holds = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp('count', 1, 'release', releaseHold.bind(this, callback));\r\n            this.storeMessages = true;\r\n            this.storedMessages = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.layers = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n\r\n            for (i = 0; i < layers.length; i++) {\r\n                layerDefinition = layers[i];\r\n                properties = {stage: this.stage, parent: this};\r\n                if (layerDefinition.properties) {\r\n                    for (key in layerDefinition.properties) {\r\n                        if (layerDefinition.properties.hasOwnProperty(key)) {\r\n                            properties[key] = layerDefinition.properties[key];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (layerDefinition.type) { // this layer should be loaded from an entity definition rather than this instance\r\n                    layerDefinition = platypus.game.settings.entities[layerDefinition.type];\r\n                }\r\n\r\n                supportedLayer = true;\r\n                if (layerDefinition.filter) {\r\n                    if (layerDefinition.filter.includes) {\r\n                        supportedLayer = false;\r\n                        for (key in layerDefinition.filter.includes) {\r\n                            if (layerDefinition.filter.includes.hasOwnProperty(key) && platypus.supports[layerDefinition.filter.includes[key]]) {\r\n                                supportedLayer = true;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (layerDefinition.filter.excludes) {\r\n                        for (key in layerDefinition.filter.excludes) {\r\n                            if (layerDefinition.filter.excludes.hasOwnProperty(key) && platypus.supports[layerDefinition.filter.excludes[key]]) {\r\n                                supportedLayer = false;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (supportedLayer) {\r\n                    layerInits.push(layerInit.bind(this, layerDefinition, properties));\r\n                }\r\n            }\r\n\r\n            _Async_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(layerInits, function () {\r\n                var holds = this.holds;\r\n\r\n                platypus.debug.olive('Scene loaded: ' + this.id);\r\n                \r\n                /**\r\n                 * This event is triggered on the layers once the Scene is finished loading.\r\n                 *\r\n                 * @event 'scene-loaded'\r\n                 * @param data {Object} A list of key-value pairs of data sent into this Scene from the previous Scene.\r\n                 * @param holds {platypus.Data} An object that handles any holds on before making the scene live.\r\n                 * @param holds.count {Number} The number of holds to wait for before triggering \"scene-live\"\r\n                 * @param holds.release {Function} The method to trigger to let the scene loader know that one hold has been released.\r\n                 */\r\n                this.triggerOnChildren('scene-loaded', this.data, holds);\r\n                \r\n                // Go ahead and load base textures to the GPU to prevent intermittent lag later. - DDD 3/18/2016\r\n                _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].preloadBaseTextures(platypus.game.renderer);\r\n\r\n                holds.release(); // Release initial hold. This triggers \"scene-live\" immediately if no holds have been placed by the \"scene-loaded\" event.\r\n            }.bind(this));\r\n\r\n            // This allows the layer to gather messages that are triggered as it is loading and deliver them to all the layers once all the layers are in place.\r\n            messages = this.storedMessages;\r\n            this.storeMessages = false;\r\n            for (i = 0; i < messages.length; i++) {\r\n                this.triggerOnChildren(messages[i].message, messages[i].value);\r\n            }\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(messages);\r\n            this.storedMessages = null;\r\n\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(layerInits);\r\n        },\r\n        loading = function (definition, callback) {\r\n            var lateAssets = this.getLateAssetList(definition),\r\n                assets = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(this.preload),\r\n                queue = null,\r\n                i = 0;\r\n\r\n            if (lateAssets.length) {\r\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, lateAssets);\r\n                this.unloadAssets = unloadAssets.bind(this, lateAssets);\r\n            } else {\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(lateAssets);\r\n            }\r\n\r\n            i = assets.length;\r\n            if (i) {\r\n                queue = new pixi_js__WEBPACK_IMPORTED_MODULE_4__[\"Loader\"]();\r\n                queue.onLoad.add((loader, response) => {\r\n                    platypus.assetCache.set(response.name, response.data);\r\n                });\r\n                queue.onComplete.add(loadScene.bind(this, callback));\r\n                while (i--) {\r\n                    queue.add(assets[i].id || assets[i].src || assets[i], assets[i].src || assets[i], assets[i]);\r\n                }\r\n                queue.load();\r\n                this.loader = queue;\r\n            } else {\r\n                loadScene.call(this, callback);\r\n            }\r\n        };\r\n\r\n    class Scene extends _Messenger_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"] {\r\n        constructor (panel, definition) {\r\n            var assets = null;\r\n\r\n            super();\r\n            \r\n            this.preload = (definition && definition.options && definition.options.preload) || [];\r\n\r\n            assets = this.getAssetList(definition);\r\n\r\n            this.id = definition.id;\r\n            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(this.preload, assets);\r\n            this.layerDefinitions = definition.layers;\r\n            this.storeMessages = false;\r\n            this.storedMessages = null;\r\n            this.stage = panel;\r\n            this.layers = null;\r\n            this.assets = definition.assets || null;\r\n            this.holds = null;\r\n            \r\n            // If the scene has dynamically added assets such as level data\r\n            this.on('load-scene', loading.bind(this, definition));\r\n            this.on('show-scene', this.sceneLive.bind(this));\r\n            this.on('exit-scene', this.exitStart.bind(this));\r\n\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(assets);\r\n        }\r\n        \r\n        sceneLive () {\r\n            platypus.game.currentScene = this;\r\n            platypus.game.stage.addChild(this.stage);\r\n            platypus.debug.olive('Scene live: ' + this.id);\r\n            \r\n            /**\r\n             * This event is triggered on the layers once the Scene is finished loading.\r\n             *\r\n             * @event 'scene-live'\r\n             * @param data {Object} A list of key-value pairs of data sent into this Scene from the previous Scene.\r\n             */\r\n            this.triggerOnChildren('scene-live', this.data);\r\n        }\r\n        \r\n        /**\r\n         * Triggers 'scene-ended' on the layer.\r\n         *\r\n         * @method exitStart\r\n         */\r\n        exitStart (callback) {\r\n            platypus.debug.olive('Scene ending: ' + this.id);\r\n            \r\n            /**\r\n             * This event is triggered on the layers once the Scene is over.\r\n             *\r\n             * @event 'scene-ended'\r\n             * @param data {Object} A list of key-value pairs of data sent into this Scene from the previous Scene.\r\n             * @since 0.7.1\r\n             */\r\n            this.triggerOnChildren('scene-ended', this.data);\r\n            platypus.game.stage.removeChild(this.stage);\r\n\r\n            this.exit();\r\n\r\n            callback();\r\n        }\r\n        \r\n        /**\r\n         * This method is used by external objects to trigger messages on the layers as well as internal entities broadcasting messages across the scope of the scene.\r\n         *\r\n         * @method triggerOnChildren\r\n         * @param {String} eventId This is the message to process.\r\n         * @param {*} event This is a message object or other value to pass along to component functions.\r\n         **/\r\n        triggerOnChildren (eventId, event) {\r\n            var i = 0;\r\n            \r\n            if (this.storeMessages) {\r\n                this.storedMessages.push({\r\n                    message: eventId,\r\n                    value: event\r\n                });\r\n            } else {\r\n                for (i = 0; i < this.layers.length; i++) {\r\n                    this.layers[i].trigger.apply(this.layers[i], arguments);\r\n                }\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * This method will return the first entity it finds with a matching id.\r\n         *\r\n         * @method getEntityById\r\n         * @param {string} id The entity id to find.\r\n         * @return {Entity} Returns the entity that matches the specified entity id.\r\n         **/\r\n        getEntityById (id) {\r\n            var i = 0,\r\n                selection = null;\r\n            \r\n            for (i = 0; i < this.layers.length; i++) {\r\n                if (this.layers[i].id === id) {\r\n                    return this.layers[i];\r\n                }\r\n                if (this.layers[i].getEntityById) {\r\n                    selection = this.layers[i].getEntityById(id);\r\n                    if (selection) {\r\n                        return selection;\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        /**\r\n         * This method will return all game entities that match the provided type.\r\n         *\r\n         * @method getEntitiesByType\r\n         * @param {String} type The entity type to find.\r\n         * @return entities {Array} Returns the entities that match the specified entity type.\r\n         **/\r\n        getEntitiesByType (type) {\r\n            var i = 0,\r\n                selection = null,\r\n                entities  = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            \r\n            for (i = 0; i < this.layers.length; i++) {\r\n                if (this.layers[i].type === type) {\r\n                    entities.push(this.layers[i]);\r\n                }\r\n                if (this.layers[i].getEntitiesByType) {\r\n                    selection = this.layers[i].getEntitiesByType(type);\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(entities, selection);\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(selection);\r\n                }\r\n            }\r\n            return entities;\r\n        }\r\n\r\n        /**\r\n         * This method destroys all the layers in the scene.\r\n         *\r\n         * @method exit\r\n         **/\r\n        exit () {\r\n            var i = 0;\r\n            \r\n            for (i = 0; i < this.layers.length; i++) {\r\n                this.layers[i].destroy();\r\n            }\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.layers);\r\n            this.layers = null;\r\n            \r\n            if (this.loader) {\r\n                this.loader.reset();\r\n                this.loader = null;\r\n            }\r\n            // Unload all base textures to prep for next scene\r\n            _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].unloadBaseTextures();\r\n\r\n            if (this.unloadAssets) {\r\n                this.unloadAssets();\r\n                this.unloadAssets = null;\r\n            }\r\n\r\n            platypus.game.currentScene = null;\r\n        }\r\n\r\n        /**\r\n         * Don't use the state object after this\r\n         * @method destroy\r\n         */\r\n        destroy () {\r\n            // Only destroy once!\r\n            if (this._destroyed) return;\r\n\r\n            this.trigger('destroy');\r\n\r\n            this.app = null;\r\n            this.scaling = null;\r\n            this.sound = null;\r\n            this.voPlayer = null;\r\n            this.config = null;\r\n            this.scalingItems = null;\r\n            this.assets = null;\r\n            this.preload = null;\r\n            this.panel = null;\r\n            this.manager = null;\r\n            this._destroyed = true;\r\n            this._onEnterProceed = null;\r\n            this._onLoadingComplete = null;\r\n\r\n            super.destroy();\r\n        };\r\n        \r\n        /**\r\n         * Returns all of the assets required for the Scene. This method calls the corresponding method on all entities to determine the list of assets. It ignores assets that have already been preloaded.\r\n         *\r\n         * @method getAssetList\r\n         * @param definition {Object} The definition for the Scene.\r\n         * @return {Array} A list of the necessary assets to load.\r\n         */\r\n        getAssetList (def) {\r\n            var i = 0,\r\n                arr = null,\r\n                assets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            \r\n            if (def.assets) {\r\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, def.assets);\r\n            }\r\n            \r\n            for (i = 0; i < def.layers.length; i++) {\r\n                arr = _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getAssetList(def.layers[i]);\r\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\r\n            }\r\n            \r\n            arr = filterAssets(assets, this.preload);\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(assets);\r\n            \r\n            return arr;\r\n        }\r\n        \r\n        /**\r\n         * Returns all of the dynamic assets required for the Scene.\r\n         *\r\n         * @method getLateAssetList\r\n         * @return {Array} A list of the necessary assets to load.\r\n         */\r\n        getLateAssetList (def) {\r\n            var i = 0,\r\n                arr = null,\r\n                assets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            \r\n            for (i = 0; i < def.layers.length; i++) {\r\n                arr = _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getLateAssetList(def.layers[i], null, this.data);\r\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\r\n            }\r\n            \r\n            arr = filterAssets(assets, this.preload);\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(assets);\r\n            \r\n            return arr;\r\n        }\r\n    }\r\n\r\n    return Scene;\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/Scene.js?");

/***/ }),

/***/ "./src/StateMap.js":
/*!*************************!*\
  !*** ./src/StateMap.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/string.js */ \"./src/utils/string.js\");\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\r\n * This class defines a state object to use for entity states with helper methods. It includes recycle methods to encourage reuse.\r\n *\r\n * @namespace platypus\r\n * @class StateMap\r\n * @constructor\r\n * @return stateMap {platypus.StateMap} Returns the new StateMap object.\r\n * @extends platypus.DataMap\r\n * @since 0.8.0\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var StateMap = function (first) {\r\n            var l = arguments.length;\r\n            \r\n            if (l) {\r\n                if ((l === 1) && (typeof first === 'string')) {\r\n                    _DataMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].call(this);\r\n                    this.updateFromString(first);\r\n                } else {\r\n                    _DataMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].apply(this, arguments);\r\n                }\r\n            } else {\r\n                _DataMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].call(this);\r\n            }\r\n        },\r\n        parent = _DataMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype,\r\n        proto = StateMap.prototype = Object.create(parent);\r\n\r\n    Object.defineProperty(StateMap.prototype, 'constructor', {\r\n        configurable: true,\r\n        writable: true,\r\n        value: StateMap\r\n    });\r\n        \r\n    /**\r\n     * Sets the state using the provided string value which is a comma-delimited list such that `\"blue,red,!green\"` sets the following state values:\r\n     *\r\n     *      {\r\n     *          red: true,\r\n     *          blue: true,\r\n     *          green: false\r\n     *      }\r\n     *\r\n     * @method updateFromString\r\n     * @param states {String} A comma-delimited list of true/false state values.\r\n     * @chainable\r\n     */\r\n    Object.defineProperty(proto, 'updateFromString', {\r\n        value: function (states) {\r\n            var arr = Object(_utils_string_js__WEBPACK_IMPORTED_MODULE_3__[\"greenSplit\"])(states, ','),\r\n                i = arr.length,\r\n                str = '';\r\n            \r\n            while (i--) {\r\n                str = arr[i];\r\n                if (str) {\r\n                    if (str.substr(0, 1) === '!') {\r\n                        this.set(str.substr(1), false);\r\n                    } else {\r\n                        this.set(str, true);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(arr);\r\n            \r\n            return this;\r\n        }\r\n    });\r\n    \r\n    /**\r\n     * Checks whether the provided state matches this state and updates this state to match.\r\n     *\r\n     * @method update\r\n     * @param state {platypus.StateMap} The state that this state should match.\r\n     * @return {Boolean} Whether this state already matches the provided state.\r\n     */\r\n    Object.defineProperty(proto, 'update', {\r\n        value: function (newState) {\r\n            var keys = newState.keys,\r\n                i = keys.length,\r\n                state   = '',\r\n                changed = false,\r\n                value = false;\r\n            \r\n            while (i--) {\r\n                state = keys[i];\r\n                value = newState.get(state);\r\n                if (this.get(state) !== value) {\r\n                    this.set(state, value);\r\n                    changed = true;\r\n                }\r\n            }\r\n            \r\n            return changed;\r\n        }\r\n    });\r\n    \r\n    /**\r\n     * Checks whether the provided state matches all equivalent keys on this state.\r\n     *\r\n     * @method includes\r\n     * @param state {platypus.StateMap} The state that this state should match.\r\n     * @return {Boolean} Whether this state matches the provided state.\r\n     */\r\n    Object.defineProperty(proto, 'includes', {\r\n        value: function (otherState) {\r\n            var keys = otherState.keys,\r\n                i = keys.length,\r\n                state = '';\r\n            \r\n            while (i--) {\r\n                state = keys[i];\r\n                if (this.get(state) !== otherState.get(state)) {\r\n                    return false;\r\n                }\r\n            }\r\n            \r\n            return true;\r\n        }\r\n    });\r\n    \r\n    /**\r\n     * Checks whether the provided state matches any equivalent keys on this state.\r\n     *\r\n     * @method intersects\r\n     * @param state {platypus.StateMap} The state that this state should intersect.\r\n     * @return {Boolean} Whether this state intersects the provided state.\r\n     */\r\n    Object.defineProperty(proto, 'intersects', {\r\n        value: function (otherState) {\r\n            var keys = otherState.keys,\r\n                i = keys.length,\r\n                state = '';\r\n            \r\n            while (i--) {\r\n                state = keys[i];\r\n                if (this.get(state) === otherState.get(state)) {\r\n                    return true;\r\n                }\r\n            }\r\n            \r\n            return false;\r\n        }\r\n    });\r\n    \r\n    /**\r\n     * Returns StateMap from cache or creates a new one if none are available.\r\n     *\r\n     * @method StateMap.setUp\r\n     * @return stateMap {platypus.StateMap} The instantiated StateMap.\r\n     */\r\n    /**\r\n     * Returns StateMap back to the cache. Prefer the StateMap's recycle method since it recycles property objects as well.\r\n     *\r\n     * @method StateMap.recycle\r\n     * @param stateMap {platypus.StateMap} The StateMap to be recycled.\r\n     */\r\n    /**\r\n     * Relinquishes StateMap properties and recycles it.\r\n     *\r\n     * @method recycle\r\n     */\r\n    recycle__WEBPACK_IMPORTED_MODULE_4__[\"default\"].add(StateMap, 'StateMap', StateMap, function () {\r\n        this.clear();\r\n    }, true, config__WEBPACK_IMPORTED_MODULE_2___default.a.dev);\r\n    \r\n    return StateMap;\r\n}());\n\n//# sourceURL=webpack://platypus/./src/StateMap.js?");

/***/ }),

/***/ "./src/Storage.js":
/*!************************!*\
  !*** ./src/Storage.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Storage; });\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var springroll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! springroll */ \"springroll\");\n/* harmony import */ var springroll__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(springroll__WEBPACK_IMPORTED_MODULE_1__);\n/**\r\n * This class defines a generic data object to use for messaging. It includes recycle methods to encourage reuse.\r\n *\r\n * @namespace platypus\r\n * @class Data\r\n * @constructor\r\n * @return {Data} Returns the new Data object.\r\n * @since 0.7.1\r\n */\r\n/* global platypus, window */\r\n\r\n\r\n\r\nclass Storage {\r\n    constructor (springroll, options) {\r\n        const\r\n            gameId = options.name,\r\n            storageKey = gameId + '-data',\r\n            unconnectedData = window.localStorage.getItem(storageKey),\r\n            keys = options.storageKeys || null,\r\n            handleData = (resp) => {\r\n                if (resp && resp.data) {\r\n                    const data = resp.data;\r\n\r\n                    for (const key in data) {\r\n                        if (data.hasOwnProperty(key)) {\r\n                            if (this.map.has(key)) {\r\n                                this.map.set(key, data[key]);\r\n                            } else {\r\n                                this.addKey(key, data[key]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n        this.map = _DataMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\r\n        this.storageKey = storageKey;\r\n        this.connected = false;\r\n\r\n        if (keys) {\r\n            for (let i = 0; i < keys.length; i++) {\r\n                this.addKey(keys[i], null);\r\n            }\r\n        }\r\n\r\n        try { // May throw if data is not parseable. If so, we'll just ignore it.\r\n            handleData({\r\n                data: JSON.parse(unconnectedData)\r\n            });\r\n        } catch (e) {}\r\n\r\n        springroll.container.on('connected', () => {\r\n            this.connected = true;\r\n            springroll__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].read(this.storageKey).then(handleData).catch((e) => {\r\n                platypus.debug.warn('Storage: connected but received an error', e);\r\n            });\r\n        });\r\n    }\r\n\r\n    addKey (key, value) {\r\n        this.map.set(key, value);\r\n        Object.defineProperty(this, key, {\r\n            get: function () {\r\n                return this.map.get(key);\r\n            },\r\n            set: function (value) {\r\n                this.map.set(key, value);\r\n\r\n                this.save();\r\n            },\r\n            enumerable: true\r\n        });\r\n    }\r\n\r\n    get (key) {\r\n        if (!this.map.has(key)) {\r\n            this.addKey(key, null);\r\n        }\r\n\r\n        return this[key];\r\n    }\r\n\r\n    save () {\r\n        const save = this.map.toJSON();\r\n        \r\n        if (this.connected) {\r\n            springroll__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].write(this.storageKey, save).catch((e) => {\r\n                platypus.debug.warn('Storage: tried to save but received an error', e);\r\n            });\r\n        } else {\r\n            window.localStorage.setItem(this.storageKey, JSON.stringify(save));\r\n        }\r\n    }\r\n\r\n    set (key, value) {\r\n        if (!this.map.has(key)) {\r\n            this.addKey(key, value);\r\n            this.save();\r\n        } else {\r\n            this[key] = value;\r\n        }\r\n    }\r\n}\n\n//# sourceURL=webpack://platypus/./src/Storage.js?");

/***/ }),

/***/ "./src/Vector.js":
/*!***********************!*\
  !*** ./src/Vector.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\r\n * This class defines a multi-dimensional vector object and a variety of methods for manipulating the vector.\r\n *\r\n * @namespace platypus\r\n * @class Vector\r\n * @constructor\r\n * @param x {number|Array|Vector} The x coordinate or an array or Vector describing the whole vector.\r\n * @param [y] {number} The y coordinate.\r\n * @param [z] {number} The z coordinate.\r\n */\r\n/*global platypus */\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var Vector = function (x, y, z) {\r\n            if (this.matrix) { // Recycled vectors will already have a matrix array. Resetting x, y, z to 0's to properly handle a set-up array of less than 3 dimensions.\r\n                this.matrix[0] = 0;\r\n                this.matrix[1] = 0;\r\n                this.matrix[2] = 0;\r\n            } else {\r\n                this.matrix = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 0, 0);\r\n            }\r\n            this.set(x, y, z);\r\n        },\r\n        proto = Vector.prototype;\r\n    \r\n    /**\r\n     * The x component of the vector.\r\n     *\r\n     * @property x\r\n     * @type number\r\n     * @default 0\r\n     */\r\n    Object.defineProperty(proto, 'x', {\r\n        get: function () {\r\n            return this.matrix[0];\r\n        },\r\n        set: function (value) {\r\n            this.matrix[0] = value;\r\n        }\r\n    });\r\n    \r\n    /**\r\n     * The y component of the vector.\r\n     *\r\n     * @property y\r\n     * @type number\r\n     * @default 0\r\n     */\r\n    Object.defineProperty(proto, 'y', {\r\n        get: function () {\r\n            return this.matrix[1];\r\n        },\r\n        set: function (value) {\r\n            this.matrix[1] = value;\r\n        }\r\n    });\r\n    \r\n    /**\r\n     * The z component of the vector.\r\n     *\r\n     * @property z\r\n     * @type number\r\n     * @default 0\r\n     */\r\n    Object.defineProperty(proto, 'z', {\r\n        get: function () {\r\n            return this.matrix[2];\r\n        },\r\n        set: function (value) {\r\n            this.matrix[2] = value;\r\n        }\r\n    });\r\n    \r\n    /**\r\n     * Returns a string describing the vector in the format of \"[x, y, z]\".\r\n     *\r\n     * @method toString\r\n     * @return {String}\r\n     */\r\n    proto.toString = function () {\r\n        return '[' + this.matrix.join(',') + ']';\r\n    };\r\n    \r\n    /**\r\n     * Sets the coordinates of the vector.\r\n     *\r\n     * @method set\r\n     * @param x {number|Array|Vector} The x coordinate or an array or Vector describing the whole vector.\r\n     * @param [y] {number} The y coordinate, or if x is an array/Vector this is the number of elements to copy from the array/Vector.\r\n     * @param [z] {number} The z coordinate.\r\n     * @chainable\r\n     */\r\n    proto.set = function (x, y, z) {\r\n        if (x && x.matrix) {                // Passing in a vector.\r\n            return this.setVector(x, y);\r\n        } else if (x && (typeof x.x === 'number') && (typeof x.y === 'number')) { // Passing in a vector-like object.\r\n            return this.setXYZ(x.x, x.y, x.z);\r\n        } else if (x && Array.isArray(x)) { // Passing in an array.\r\n            return this.setArray(x, y);\r\n        } else {                            // Passing in coordinates.\r\n            return this.setXYZ(x, y, z);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets the coordinates of the vector.\r\n     *\r\n     * @method setXYZ\r\n     * @param x {number} The x coordinate.\r\n     * @param [y] {number} The y coordinate.\r\n     * @param [z] {number} The z coordinate.\r\n     * @chainable\r\n     * @since 0.7.4\r\n     */\r\n    proto.setXYZ = function (x, y, z) {\r\n        var matrix = this.matrix;\r\n        \r\n        matrix[0] = x || 0;\r\n        matrix[1] = y || 0;\r\n        matrix[2] = z || 0;\r\n        \r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Sets the coordinates of the vector.\r\n     *\r\n     * @method setVector\r\n     * @param vector {Vector} The Vector to copy.\r\n     * @param [dimensions] {number} The number of elements to copy from the Vector.\r\n     * @chainable\r\n     * @since 0.7.4\r\n     */\r\n    proto.setVector = function (vector, dimensions) {\r\n        return this.setArray(vector.matrix, dimensions);\r\n    };\r\n\r\n    /**\r\n     * Sets the coordinates of the vector.\r\n     *\r\n     * @method setArray\r\n     * @param arr {Array} The array to copy.\r\n     * @param [dimensions] {number} The number of elements to copy from the Array.\r\n     * @chainable\r\n     * @since 0.7.4\r\n     */\r\n    proto.setArray = function (arr, dimensions) {\r\n        var q = dimensions || arr.length,\r\n            matrix = this.matrix;\r\n        \r\n        while (q--) {\r\n            matrix[q] = arr[q];\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Determines whether two vectors are equal.\r\n     *\r\n     * @method equals\r\n     * @param x {number|Array|Vector} The x coordinate or an array or Vector to check against.\r\n     * @param [y] {number} The y coordinate, or if x is an array/Vector this is the number of dimensions to check from the array/Vector.\r\n     * @param [z] {number} The z coordinate.\r\n     * @return {Boolean} Whether the vectors are equal.\r\n     * @since 0.7.3\r\n     */\r\n    proto.equals = function (x, y, z) {\r\n        var m = null,\r\n            q = 0,\r\n            matrix = this.matrix;\r\n        \r\n        if (x && Array.isArray(x)) {   // Passing in an array.\r\n            q = y || x.length;\r\n            while (q--) {\r\n                if (matrix[q] !== x[q]) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } else if (x && x.matrix) {   // Passing in a vector.\r\n            m = x.matrix;\r\n            q = y || m.length;\r\n            while (q--) {\r\n                if (matrix[q] !== m[q]) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } else {                     // Passing in coordinates.\r\n            return ((typeof x === 'number') && (matrix[0] === x)) && ((typeof y !== 'number') || (matrix[1] === y)) && ((typeof z !== 'number') || (matrix[2] === z));\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Returns the magnitude of the vector.\r\n     *\r\n     * @method magnitude\r\n     * @param [dimensions] {number} The dimensions to include. Defaults to all dimensions.\r\n     * @return {number} The magnitude of the vector.\r\n     */\r\n    proto.magnitude = function (dimensions) {\r\n        return Math.sqrt(this.magnitudeSquared(dimensions));\r\n    };\r\n    \r\n    /**\r\n     * Returns the magnitude squared of the vector. This is slightly faster than finding the magnitude.\r\n     *\r\n     * @method magnitudeSquared\r\n     * @param [dimensions] {number} The dimensions to include. Defaults to all dimensions.\r\n     * @return {number} The magnitude squared of the vector.\r\n     */\r\n    proto.magnitudeSquared = function (dimensions) {\r\n        var squares = 0,\r\n            x = 0;\r\n\r\n        dimensions = dimensions || this.matrix.length;\r\n\r\n        for (x = 0; x < dimensions; x++) {\r\n            squares += Math.pow(this.matrix[x], 2);\r\n        }\r\n\r\n        return squares;\r\n    };\r\n    \r\n    /**\r\n     * Returns the direction of the vector from the z-axis\r\n     *\r\n     * @return {number} The direction of the vector in radians.\r\n     */\r\n    proto.getAngle = function () {\r\n        var mag   = this.magnitude(2),\r\n            angle = 0;\r\n\r\n        if (mag !== 0) {\r\n            angle = Math.acos(this.x / mag);\r\n            if (this.y < 0) {\r\n                angle = (Math.PI * 2) - angle;\r\n            }\r\n        }\r\n        return angle;\r\n    };\r\n    \r\n    /**\r\n     * Returns a normalized copy of the vector.\r\n     *\r\n     * @method getUnit\r\n     * @return {platypus.Vector} A normalized vector in the same direction as this vector.\r\n     */\r\n    proto.getUnit = function () {\r\n        return Vector.setUp(this).normalize();\r\n    };\r\n    \r\n    /**\r\n     * Returns a copy of the Vector inverted.\r\n     *\r\n     * @method getInverse\r\n     * @return {platypus.Vector}\r\n     */\r\n    proto.getInverse = function () {\r\n        return Vector.setUp(this).multiply(-1);\r\n    };\r\n    \r\n    /**\r\n     * Normalizes the vector.\r\n     *\r\n     * @method normalize\r\n     * @chainable\r\n     */\r\n    proto.normalize = function () {\r\n        var mag = this.magnitude();\r\n        \r\n        if (mag === 0) {\r\n            // Ignores attempt to normalize a vector of zero magnitude.\r\n            return this;\r\n        } else {\r\n            return this.multiply(1 / mag);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Crosses this vector with the parameter vector.\r\n     *\r\n     * @method cross\r\n     * @param vector {platypus.Vector} The vector to cross this vector with.\r\n     * @chainable\r\n     */\r\n    proto.cross = (function () {\r\n        var det = function (a, b, c, d) {\r\n            return a * d - b * c;\r\n        };\r\n        \r\n        return function (v) {\r\n            var tempX = det(this.y, this.z, v.y, v.z),\r\n                tempY = -det(this.x, this.z, v.x, v.z),\r\n                tempZ = det(this.x, this.y, v.x, v.y);\r\n            \r\n            this.x = tempX;\r\n            this.y = tempY;\r\n            this.z = tempZ;\r\n            \r\n            return this;\r\n        };\r\n    }());\r\n    \r\n    /**\r\n     * Crosses this vector with the parameter vector and returns the cross product.\r\n     *\r\n     * @method getCrossProduct\r\n     * @param vector {platypus.Vector} The vector to cross this vector with.\r\n     * @return {platypus.Vector} The cross product.\r\n     */\r\n    proto.getCrossProduct = function (v) {\r\n        return Vector.setUp(this).cross(v);\r\n    };\r\n    \r\n    /**\r\n     * Rotates the vector by the given amount.\r\n     *\r\n     * @method rotate\r\n     * @param angle {number} The amount to rotate the vector in radians.\r\n     * @param [axis=\"z\"] {String|Vector} A vector describing the axis around which the rotation should occur or 'x', 'y', or 'z'.\r\n     * @chainable\r\n     */\r\n    proto.rotate = function (angle, axis) {\r\n        var a    = axis,\r\n            arr  = null,\r\n            cos  = Math.cos(angle),\r\n            sin  = Math.sin(angle),\r\n            icos = 1 - cos,\r\n            x    = 0,\r\n            y    = 0,\r\n            z    = 0,\r\n            temp = Vector.setUp();\r\n        \r\n        if (a) {\r\n            if (a === 'x') {\r\n                a = temp.setXYZ(1, 0, 0);\r\n            } else if (a === 'y') {\r\n                a = temp.setXYZ(0, 1, 0);\r\n            } else if (a === 'z') {\r\n                a = temp.setXYZ(0, 0, 1);\r\n            }\r\n        } else {\r\n            a = temp.setXYZ(0, 0, 1);\r\n        }\r\n        \r\n        x     = a.x;\r\n        y     = a.y;\r\n        z     = a.z;\r\n        \r\n        arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(    cos + x * x * icos, x * y * icos - z * sin, x * z * icos + y * sin),\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(y * x * icos + z * sin,     cos + y * y * icos, y * z * icos - x * sin),\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(z * x * icos - y * sin, z * y * icos + x * sin,     cos + z * z * icos)\r\n        );\r\n        \r\n        this.multiply(arr);\r\n        \r\n        temp.recycle();\r\n        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr, 2);\r\n        \r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Rotates the vector position around a given point on the cartesian plane.\r\n     *\r\n     * @method rotateAbout\r\n     * @param point {Vector} A vector describing the point around which the rotation should occur.\r\n     * @param angle {number} The amount to rotate the vector in radians.\r\n     * @chainable\r\n     */\r\n    proto.rotateAbout = function (point, angle) {\r\n        const cos = Math.cos(angle),\r\n            sin = Math.sin(angle),\r\n            dx = this.x - point.x,\r\n            dy = this.y - point.y;\r\n\r\n        this.x = point.x + (dx * cos - dy * sin);\r\n        this.y = point.y + (dx * sin + dy * cos);\r\n\r\n        return this;\r\n    };\r\n    \r\n    /**\r\n     * Scales the vector by the given factor or performs a transform if a matrix is provided.\r\n     *\r\n     * @method multiply\r\n     * @param multiplier {number|Array} The factor to scale by or a 2D array describing a multiplication matrix.\r\n     * @param limit {number} For scaling, determines which coordinates are affected.\r\n     * @chainable\r\n     */\r\n    proto.multiply = function (multiplier, limit) {\r\n        var i = 0,\r\n            j = 0,\r\n            arr = null,\r\n            l = 0;\r\n        \r\n        if (Array.isArray(multiplier)) {\r\n            arr = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(this.matrix);\r\n            l = limit || multiplier.length;\r\n            for (i = 0; i < l; i++) {\r\n                this.matrix[i] = 0;\r\n                for (j = 0; j < l; j++) {\r\n                    this.matrix[i] += arr[j] * multiplier[i][j];\r\n                }\r\n            }\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\r\n        } else {\r\n            l = limit || this.matrix.length;\r\n            for (i = 0; i < l; i++) {\r\n                this.matrix[i] *= multiplier;\r\n            }\r\n        }\r\n        \r\n        return this;\r\n    };\r\n    \r\n    /**\r\n     * Adds the given components to this vector.\r\n     *\r\n     * @method add\r\n     * @param x {number|Array|Vector} The x component to add, or an array or vector describing the whole addition.\r\n     * @param [y] {number} The y component to add or the limit if the first parameter is a vector or array.\r\n     * @param [z] {number} The z component to add.\r\n     * @chainable\r\n     */\r\n    proto.add = function (x, y, z) {\r\n        var addMatrix = x,\r\n            limit = 0,\r\n            q = 0;\r\n\r\n        if (!Array.isArray(addMatrix)) {\r\n            if (addMatrix instanceof Vector) {\r\n                addMatrix = addMatrix.matrix;\r\n                limit = y || this.matrix.length;\r\n            } else {\r\n                addMatrix = [x || 0, y || 0, z || 0];\r\n                limit = this.matrix.length;\r\n            }\r\n        } else {\r\n            limit = y || this.matrix.length;\r\n        }\r\n        \r\n        for (q = 0; q < limit; q++) {\r\n            this.matrix[q] += addMatrix[q];\r\n        }\r\n        \r\n        return this;\r\n    };\r\n    \r\n    /**\r\n     * Adds the given vector to this vector.\r\n     *\r\n     * @method addVector\r\n     * @param otherVector {platypus.Vector} The vector to add.\r\n     * @chainable\r\n     */\r\n    proto.addVector = function (otherVector, dimensions) {\r\n        return this.add(otherVector, dimensions);\r\n    };\r\n    \r\n    /**\r\n     * Subtracts the given vector from this vector.\r\n     *\r\n     * @method subtractVector\r\n     * @param otherVector {platypus.Vector} The vector to subtract.\r\n     * @chainable\r\n     */\r\n    proto.subtractVector = function (otherVector, dimensions) {\r\n        var inv = otherVector.getInverse();\r\n\r\n        this.add(inv, dimensions);\r\n        inv.recycle();\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Returns the perpendicular vector.\r\n     *\r\n     * @method perpendicular\r\n     * @param opposite {Boolean} Whether to negate the perpendicular vector.\r\n     * @chainable\r\n     */\r\n    proto.perpendicular = function (negate) {\r\n        const matrix = this.matrix,\r\n            mult = (negate === true) ? -1 : 1,\r\n            x = -this.matrix[1];\r\n\r\n        matrix[1] = matrix[0];\r\n        matrix[0] = x;\r\n\r\n        if (negate) {\r\n            matrix[1] *= mult;\r\n            matrix[0] *= mult;\r\n        }\r\n\r\n        return this;\r\n    };\r\n    \r\n    /**\r\n     * Scales the vector by the given factor.\r\n     *\r\n     * @method multiply\r\n     * @param factor {number} The factor to scale by.\r\n     * @param limit {number} Determines which coordinates are affected. Defaults to all coordinates.\r\n     * @chainable\r\n     */\r\n    proto.scale = function (factor, limit) {\r\n        return this.multiply(factor, limit);\r\n    };\r\n    \r\n    /**\r\n     * Finds the dot product of the two vectors.\r\n     *\r\n     * @method dot\r\n     * @param otherVector {platypus.Vector} The other vector.\r\n     * @param limit {number} The number of vector indexes to include in the dot product.\r\n     * @return {number} The dot product.\r\n     */\r\n    proto.dot = function (otherVector, limit) {\r\n        var sum = 0,\r\n            q = 0,\r\n            m = this.matrix,\r\n            oM = otherVector.matrix;\r\n            \r\n        q = limit || m.length;\r\n        \r\n        while (q--) {\r\n            sum += m[q] * (oM[q] || 0);\r\n        }\r\n        \r\n        return sum;\r\n    };\r\n    \r\n    /**\r\n     * Finds the shortest angle between the two vectors.\r\n     *\r\n     * @method angleTo\r\n     * @param otherVector {platypus.Vector} The other vector.\r\n     * @return {number} The angle between this vector and the received vector.\r\n     */\r\n    proto.angleTo = function (otherVector) {\r\n        var v1 = this.getUnit(),\r\n            v2 = otherVector.getUnit(),\r\n            ang = 0;\r\n            \r\n        if (v1.magnitude() && v2.magnitude()) { // Probably want a less expensive check here for zero-length vectors.\r\n            ang = Math.acos(v1.dot(v2));\r\n        } else {\r\n            platypus.debug.warn('Vector: Attempted to find the angle of a zero-length vector.');\r\n            ang = NaN;\r\n        }\r\n            \r\n        v1.recycle();\r\n        v2.recycle();\r\n        \r\n        return ang;\r\n    };\r\n    \r\n    /**\r\n     * Finds the shortest signed angle between the two vectors.\r\n     *\r\n     * @method signedAngleTo\r\n     * @param otherVector {platypus.Vector} The other vector.\r\n     * @param normal {platypus.Vector} A normal vector determining the resultant sign of the angle between two vectors.\r\n     * @return {number} The angle between this vector and the received vector.\r\n     */\r\n    proto.signedAngleTo = function (otherVector, normal) {\r\n        var v1 = this.getUnit(),\r\n            v2 = otherVector.getUnit(),\r\n            v3 = v1.getCrossProduct(v2),\r\n            ang = 0;\r\n        \r\n        if (v3.magnitude() === 0) {\r\n            ang = 0;\r\n        } else if (v3.dot(normal) < 0) {\r\n            ang = -Math.acos(v1.dot(v2));\r\n        } else {\r\n            ang =  Math.acos(v1.dot(v2));\r\n        }\r\n        \r\n        v1.recycle();\r\n        v2.recycle();\r\n        v3.recycle();\r\n        \r\n        return ang;\r\n    };\r\n    \r\n    /**\r\n     * Find the scalar value of projecting this vector onto the parameter vector or onto a vector at the specified angle away.\r\n     *\r\n     * @method scalerProjection\r\n     * @param vectorOrAngle {Vector|number} The other vector or the angle between the vectors.\r\n     * @return {number} The magnitude of the projection.\r\n     */\r\n    proto.scalarProjection = function (vectorOrAngle) {\r\n        var v = null,\r\n            d = 0;\r\n        \r\n        if (typeof vectorOrAngle === \"number\") {\r\n            return this.magnitude(2) * Math.cos(vectorOrAngle);\r\n        } else {\r\n            v = Vector.setUp(vectorOrAngle).normalize();\r\n            d = this.dot(v);\r\n            v.recycle();\r\n            return d;\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Returns a copy of this vector.\r\n     *\r\n     * @method copy\r\n     * @return {platypus.Vector} A copy of this vector.\r\n     */\r\n    proto.copy = function () {\r\n        return Vector.setUp(this);\r\n    };\r\n    \r\n    /**\r\n     * Adds properties to an object that describe the coordinates of a vector.\r\n     *\r\n     * @method Vector.assign\r\n     * @param object {Object} Object on which the coordinates and vector will be added.\r\n     * @param propertyName {String} A string describing the property name where the vector is accessable.\r\n     * @param [coordinateName*] {String} One or more parameters describing coordinate values on the object.\r\n     */\r\n    Vector.assign = (function () {\r\n        var createProperty = function (property, obj, vector, index) {\r\n            var temp = null,\r\n                propertyInUse = false;\r\n            \r\n            if (typeof property === 'string') {\r\n                if (typeof obj[property] !== 'undefined') {\r\n                    temp = obj[property];\r\n                    delete obj[property];\r\n                    propertyInUse = true;\r\n                }\r\n            }\r\n            \r\n            Object.defineProperty(obj, property, {\r\n                get: function () {\r\n                    return vector.matrix[index];\r\n                },\r\n                set: function (value) {\r\n                    vector.matrix[index] = value;\r\n                },\r\n                enumerable: true\r\n            });\r\n            \r\n            if (propertyInUse) {\r\n                obj[property] = temp;\r\n            }\r\n        };\r\n        \r\n        return function (obj, prop) {\r\n            var i = 0;\r\n\r\n            if (obj && prop) {\r\n                if (!obj[prop]) {\r\n                    obj[prop] = Vector.setUp();\r\n                    \r\n                    for (i = 2; i < arguments.length; i++) {\r\n                        if (arguments[i] !== prop) {\r\n                            createProperty(arguments[i], obj, obj[prop], i - 2);\r\n                        }\r\n                    }\r\n                    \r\n                    return null;\r\n                }\r\n                return obj[prop];\r\n            } else {\r\n                return null;\r\n            }\r\n        };\r\n    }());\r\n\r\n    /**\r\n     * Returns a Vector from cache or creates a new one if none are available.\r\n     *\r\n     * @method Vector.setUp\r\n     * @return {platypus.Vector} The instantiated Vector.\r\n     * @since 0.7.1\r\n     */\r\n    /**\r\n     * Returns a Vector back to the cache. Prefer the Vector's recycle method since it recycles property objects as well.\r\n     *\r\n     * @method Vector.recycle\r\n     * @param {platypus.Vector} The Vector to be recycled.\r\n     * @since 0.7.1\r\n     */\r\n    /**\r\n     * Relinquishes properties of the vector and recycles it.\r\n     *\r\n     * @method recycle\r\n     * @since 0.7.1\r\n     */\r\n    recycle__WEBPACK_IMPORTED_MODULE_2__[\"default\"].add(Vector, 'Vector', Vector, function () {\r\n        this.matrix.length = 0;\r\n    }, true, config__WEBPACK_IMPORTED_MODULE_1___default.a.dev);\r\n    \r\n    return Vector;\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/Vector.js?");

/***/ }),

/***/ "./src/components sync recursive .*\\.js":
/*!************************************!*\
  !*** ./src/components sync .*\.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var map = {\n\t\"./AIChaser.js\": \"./src/components/AIChaser.js\",\n\t\"./AIPacer.js\": \"./src/components/AIPacer.js\",\n\t\"./AudioMusic.js\": \"./src/components/AudioMusic.js\",\n\t\"./AudioSFX.js\": \"./src/components/AudioSFX.js\",\n\t\"./AudioVO.js\": \"./src/components/AudioVO.js\",\n\t\"./Camera.js\": \"./src/components/Camera.js\",\n\t\"./CameraFollowMe.js\": \"./src/components/CameraFollowMe.js\",\n\t\"./CollisionBasic.js\": \"./src/components/CollisionBasic.js\",\n\t\"./CollisionFilter.js\": \"./src/components/CollisionFilter.js\",\n\t\"./CollisionGroup.js\": \"./src/components/CollisionGroup.js\",\n\t\"./CollisionTiles.js\": \"./src/components/CollisionTiles.js\",\n\t\"./ComponentSwitcher.js\": \"./src/components/ComponentSwitcher.js\",\n\t\"./Counter.js\": \"./src/components/Counter.js\",\n\t\"./EntityContainer.js\": \"./src/components/EntityContainer.js\",\n\t\"./EntityController.js\": \"./src/components/EntityController.js\",\n\t\"./HandlerCollision.js\": \"./src/components/HandlerCollision.js\",\n\t\"./HandlerController.js\": \"./src/components/HandlerController.js\",\n\t\"./HandlerLogic.js\": \"./src/components/HandlerLogic.js\",\n\t\"./HandlerRender.js\": \"./src/components/HandlerRender.js\",\n\t\"./Interactive.js\": \"./src/components/Interactive.js\",\n\t\"./LevelBuilder.js\": \"./src/components/LevelBuilder.js\",\n\t\"./LogicAngularMovement.js\": \"./src/components/LogicAngularMovement.js\",\n\t\"./LogicAttachment.js\": \"./src/components/LogicAttachment.js\",\n\t\"./LogicButton.js\": \"./src/components/LogicButton.js\",\n\t\"./LogicCarrier.js\": \"./src/components/LogicCarrier.js\",\n\t\"./LogicDestroyMe.js\": \"./src/components/LogicDestroyMe.js\",\n\t\"./LogicDirectionalMovement.js\": \"./src/components/LogicDirectionalMovement.js\",\n\t\"./LogicDragDrop.js\": \"./src/components/LogicDragDrop.js\",\n\t\"./LogicImpactLaunch.js\": \"./src/components/LogicImpactLaunch.js\",\n\t\"./LogicPacingPlatform.js\": \"./src/components/LogicPacingPlatform.js\",\n\t\"./LogicPortable.js\": \"./src/components/LogicPortable.js\",\n\t\"./LogicPortal.js\": \"./src/components/LogicPortal.js\",\n\t\"./LogicPushable.js\": \"./src/components/LogicPushable.js\",\n\t\"./LogicRebounder.js\": \"./src/components/LogicRebounder.js\",\n\t\"./LogicRegionSpawner.js\": \"./src/components/LogicRegionSpawner.js\",\n\t\"./LogicRotationalMovement.js\": \"./src/components/LogicRotationalMovement.js\",\n\t\"./LogicSpawner.js\": \"./src/components/LogicSpawner.js\",\n\t\"./LogicStateMachine.js\": \"./src/components/LogicStateMachine.js\",\n\t\"./LogicSwitch.js\": \"./src/components/LogicSwitch.js\",\n\t\"./LogicTeleportee.js\": \"./src/components/LogicTeleportee.js\",\n\t\"./LogicTeleporter.js\": \"./src/components/LogicTeleporter.js\",\n\t\"./LogicTimer.js\": \"./src/components/LogicTimer.js\",\n\t\"./LogicWindUpRacer.js\": \"./src/components/LogicWindUpRacer.js\",\n\t\"./Motion.js\": \"./src/components/Motion.js\",\n\t\"./Mover.js\": \"./src/components/Mover.js\",\n\t\"./Node.js\": \"./src/components/Node.js\",\n\t\"./NodeMap.js\": \"./src/components/NodeMap.js\",\n\t\"./NodeResident.js\": \"./src/components/NodeResident.js\",\n\t\"./Orientation.js\": \"./src/components/Orientation.js\",\n\t\"./RandomEvents.js\": \"./src/components/RandomEvents.js\",\n\t\"./RelativePosition.js\": \"./src/components/RelativePosition.js\",\n\t\"./RelayFamily.js\": \"./src/components/RelayFamily.js\",\n\t\"./RelayGame.js\": \"./src/components/RelayGame.js\",\n\t\"./RelayLinker.js\": \"./src/components/RelayLinker.js\",\n\t\"./RelayParent.js\": \"./src/components/RelayParent.js\",\n\t\"./RelaySelf.js\": \"./src/components/RelaySelf.js\",\n\t\"./RenderAnimator.js\": \"./src/components/RenderAnimator.js\",\n\t\"./RenderContainer.js\": \"./src/components/RenderContainer.js\",\n\t\"./RenderDebug.js\": \"./src/components/RenderDebug.js\",\n\t\"./RenderDestroyMe.js\": \"./src/components/RenderDestroyMe.js\",\n\t\"./RenderProgress.js\": \"./src/components/RenderProgress.js\",\n\t\"./RenderSpine.js\": \"./src/components/RenderSpine.js\",\n\t\"./RenderSprite.js\": \"./src/components/RenderSprite.js\",\n\t\"./RenderText.js\": \"./src/components/RenderText.js\",\n\t\"./RenderTiles.js\": \"./src/components/RenderTiles.js\",\n\t\"./SceneChanger.js\": \"./src/components/SceneChanger.js\",\n\t\"./TiledLoader.js\": \"./src/components/TiledLoader.js\",\n\t\"./Timeline.js\": \"./src/components/Timeline.js\",\n\t\"./Tutorial.js\": \"./src/components/Tutorial.js\",\n\t\"./Tween.js\": \"./src/components/Tween.js\",\n\t\"./VoiceOver.js\": \"./src/components/VoiceOver.js\",\n\t\"./XHR.js\": \"./src/components/XHR.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/components sync recursive .*\\\\.js\";\n\n//# sourceURL=webpack://platypus/./src/components_sync_.*\\.js?");

/***/ }),

/***/ "./src/components/AIChaser.js":
/*!************************************!*\
  !*** ./src/components/AIChaser.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/**\r\n * This component acts as a simple AI that will chase another entity.\r\n *\r\n * @namespace platypus.components\r\n * @class AIChaser\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'AIChaser',\r\n        \r\n        properties: {\r\n            /**\r\n             * Sets whether the speed property should enact acceleration upon the entity rather than velocity.\r\n             *\r\n             * @property accelerate\r\n             * @type boolean\r\n             * @default false\r\n             */\r\n            accelerate: false,\r\n            \r\n            /**\r\n             * Whether the entity is in a chasing state.\r\n             *\r\n             * @property chasing\r\n             * @type boolean\r\n             * @default true\r\n             */\r\n            chasing: true\r\n        },\r\n        \r\n        publicProperties: {\r\n            /**\r\n             * Sets the velocity of the entity. This property is accessible on the entity as `entity.speed`.\r\n             *\r\n             * @property speed\r\n             * @type number\r\n             * @default 0.3\r\n             */\r\n            speed: 0.3\r\n        },\r\n        \r\n        initialize: function () {\r\n            this.target = this.owner.target || null;\r\n            this.offset = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(0, 0);\r\n            this.state = this.owner.state;\r\n            this.state.set('chasing', false);\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * This component listens for this event to initialize movement.\r\n             *\r\n             * @method 'load'\r\n             */\r\n            \"load\": function () {\r\n                if (!this.owner.addMover) {\r\n                    platypus.debug.warn('The \"AIChaser\" component requires a \"Mover\" component to function correctly.');\r\n                    return;\r\n                }\r\n                \r\n                this.direction = this.owner.addMover({\r\n                    vector: [this.speed, 0, 0],\r\n                    event: \"chase\",\r\n                    accelerator: this.accelerate\r\n                }).vector;\r\n            },\r\n        \r\n            /**\r\n             * This AI listens for a step message triggered by its entity parent in order to perform its logic on each tick.\r\n             *\r\n             * @method 'handle-ai'\r\n             */\r\n            \"handle-ai\": function () {\r\n                var v = null,\r\n                    m = 0,\r\n                    c = false;\r\n\r\n                if (this.target && this.chasing) {\r\n                    v = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.offset).add(this.target.position).subtractVector(this.owner.position);\r\n                    m = v.magnitude(2);\r\n\r\n                    if (m) {\r\n                        c = true;\r\n                        this.direction.setVector(v).normalize().multiply(this.speed);\r\n                    }\r\n\r\n                    v.recycle();\r\n                }\r\n                \r\n                if (c !== this.state.get('chasing')) {\r\n                    this.state.set('chasing', c);\r\n                    \r\n                    /**\r\n                     * This event is triggered whenever the entity begins chasing another entity or stops chasing another entity.\r\n                     *\r\n                     * @event 'chase'\r\n                     * @param chasing {boolean} Whether the entity is chasing another entity.\r\n                     */\r\n                    this.owner.triggerEvent('chase', c);\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the component will change its target and begin chasing the new entity.\r\n             *\r\n             * @method 'set-target'\r\n             * @param entity {platypus.Entity} Sets this entity's target to the provided entity.\r\n             */\r\n            \"set-target\": function (entity) {\r\n                this.target = entity;\r\n                this.offset.x = 0;\r\n                this.offset.y = 0;\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the component will change its target offset.\r\n             *\r\n             * @method 'set-target-offset'\r\n             * @param offset {Object|Vector} Sets the chased entity's offset to the provided offset.\r\n             * @param offset.x {number} The offset along the x-axis.\r\n             * @param offset.y {number} The offset along the y-axis.\r\n             */\r\n            \"set-target-offset\": function (offset) {\r\n                this.offset.x = offset.x;\r\n                this.offset.y = offset.y;\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the component will begin chasing the entity.\r\n             *\r\n             * @method 'start-chasing'\r\n             * @param [entity] {platypus.Entity} Sets the entity if it's provided.\r\n             */\r\n            \"start-chasing\": function (entity) {\r\n                if (entity) {\r\n                    this.target = entity;\r\n                }\r\n                this.chasing = true;\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the component will cease chasing the entity.\r\n             *\r\n             * @method 'stop-chasing'\r\n             */\r\n            \"stop-chasing\": function () {\r\n                this.chasing = false;\r\n            }\r\n        },\r\n        \r\n        methods: {// These are methods that are called on the component\r\n            destroy: function () {\r\n                this.target = null;\r\n                this.offset.recycle();\r\n                this.state = null;\r\n            }\r\n        }\r\n    });\r\n}());\n\n//# sourceURL=webpack://platypus/./src/components/AIChaser.js?");

/***/ }),

/***/ "./src/components/AIPacer.js":
/*!***********************************!*\
  !*** ./src/components/AIPacer.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * This component acts as a simple AI that will reverse the movement direction of an object when it collides with something.\r\n *\r\n * @namespace platypus.components\r\n * @class AIPacer\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        id: \"AIPacer\",\r\n        \r\n        properties: {\r\n            /**\r\n             * This determines the direction of movement. Can be \"horizontal\", \"vertical\", or \"both\".\r\n             *\r\n             * @property movement\r\n             * @type String\r\n             * @default \"both\"\r\n             */\r\n            movement: 'both',\r\n            \r\n            /**\r\n             * This sets the initial direction of movement. Defaults to \"up\", or \"left\" if movement is horizontal.\r\n             *\r\n             * @property direction\r\n             * @type String\r\n             * @default \"up\"\r\n             */\r\n            direction: null\r\n        },\r\n        \r\n        initialize: function () {\r\n            this.lastDirection    = '';\r\n            this.currentDirection = this.direction || ((this.movement === 'horizontal') ? 'left' : 'up');\r\n        },\r\n        \r\n        events: {\r\n            /**\r\n             * This AI listens for a step message triggered by its entity parent in order to perform its logic on each tick.\r\n             *\r\n             * @method 'handle-ai'\r\n             */\r\n            \"handle-ai\": function () {\r\n                if (this.currentDirection !== this.lastDirection) {\r\n                    this.lastDirection = this.currentDirection;\r\n                    \r\n                    /**\r\n                     * Triggers this event prior to changing direction.\r\n                     *\r\n                     * @event 'stop'\r\n                     */\r\n                    this.owner.triggerEvent('stop');\r\n                    \r\n                    /**\r\n                     * Triggers this event when the entity is moving right and collides with something.\r\n                     *\r\n                     * @event 'go-left'\r\n                     */\r\n                    /**\r\n                     * Triggers this event when the entity is moving left and collides with something.\r\n                     *\r\n                     * @event 'go-right'\r\n                     */\r\n                    /**\r\n                     * Triggers this event when the entity is moving up and collides with something.\r\n                     *\r\n                     * @event 'go-down'\r\n                     */\r\n                    /**\r\n                     * Triggers this event when the entity is moving down and collides with something.\r\n                     *\r\n                     * @event 'go-up'\r\n                     */\r\n                    this.owner.triggerEvent('go-' + this.currentDirection);\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the component will check the collision side and re-orient itself accordingly.\r\n             *\r\n             * @method 'turn-around'\r\n             * @param collisionInfo {platypus.CollisionData} Uses direction of collision to determine whether to turn around.\r\n             */\r\n            \"turn-around\": function (collisionInfo) {\r\n                if ((this.movement === 'both') || (this.movement === 'horizontal')) {\r\n                    if (collisionInfo.x > 0) {\r\n                        this.currentDirection = 'left';\r\n                    } else if (collisionInfo.x < 0) {\r\n                        this.currentDirection = 'right';\r\n                    }\r\n                }\r\n                if ((this.movement === 'both') || (this.movement === 'vertical')) {\r\n                    if (collisionInfo.y > 0) {\r\n                        this.currentDirection = 'up';\r\n                    } else if (collisionInfo.y < 0) {\r\n                        this.currentDirection = 'down';\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/AIPacer.js?");

/***/ }),

/***/ "./src/components/AudioMusic.js":
/*!**************************************!*\
  !*** ./src/components/AudioMusic.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi-sound */ \"pixi-sound\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_sound__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tweenjs/tween.js */ \"@tweenjs/tween.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2__);\n/**\r\n * This component plays music or background ambiance.\r\n *\r\n * @namespace platypus.components\r\n * @class AudioMusic\r\n * @uses platypus.Component\r\n * @since 6.0.0\r\n */\r\n/*global platypus */\r\n\r\n\r\n\r\n\r\nconst\r\n    Tween = _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_2___default.a.Tween,\r\n    tracks = {}; // List of actively-playing tracks.\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (platypus.createComponentClass({\r\n    id: 'AudioMusic',\r\n    \r\n    properties: {\r\n        /**\r\n         * Use the tracks property object to handle playing tracks or new tracks to load. Here is an example audioMap object:\r\n         *       {\r\n         *           \"audio-1\": \"audio-id\",\r\n         *\r\n         *           \"audio-2\": {\r\n         *               \"sound\": \"another-audio-id\",\r\n         *               // Required. This is the audio clip to loop.\r\n         *\r\n         *               \"volume\": 0.75,\r\n         *               // Optional. Used to specify how loud to play audio on a range from 0 (mute) to 1 (full volume). Default is 1.\r\n         *\r\n         *               \"fade\": 1000\r\n         *               // Optional. How long to fade to selected volume.\r\n         *           }\r\n         *       }\r\n         *\r\n         * Any tracks already playing and not defined here will fade out.\r\n         *\r\n         * @property tracks\r\n         * @type Object\r\n         * @default null\r\n         */\r\n        tracks: null\r\n    },\r\n        \r\n    initialize: function () {\r\n        const fadeOuts = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n        let fade = 1000;\r\n        \r\n        for (const key in tracks) {\r\n            if (tracks.hasOwnProperty(key)) {\r\n                fadeOuts.push(key);\r\n            }\r\n        }\r\n    \r\n        if (this.tracks) {\r\n            for (const key in this.tracks) {\r\n                if (this.tracks.hasOwnProperty(key)) {\r\n                    const fadeOut = fadeOuts.indexOf(key),\r\n                        trackProperties = this.tracks[key];\r\n                    \r\n                    let sound = tracks[key],\r\n                        tween = null;\r\n\r\n                    if (fadeOut >= 0) {\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(fadeOuts, fadeOut);\r\n                    } else { // gotta load it because it's not there!\r\n                        sound = tracks[key] = pixi_sound__WEBPACK_IMPORTED_MODULE_1___default.a.play(trackProperties.sound || trackProperties, {\r\n                            loop: Infinity,\r\n                            volume: trackProperties.fade ? 0 : (typeof trackProperties.volume === 'number' ? trackProperties.volume : 1)\r\n                        });\r\n                    }\r\n\r\n                    if (trackProperties.fade) {\r\n                        tween = new Tween(sound);\r\n                        tween.to({\r\n                            volume: typeof trackProperties.volume === 'number' ? trackProperties.volume : 1\r\n                        }, trackProperties.fade);\r\n                        tween.start();\r\n\r\n                        // default to what is being used for defined sounds to handle undefined sounds.\r\n                        fade = trackProperties.fade;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        fadeOuts.forEach((value) => {\r\n            const sound = tracks[value],\r\n                tween = new Tween(sound);\r\n\r\n            tween.to({\r\n                volume: 0\r\n            }, fade);\r\n            tween.onComplete(() => {\r\n                sound.stop();\r\n                sound.unload();\r\n                delete tracks[value];\r\n            });\r\n            tween.start();\r\n        });\r\n    },\r\n\r\n    events: {\r\n        /**\r\n         * On receiving this message all music will mute.\r\n         *\r\n         * @method 'mute-music'\r\n         */\r\n        \"mute-music\": function () {\r\n            for (const key in tracks) {\r\n                if (tracks.hasOwnProperty(key)) {\r\n                    tracks[key].muted = true;\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * On receiving this message all music will unmute.\r\n         *\r\n         * @method 'unmute-music'\r\n         */\r\n        \"unmute-music\": function () {\r\n            for (const key in tracks) {\r\n                if (tracks.hasOwnProperty(key)) {\r\n                    tracks[key].muted = false;\r\n                }\r\n            }\r\n        }\r\n    },\r\n    \r\n    methods: {\r\n        destroy: function () {\r\n        }\r\n    },\r\n        \r\n    getAssetList: function (component, props, defaultProps) {\r\n        var key = '',\r\n            preload = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n            tracks = component.tracks || props.tracks || defaultProps.tracks;\r\n        \r\n        if (tracks) {\r\n            for (key in tracks) {\r\n                if (tracks.hasOwnProperty(key)) {\r\n                    const item = (tracks[key].sound || tracks[key]) + '.{ogg,mp3}';\r\n                    if (preload.indexOf(item) === -1) {\r\n                        preload.push(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return preload;\r\n    }\r\n}));\r\n\n\n//# sourceURL=webpack://platypus/./src/components/AudioMusic.js?");

/***/ }),

/***/ "./src/components/AudioSFX.js":
/*!************************************!*\
  !*** ./src/components/AudioSFX.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pixi-sound */ \"pixi-sound\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(pixi_sound__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../StateMap.js */ \"./src/StateMap.js\");\n/**\r\n * This component plays audio using the SpringRoll Sound instance. Audio is played in one of two ways, by triggering specific messages defined in the audio component definition or using an audio map which plays sounds when the entity enters specified states.\r\n *\r\n * @namespace platypus.components\r\n * @class AudioSFX\r\n * @uses platypus.Component\r\n * @since 0.6.0\r\n */\r\n/*global platypus */\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var defaultSettings = {\r\n            interrupt: 0,\r\n            delay: 0,\r\n            offset: 0,\r\n            loop: 0,\r\n            volume: 1,\r\n            pan: 0,\r\n            mute: false,\r\n            paused: false\r\n        },\r\n        playSound = function (soundDefinition, channel) {\r\n            var sound      = '',\r\n                attributes = null,\r\n                completed  = function (data/*, cancelled*/) {\r\n                    if (data.audio && !this.owner.destroyed) {\r\n                        //clean up active clips\r\n                        this.removeClip(data.audio);\r\n                        \r\n                        /**\r\n                         * When a sound effect is finished playing, this event is triggered.\r\n                         *\r\n                         * @event clip-complete\r\n                         */\r\n                        this.owner.triggerEvent('clip-complete');\r\n                    }\r\n                    data.recycle();\r\n                };\r\n            \r\n            if (typeof soundDefinition === 'string') {\r\n                sound      = soundDefinition;\r\n                attributes = {\r\n                    channel: channel\r\n                };\r\n            } else {\r\n                sound      = soundDefinition.sound;\r\n                attributes = {\r\n                    interrupt: soundDefinition.interrupt,\r\n                    delay: soundDefinition.delay,\r\n                    offset: soundDefinition.offset,\r\n                    loop: soundDefinition.loop,\r\n                    volume: soundDefinition.volume,\r\n                    pan: soundDefinition.pan,\r\n                    startTime: soundDefinition.startTime,\r\n                    duration: soundDefinition.duration,\r\n                    mute: soundDefinition.mute,\r\n                    paused: soundDefinition.paused,\r\n                    channel: channel\r\n                };\r\n            }\r\n\r\n            return function (value) {\r\n                var data = null,\r\n                    wait = null;\r\n\r\n                value = value || attributes;\r\n                \r\n                data = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\r\n                    \"interrupt\", value.interrupt || attributes.interrupt || defaultSettings.interrupt,\r\n                    \"delay\",     value.delay     || attributes.delay  || defaultSettings.delay,\r\n                    \"loop\",      value.loop      || attributes.loop   || defaultSettings.loop,\r\n                    \"loops\",     value.loop      || attributes.loop   || defaultSettings.loop, // SoundJS 2.0 listens for this\r\n                    \"offset\",    value.offset    || attributes.offset || defaultSettings.offset,\r\n                    \"volume\",    (typeof value.volume !== 'undefined') ? value.volume : ((typeof attributes.volume !== 'undefined') ? attributes.volume : defaultSettings.volume),\r\n                    \"pan\",       value.pan       || attributes.pan    || defaultSettings.pan,\r\n                    \"mute\",      value.mute      || attributes.mute   || defaultSettings.mute,\r\n                    \"paused\",    value.paused    || attributes.paused || defaultSettings.paused,\r\n                    \"channel\",    value.channel    || attributes.channel || defaultSettings.channel\r\n                );\r\n                data.complete = completed.bind(this, data);\r\n                data.audio = this.player.play(sound, data);\r\n                if (data.pan) {\r\n                    data.audio.filters = [\r\n                        new pixi_sound__WEBPACK_IMPORTED_MODULE_2___default.a.filters.StereoFilter(data.audio.pan)\r\n                    ];\r\n                }\r\n                if (data.volume) {\r\n                    data.audio.volume = data.volume;\r\n                }\r\n                \r\n                if (data.audio) {\r\n                    data.audio.soundId = sound;\r\n                    this.activeAudioClips.push(data.audio);\r\n\r\n                    if (data.audio.playState === 'playFailed') {\r\n                        // Let's try again - maybe it was a loading issue.\r\n                        wait = function (event) {\r\n                            if (event.id === sound) {\r\n                                data.audio.play(data);\r\n                                pixi_sound__WEBPACK_IMPORTED_MODULE_2___default.a.off('fileload', wait);\r\n                            }\r\n                        };\r\n                        pixi_sound__WEBPACK_IMPORTED_MODULE_2___default.a.on('fileload', wait);\r\n                    }\r\n                }\r\n            };\r\n        },\r\n        stateAudioPlay = function (checkData, audioId, play, state) {\r\n            var active = state.includes(checkData.states);\r\n\r\n            if (active !== checkData.playing) {\r\n                if (active) {\r\n                    play();\r\n                } else {\r\n                    this.stopAudio(audioId, this.forcePlaythrough);\r\n                }\r\n                checkData.playing = active;\r\n            }\r\n        };\r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'AudioSFX',\r\n        \r\n        properties: {\r\n            /**\r\n             * Use the audioMap property object to map messages triggered with audio clips to play. At least one audio mapping should be included for audio to play. Here is an example audioMap object:\r\n             *\r\n             *       {\r\n             *           \"message-triggered\": \"audio-id\",\r\n             *           // This simple form is useful to listen for \"message-triggered\" and play \"audio-id\" using default audio properties.\r\n             *\r\n             *           \"another-message\": {\r\n             *           // To specify audio properties, instead of mapping the message to an audio id string, map it to an object with one or more of the properties shown below. Many of these properties directly correspond to SoundJS play parameters.\r\n             *\r\n             *               \"sound\": \"another-audio-id\",\r\n             *               // Required. This is the audio clip to play when \"another-message\" is triggered.\r\n             *\r\n             *               \"interrupt\": \"none\",\r\n             *               // Optional. Can be \"any\", \"early\", \"late\", or \"none\". Determines how to handle the audio when it's already playing but a new play request is received. Default is \"any\".\r\n             *\r\n             *               \"delay\": 500,\r\n             *               // Optional. Time in milliseconds to wait before playing audio once the message is received. Default is 0.\r\n             *\r\n             *               \"offset\": 1500,\r\n             *               // Optional. Time in milliseconds determining where in the audio clip to begin playback. Default is 0.\r\n             *\r\n             *               \"length\": 2500,\r\n             *               // Optional. Time in milliseconds to play audio before stopping it. If 0 or not specified, play continues to the end of the audio clip.\r\n             *\r\n             *               \"loop\": 4,\r\n             *               // Optional. Determines how many more times to play the audio clip once it finishes. Set to -1 for an infinite loop. Default is 0.\r\n             *\r\n             *               \"volume\": 0.75,\r\n             *               // Optional. Used to specify how loud to play audio on a range from 0 (mute) to 1 (full volume). Default is 1.\r\n             *\r\n             *               \"pan\": -0.25\r\n             *               // Optional. Used to specify the pan of audio on a range of -1 (left) to 1 (right). Default is 0.\r\n             *           }\r\n             *       }\r\n             *\r\n             * @property audioMap\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            audioMap: null,\r\n\r\n            channel: '',\r\n            \r\n            /**\r\n             * Determines whether a sound that's started should play through completely regardless of entity state changes.\r\n             *\r\n             * @property forcePlayThrough\r\n             * @type boolean\r\n             * @default true\r\n             */\r\n            forcePlayThrough: true,\r\n\r\n            /**\r\n             * Optional. Specifies whether this component should listen to events matching the animationMap to animate. Set this to true if the component should animate for on events.\r\n             *\r\n             * @property eventBased\r\n             * @type Boolean\r\n             * @default true\r\n             * @since 0.7.5\r\n             */\r\n            eventBased: true,\r\n\r\n            /**\r\n             * Optional. Specifies whether this component should listen to changes in the entity's state that match the animationMap to animate. Set this to true if the component should animate based on this.owner.state.\r\n             *\r\n             * @property stateBased\r\n             * @type Boolean\r\n             * @default false\r\n             * @since 0.7.5 - Defaults to `true` prior to version 0.9.0\r\n             */\r\n            stateBased: false\r\n        },\r\n            \r\n        initialize: function (definition) {\r\n            var key      = '',\r\n                playClip = null,\r\n                sound    = null;\r\n            \r\n            if (this.channel) {/*\r\n                if (!platypus.game.audioChannels) { // Monkey-patch to add per-channel volume\r\n                    const wasi = createjs.WebAudioSoundInstance;\r\n\r\n                    platypus.game.audioChannels = {};\r\n\r\n                    wasi.prototype._beginPlaying = function (playProps) {\r\n                        if (playProps.channel) {\r\n                            if (!platypus.game.audioChannels[playProps.channel]) {\r\n                                const gain = platypus.game.audioChannels[playProps.channel] = wasi.context.createGain();\r\n                                gain.connect(wasi.destinationNode);\r\n                            }\r\n                            this.destinationNode = platypus.game.audioChannels[playProps.channel];\r\n                        } else {\r\n                            this.destinationNode = wasi.destinationNode;\r\n                        }\r\n                        createjs.AbstractSoundInstance.prototype._beginPlaying.call(this, playProps);\r\n                    };\r\n                    \r\n                    wasi.prototype._handleSoundReady = function () {\r\n                        var dur = this._duration * 0.001,\r\n                            pos = Math.min(Math.max(0, this._position) * 0.001, dur);\r\n\r\n                        this.gainNode.connect(this.destinationNode);  // this line can cause a memory leak.  Nodes need to be disconnected from the audioDestination or any sequence that leads to it.\r\n\r\n                        this.sourceNode = this._createAndPlayAudioNode((wasi.context.currentTime - dur), pos);\r\n                        this._playbackStartTime = this.sourceNode.startTime - pos;\r\n\r\n                        this._soundCompleteTimeout = setTimeout(this._endedHandler, (dur - pos) * 1000);\r\n\r\n                        if (this._loop !== 0) {\r\n                            this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0);\r\n                        }\r\n                    };\r\n                }*/ //TODO: Need to implement channels.\r\n            }\r\n            \r\n            this.activeAudioClips = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n    \r\n            this.state = this.owner.state;\r\n            this.stateChange = false;\r\n            \r\n            this.player = pixi_sound__WEBPACK_IMPORTED_MODULE_2___default.a;\r\n    \r\n            if (this.audioMap) {\r\n                if (this.stateBased) {\r\n                    this.checkStates = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                }\r\n                for (key in this.audioMap) {\r\n                    if (this.audioMap.hasOwnProperty(key)) {\r\n                        sound = this.audioMap[key];\r\n                        playClip = playSound(sound, this.channel);\r\n                        if (sound.sound) {\r\n                            sound = sound.sound;\r\n                        }\r\n                        \r\n                        /**\r\n                         * Listens for messages specified by the `audioMap` and on receiving them, begins playing corresponding audio clips. Audio play message can optionally include several parameters, many of which correspond with SoundJS play parameters.\r\n                         *\r\n                         * @method '*'\r\n                         * @param message.interrupt (string) - Optional. Can be \"any\", \"early\", \"late\", or \"none\". Determines how to handle the audio when it's already playing but a new play request is received. Default is \"any\".\r\n                         * @param message.delay (integer) - Optional. Time in milliseconds to wait before playing audio once the message is received. Default is 0.\r\n                         * @param message.offset (integer) - Optional. Time in milliseconds determining where in the audio clip to begin playback. Default is 0.\r\n                         * @param message.length (integer) - Optional. Time in milliseconds to play audio before stopping it. If 0 or not specified, play continues to the end of the audio clip.\r\n                         * @param message.loop (integer) - Optional. Determines how many more times to play the audio clip once it finishes. Set to -1 for an infinite loop. Default is 0.\r\n                         * @param message.volume (float) - Optional. Used to specify how loud to play audio on a range from 0 (mute) to 1 (full volume). Default is 1.\r\n                         * @param message.pan (float) - Optional. Used to specify the pan of audio on a range of -1 (left) to 1 (right). Default is 0.\r\n                         * @param message.next (string) - Optional. Used to specify the next audio clip to play once this one is complete.\r\n                         */\r\n                        if (this.eventBased) {\r\n                            this.addEventListener(key, playClip);\r\n                        }\r\n                        if (this.stateBased) {\r\n                            this.addStateCheck(key, sound, playClip);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            this.paused          = false;\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * On each `handle-render` message, this component checks its list of playing audio clips and stops any clips whose play length has been reached.\r\n             *\r\n             * @method 'handle-render'\r\n             */\r\n            \"handle-render\": function () {\r\n                var i = 0,\r\n                    cs = null,\r\n                    state = this.state;\r\n                \r\n                if (this.paused) {\r\n                    return;\r\n                }\r\n                \r\n                if (this.stateBased && this.stateChange) {\r\n                    cs = this.checkStates;\r\n                    i = cs.length;\r\n                    while (i--) {\r\n                        cs[i].check(state);\r\n                    }\r\n                    this.stateChange = false;\r\n                }\r\n            },\r\n             \r\n            /**\r\n             * This component listens for changes to the entity state and tests the current state of the entity against the audio map. If a match is found, the matching audio clip is played.\r\n             *\r\n             * @method 'state-changed'\r\n             */\r\n            \"state-changed\": function () {\r\n                this.stateChange = true;\r\n            },\r\n\r\n            /**\r\n             * On receiving this message, the audio will mute if unmuted, and unmute if muted.\r\n             *\r\n             * @method 'toggle-mute'\r\n             * @param audioId {String} If an audioId is provided, that particular sound instance is toggled. Otherwise all audio is toggled from mute to unmute or vice versa.\r\n             */\r\n            \"toggle-mute\": function (audioId) {\r\n                this.handleClip(audioId, function (clip) {\r\n                    if (clip) {\r\n                        if (clip.unmuted) {\r\n                            clip.volume = clip.unmuted;\r\n                            delete clip.unmuted;\r\n                        } else {\r\n                            clip.unmuted = clip.volume;\r\n                            clip.volume = 0;\r\n                        }\r\n                    }\r\n                });\r\n            },\r\n\r\n            /**\r\n             * On receiving this message, audio will stop playing.\r\n             *\r\n             * @method 'stop-audio'\r\n             * @param audioId {String} If an audioId is provided, that particular sound instance is stopped. Otherwise all audio is stopped.\r\n             */\r\n            \"stop-audio\": function (audioId) {\r\n                if (!audioId) {\r\n                    this.stopAudio();\r\n                } else if (typeof audioId === 'string') {\r\n                    this.stopAudio(audioId);\r\n                } else {\r\n                    this.stopAudio(audioId.audioId || false, audioId.playthrough || false);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * On receiving this message all audio will mute, or a particular sound instance will mute if an id is specified.\r\n             *\r\n             * @method 'mute-audio'\r\n             * @param audioId {String} If an audioId is provided, that particular sound instance will mute. Otherwise all audio is muted.\r\n             */\r\n            \"mute-audio\": function (audioId) {\r\n                this.handleClip(audioId, function (clip) {\r\n                    if (clip) {\r\n                        clip.unmuted = clip.volume;\r\n                        clip.volume = 0;\r\n                    }\r\n                });\r\n            },\r\n\r\n            /**\r\n             * On receiving this message all audio will unmute, or a particular sound instance will unmute if an id is specified.\r\n             *\r\n             * @method 'unmute-audio'\r\n             * @param audioId {String} If an audioId is provided, that particular sound instance will unmute. Otherwise all audio is unmuted.\r\n             */\r\n            \"unmute-audio\": function (audioId) {\r\n                this.handleClip(audioId, function (clip) {\r\n                    if (clip) {\r\n                        clip.volume = clip.unmuted;\r\n                        delete clip.unmuted;\r\n                    }\r\n                });\r\n            },\r\n\r\n            /**\r\n             * On receiving this message all audio will pause, or a particular sound instance will pause if an id is specified.\r\n             *\r\n             * @method 'pause-audio'\r\n             * @param audioId {String} If an audioId is provided, that particular sound instance will pause. Otherwise all audio is paused.\r\n             */\r\n            \"pause-audio\": function (audioId) {\r\n                this.handleClip(audioId, function (clip) {\r\n                    if (clip) {\r\n                        clip.pause();\r\n                    }\r\n                });\r\n            },\r\n\r\n            /**\r\n             * On receiving this message all audio will unpause, or a particular sound instance will unpause if an id is specified.\r\n             *\r\n             * @method 'unpause-audio'\r\n             * @param audioId {String} If an audioId is provided, that particular sound instance will unpause. Otherwise all audio is unpaused.\r\n             */\r\n            \"unpause-audio\": function (audioId) {\r\n                this.handleClip(audioId, function (clip) {\r\n                    if (clip) {\r\n                        clip.unpause();\r\n                    }\r\n                });\r\n            },\r\n             \r\n            /**\r\n             * This message sets the volume of playing audio.\r\n             *\r\n             * @method 'set-pan'\r\n             * @param pan {Number} A number from -1 to 1 that sets the pan.\r\n             * @param [soundId] {String} If an soundId is provided, that particular sound instance's pan is set.\r\n             * @since 0.11.3\r\n             */\r\n            \"set-pan\": function (pan, soundId) {\r\n                var id = soundId || '',\r\n                    handler = function (pan, clip) {\r\n                        if (clip) {\r\n                            clip.pan = pan;\r\n                        }\r\n                    };\r\n\r\n                if (soundId) {\r\n                    this.handleClip(id, handler.bind(null, pan));\r\n                } else {\r\n                    this.getAllClips(handler.bind(null, pan));\r\n                }\r\n            },\r\n             \r\n            /**\r\n             * This message sets the volume of playing audio.\r\n             *\r\n             * @method 'set-volume'\r\n             * @param volume {Number} A number from 0 to 1 that sets the volume.\r\n             * @param [soundId] {String} If an soundId is provided, that particular sound instance's volume is set. Otherwise all audio volume is changed.\r\n             */\r\n            \"set-volume\": function (volume, soundId) {\r\n                var id = soundId || '',\r\n                    handler = function (vol, clip) {\r\n                        if (clip) {\r\n                            clip.volume = vol;\r\n                        }\r\n                    };\r\n\r\n                if (soundId) {\r\n                    this.handleClip(id, handler.bind(null, volume));\r\n                } else {\r\n                    this.getAllClips(handler.bind(null, volume));\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            handleClip: function (audioId, handler) {\r\n                if (typeof audioId === 'string') {\r\n                    this.getClipById(audioId, handler);\r\n                } else {\r\n                    this.getAllClips(handler);\r\n                }\r\n            },\r\n            \r\n            getClipById: function (id, onGet) {\r\n                var i     = 0,\r\n                    clips = this.activeAudioClips;\r\n                \r\n                for (i = 0; i < clips.length; i++) {\r\n                    if (clips[i].soundId === id) {\r\n                        if (onGet) {\r\n                            onGet(clips[i]);\r\n                        }\r\n                        return clips[i];\r\n                    }\r\n                }\r\n                \r\n                if (onGet) {\r\n                    onGet(null);\r\n                }\r\n\r\n                return null;\r\n            },\r\n            \r\n            getAllClips: function (onGet) {\r\n                var i     = 0,\r\n                    clips = this.activeAudioClips;\r\n                \r\n                if (onGet) {\r\n                    for (i = 0; i < clips.length; i++) {\r\n                        onGet(clips[i]);\r\n                    }\r\n                }\r\n\r\n                return clips;\r\n            },\r\n            \r\n            stopAudio: (function () {\r\n                var\r\n                    loopFunc = function (instance) {\r\n                        this.stopAudioInstance(instance.currentTarget);\r\n                    };\r\n                \r\n                return function (audioId, playthrough) {\r\n                    var clips = this.activeAudioClips,\r\n                        func = loopFunc.bind(this),\r\n                        i = clips.length;\r\n                    \r\n                    if (audioId) {\r\n                        while (i--) {\r\n                            if (clips[i].soundId === audioId) {\r\n                                if (clips[i].playthrough || playthrough) {\r\n                                    clips[i].addEventListener('loop', func);\r\n                                } else {\r\n                                    clips[i].stop();\r\n                                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(clips, i);\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        while (i--) {\r\n                            if (playthrough || clips[i].playthrough) {\r\n                                clips[i].addEventListener('loop', func);\r\n                            } else {\r\n                                clips[i].stop();\r\n                            }\r\n                        }\r\n                        clips.length = 0;\r\n                    }\r\n                };\r\n            }()),\r\n            \r\n            stopAudioInstance: function (instance) {\r\n                var clips = this.activeAudioClips,\r\n                    i     = clips ? clips.indexOf(instance) : -1;\r\n                \r\n                if (i >= 0) {\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(clips, i);\r\n                }\r\n                instance.stop();\r\n            },\r\n            \r\n            removeClip: function (audioClip) {\r\n                var i = this.activeAudioClips.indexOf(audioClip);\r\n\r\n                if (i >= 0) {\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.activeAudioClips, i);\r\n                }\r\n            },\r\n            \r\n            addStateCheck: function (key, value, play) {\r\n                var states = _StateMap_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setUp(key),\r\n                    checkData = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\r\n                        \"states\", states,\r\n                        \"playing\", false\r\n                    );\r\n                \r\n                checkData.check = stateAudioPlay.bind(this, checkData, value, play.bind(this));\r\n                this.checkStates.push(checkData);\r\n            },\r\n            \r\n            destroy: function () {\r\n                var c = this.checkStates,\r\n                    ci = null,\r\n                    i = 0;\r\n                \r\n                this.stopAudio();\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.activeAudioClips);\r\n                this.activeAudioClips = null;\r\n                \r\n                this.state = null;\r\n\r\n                if (c) {\r\n                    i = c.length;\r\n                    while (i--) {\r\n                        ci = c[i];\r\n                        ci.states.recycle();\r\n                        ci.recycle();\r\n                    }\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(c);\r\n                    this.checkStates = null;\r\n                }\r\n            }\r\n        },\r\n        \r\n        getAssetList: function (component, props, defaultProps) {\r\n            var key = '',\r\n                preload = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                audioMap = component.audioMap || props.audioMap || defaultProps.audioMap;\r\n            \r\n            for (key in audioMap) {\r\n                if (audioMap.hasOwnProperty(key)) {\r\n                    const item = (audioMap[key].sound || audioMap[key]) + '.{ogg,mp3}';\r\n                    if (preload.indexOf(item) === -1) {\r\n                        preload.push(item);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return preload;\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/AudioSFX.js?");

/***/ }),

/***/ "./src/components/AudioVO.js":
/*!***********************************!*\
  !*** ./src/components/AudioVO.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n * This component plays audio using the SpringRoll VOPlayer instance. Audio is played by triggering specific messages defined in the audio component definition.\r\n *\r\n * @namespace platypus.components\r\n * @class AudioVO\r\n * @uses platypus.Component\r\n * @since 0.6.0\r\n */\r\n/*global platypus */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var sortByTime = function (a, b) {\r\n            return a.time - b.time;\r\n        },\r\n        addEvents = function (fromList, toList) {\r\n            var i = 0;\r\n            \r\n            for (i = 0; i < fromList.length; i++) {\r\n                toList.push(_Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(\r\n                    'event', fromList[i].event,\r\n                    'time', fromList[i].time || 0,\r\n                    'message', fromList[i].message\r\n                ));\r\n            }\r\n            \r\n            if (i) {\r\n                toList.sort(sortByTime);\r\n            }\r\n            \r\n            return toList;\r\n        },\r\n        offsetEvents = function (fromList, toList, player) {\r\n            var i = 0,\r\n                offset = player.getElapsed();\r\n            \r\n            for (i = 0; i < fromList.length; i++) {\r\n                toList.push(_Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(\r\n                    'event', fromList[i].event,\r\n                    'time', (fromList[i].time || 0) + offset,\r\n                    'message', fromList[i].message || null\r\n                ));\r\n            }\r\n            \r\n            if (i) {\r\n                toList.sort(sortByTime);\r\n            }\r\n        },\r\n        setupEventList = function (sounds, eventList, player) { // This function merges events from individual sounds into a full list queued to sync with the SpringRoll voPlayer.\r\n            var i = 0,\r\n                soundList = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n            \r\n            // Create alias-only sound list.\r\n            for (i = 0; i < sounds.length; i++) {\r\n                if (sounds[i].sound) {\r\n                    if (sounds[i].events) {\r\n                        soundList.push(offsetEvents.bind(this, sounds[i].events, eventList, player));\r\n                    }\r\n                    soundList.push(sounds[i].sound);\r\n                } else {\r\n                    soundList.push(sounds[i]);\r\n                }\r\n            }\r\n            return soundList;\r\n        },\r\n        onComplete = function (complete, soundList) {\r\n            this.playingAudio = false;\r\n            this.player.unloadSound();\r\n            if (!this.owner.destroyed) {\r\n                this.checkTimeEvents(true);\r\n                \r\n                /**\r\n                 * When an audio sequence is finished playing, this event is triggered.\r\n                 *\r\n                 * @event sequence-complete\r\n                 */\r\n                this.owner.triggerEvent('sequence-complete');\r\n            }\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(soundList);\r\n        },\r\n        playSound = function (soundDefinition, value) {\r\n            var soundList = null,\r\n                eventList = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\r\n                player = this.player;\r\n\r\n            if (typeof soundDefinition === 'string') {\r\n                soundList = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(soundDefinition);\r\n            } else if (Array.isArray(soundDefinition)) {\r\n                soundList = setupEventList(soundDefinition, eventList, player);\r\n            } else {\r\n                if (soundDefinition.events) {\r\n                    addEvents(soundDefinition.events, eventList);\r\n                }\r\n                if (Array.isArray(soundDefinition.sound)) {\r\n                    soundList = setupEventList(soundDefinition.sound, eventList, player);\r\n                } else {\r\n                    soundList = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(soundDefinition.sound);\r\n                }\r\n            }\r\n            \r\n            if (value && value.events) {\r\n                addEvents(value.events, eventList);\r\n            }\r\n\r\n            player.play(soundList, onComplete.bind(this, true, soundList), onComplete.bind(this, false, soundList));\r\n\r\n            // Removing `this.eventList` after play call since playing a VO clip could be stopping a currently playing clip with events in progress.\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.eventList);\r\n            this.eventList = eventList;\r\n            this.playingAudio = true;\r\n        };\r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'AudioVO',\r\n        \r\n        properties: {\r\n            /**\r\n             * Use the audioMap property object to map messages triggered with audio clips to play. At least one audio mapping should be included for audio to play. Here is an example audioMap object:\r\n             *\r\n             *       {\r\n             *           \"message-triggered\": \"audio-id\",\r\n             *           // This simple form is useful to listen for \"message-triggered\" and play \"audio-id\" using default audio properties.\r\n             *\r\n             *           \"another-message\": {\r\n             *           // To specify audio properties, instead of mapping the message to an audio id string, map it to an object with one or more of the properties shown below. Many of these properties directly correspond to SoundJS play parameters.\r\n             *\r\n             *               \"sound\": \"another-audio-id\",\r\n             *               // Required. This is the audio clip to play when \"another-message\" is triggered.\r\n             *\r\n             *               \"events\": [{\r\n             *                   \"event\": \"walk-to-the-left\",\r\n             *                   \"time\": 1500\r\n             *               }]\r\n             *               // Optional. Used to specify a list of events to play once the VO begins.\r\n             *           }\r\n             *       }\r\n             *\r\n             * @property audioMap\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            audioMap: null\r\n        },\r\n            \r\n        initialize: function () {\r\n            var key = '';\r\n            \r\n            this.eventList = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n    \r\n            this.playingAudio = false;\r\n            this.player = platypus.game.app.voPlayer;\r\n            this.player.trackSound = platypus.supports.iOS;\r\n    \r\n            if (this.audioMap) {\r\n                for (key in this.audioMap) {\r\n                    if (this.audioMap.hasOwnProperty(key)) {\r\n\r\n                        /**\r\n                         * Listens for messages specified by the `audioMap` and on receiving them, begins playing corresponding audio clips.\r\n                         *\r\n                         * @method '*'\r\n                         * @param [message.events] {Array} Used to specify the list of events to trigger while playing this audio sequence.\r\n                         */\r\n                        this.addEventListener(key, playSound.bind(this, this.audioMap[key]));\r\n                    }\r\n                }\r\n            }\r\n            \r\n            this.paused = false;\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * On each `handle-render` message, this component checks its list of playing audio clips and stops any clips whose play length has been reached.\r\n             *\r\n             * @method 'handle-render'\r\n             */\r\n            \"handle-render\": function () {\r\n                if (!this.paused) {\r\n                    this.checkTimeEvents(false);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * On receiving this message, audio will stop playing.\r\n             *\r\n             * @method 'stop-audio'\r\n             */\r\n            \"stop-audio\": function () {\r\n                this.player.stop();\r\n                this.player.voList = []; // Workaround to prevent a Springroll bug wherein stopping throws an error due to `voList` being `null`.\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            checkTimeEvents: function (finished) {\r\n                var event = null,\r\n                    events = this.eventList,\r\n                    currentTime = 0,\r\n                    owner = this.owner;\r\n                \r\n                if (events && events.length) {\r\n                    currentTime = this.player.getElapsed();\r\n\r\n                    while (events.length && (finished || (events[0].time <= currentTime))) {\r\n                        event = events.shift();\r\n                        owner.trigger(event.event, event.message);\r\n                        event.recycle();\r\n                    }\r\n                }\r\n            },\r\n\r\n            destroy: function () {\r\n                if (this.playingAudio) {\r\n                    this.player.stop();\r\n                    this.player.voList = []; // Workaround to prevent a Springroll bug wherein stopping throws an error due to `voList` being `null`.\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.eventList);\r\n                this.eventList = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/AudioVO.js?");

/***/ }),

/***/ "./src/components/Camera.js":
/*!**********************************!*\
  !*** ./src/components/Camera.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tweenjs/tween.js */ \"@tweenjs/tween.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/**\r\n * This component controls the game camera deciding where and how it should move. The camera also broadcasts messages when the window resizes or its orientation changes.\r\n *\r\n * @namespace platypus.components\r\n * @class Camera\r\n * @uses platypus.Component\r\n*/\r\n/*global platypus, window */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var DPR = window.devicePixelRatio || 1,\r\n        anchorBound = function (anchorAABB, entityOffsetX, entityOffsetY, entity) {\r\n            var aabb = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(entity.x + entityOffsetX, entity.y + entityOffsetY, entity.width, entity.height),\r\n                x = anchorAABB.x,\r\n                y = anchorAABB.y;\r\n\r\n            if (aabb.top < anchorAABB.top) {\r\n                y -= (anchorAABB.top - aabb.top);\r\n            } else if (aabb.bottom > anchorAABB.bottom) {\r\n                y += (anchorAABB.bottom - aabb.bottom);\r\n            }\r\n            \r\n            if (aabb.left < anchorAABB.left) {\r\n                x -= (anchorAABB.left - aabb.left);\r\n            } else if (aabb.right > anchorAABB.right) {\r\n                x += (anchorAABB.right - aabb.right);\r\n            }\r\n            \r\n            aabb.recycle();\r\n            \r\n            return this.move(x, y, 0);\r\n        },\r\n        doNothing = function () {\r\n            return false;\r\n        },\r\n\r\n        // These fix coords for touch events filling in for pointer events from the PIXI InteractiveManager\r\n        getClientX = function (event) {\r\n            if (!event.clientX) {\r\n                if (event.touches && event.touches[0] && event.touches[0].clientX) {\r\n                    return event.touches[0].clientX;\r\n                }\r\n                return 0;\r\n            }\r\n            return event.clientX;\r\n        },\r\n        getClientY = function (event) {\r\n            if (!event.clientY) {\r\n                if (event.touches && event.touches[0] && event.touches[0].clientY) {\r\n                    return event.touches[0].clientY;\r\n                }\r\n                return 0;\r\n            }\r\n            return event.clientY;\r\n        };\r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'Camera',\r\n        properties: {\r\n            /**\r\n             * Number specifying width of viewport in world coordinates.\r\n             *\r\n             * @property width\r\n             * @type number\r\n             * @default 0\r\n             **/\r\n            \"width\": 0,\r\n             \r\n            /**\r\n             * Number specifying height of viewport in world coordinates.\r\n             *\r\n             * @property height\r\n             * @type number\r\n             * @default 0\r\n             **/\r\n            \"height\": 0,\r\n            \r\n            /**\r\n             * Specifies whether the camera should be draggable via the mouse by setting to 'pan'.\r\n             *\r\n             * @property mode\r\n             * @type String\r\n             * @default 'static'\r\n             * @since 0.9.0\r\n             **/\r\n            \"mode\": \"static\",\r\n            \r\n            /**\r\n             * Whether camera overflows to cover the whole canvas or remains contained within its aspect ratio's boundary.\r\n             *\r\n             * @property overflow\r\n             * @type boolean\r\n             * @default false\r\n             */\r\n            \"overflow\": false,\r\n            \r\n            /**\r\n             * Boolean value that determines whether the camera should stretch the world viewport when window is resized. Defaults to false which maintains the proper aspect ratio.\r\n             *\r\n             * @property stretch\r\n             * @type boolean\r\n             * @default: false\r\n             */\r\n            \"stretch\": false,\r\n            \r\n            /**\r\n             * Sets how many units the followed entity can move before the camera will re-center. This should be lowered for small-value coordinate systems such as Box2D.\r\n             *\r\n             * @property threshold\r\n             * @type number\r\n             * @default 1\r\n             **/\r\n            \"threshold\": 1,\r\n            \r\n            /**\r\n             * Whether, when following an entity, the camera should rotate to match the entity's orientation.\r\n             *\r\n             * @property rotate\r\n             * @type boolean\r\n             * @default false\r\n             **/\r\n            \"rotate\": false,\r\n\r\n            /**\r\n             * Number specifying the horizontal center of viewport in world coordinates.\r\n             *\r\n             * @property x\r\n             * @type number\r\n             * @default 0\r\n             **/\r\n            \"x\": 0,\r\n             \r\n            /**\r\n             * Number specifying the vertical center of viewport in world coordinates.\r\n             *\r\n             * @property y\r\n             * @type number\r\n             * @default 0\r\n             **/\r\n            \"y\": 0\r\n        },\r\n        publicProperties: {\r\n            /**\r\n             * The entity's canvas element is used to determine the window size of the camera.\r\n             *\r\n             * @property canvas\r\n             * @type DOMElement Canvas\r\n             * @default null\r\n             */\r\n            \"canvas\": null,\r\n            \r\n            /**\r\n             * Sets how quickly the camera should pan to a new position in the horizontal direction.\r\n             *\r\n             * @property transitionX\r\n             * @type number\r\n             * @default 400\r\n             **/\r\n            \"transitionX\": 400,\r\n            \r\n            /**\r\n             * Sets how quickly the camera should pan to a new position in the vertical direction.\r\n             *\r\n             * @property transitionY\r\n             * @type number\r\n             * @default 600\r\n             **/\r\n            \"transitionY\": 600,\r\n             \r\n            /**\r\n             * Sets how quickly the camera should rotate to a new orientation.\r\n             *\r\n             * @property transitionAngle\r\n             * @type number\r\n             * @default: 600\r\n             **/\r\n            \"transitionAngle\": 600\r\n        },\r\n        initialize: function (definition) {\r\n            var worldVP = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.x, this.y, this.width, this.height),\r\n                worldCamera = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                    \"viewport\", worldVP,\r\n                    \"orientation\", definition.orientation || 0\r\n                );\r\n\r\n            //The dimensions of the camera in the window\r\n            this.viewport = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(0, 0, 0, 0);\r\n            \r\n            //The dimensions of the camera in the game world\r\n            this.worldCamera = worldCamera;\r\n\r\n            //Message object defined here so it's reusable\r\n            this.worldDimensions = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\r\n            this.message = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                \"viewport\", _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(),\r\n                \"scaleX\", 0,\r\n                \"scaleY\", 0,\r\n                \"orientation\", 0,\r\n                \"stationary\", false,\r\n                \"world\", this.worldDimensions\r\n            );\r\n            this.cameraLoadedMessage = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                \"viewport\", this.message.viewport,\r\n                \"world\", this.worldDimensions\r\n            );\r\n    \r\n            //Whether the map has finished loading.\r\n            this.worldIsLoaded = false;\r\n            \r\n            this.following = null;\r\n            this.state = 'static';//'roaming';\r\n            if (this.mode === 'pan') {\r\n                this.state = 'mouse-pan';\r\n            }\r\n            \r\n            //FOLLOW MODE VARIABLES\r\n            \r\n            //--Bounding\r\n            this.boundingBox = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(worldVP.x, worldVP.y, worldVP.width / 2, worldVP.height / 2);\r\n            \r\n            //Forward Follow\r\n            this.lastX = worldVP.x;\r\n            this.lastY = worldVP.y;\r\n            this.lastOrientation = worldCamera.orientation;\r\n            this.forwardX = 0;\r\n            this.forwardY = 0;\r\n            this.forwardAngle = 0;\r\n            this.averageOffsetX = 0;\r\n            this.averageOffsetY = 0;\r\n            this.averageOffsetAngle = 0;\r\n            this.offsetX = 0;\r\n            this.offsetY = 0;\r\n            this.offsetAngle = 0;\r\n            this.forwardFollower = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                \"x\", this.lastX,\r\n                \"y\", this.lastY,\r\n                \"orientation\", this.lastOrientation\r\n            );\r\n            \r\n            this.lastFollow = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                \"entity\", null,\r\n                \"mode\", null,\r\n                \"offsetX\", 0,\r\n                \"offsetY\", 0,\r\n                \"begin\", 0\r\n            );\r\n            \r\n            this.xMagnitude = 0;\r\n            this.yMagnitude = 0;\r\n            this.xWaveLength = 0;\r\n            this.yWaveLength = 0;\r\n            this.xShakeTime = 0;\r\n            this.yShakeTime = 0;\r\n            this.shakeTime = 0;\r\n            this.shakeIncrementor = 0;\r\n            \r\n            this.direction = true;\r\n            this.stationary = false;\r\n            \r\n            this.viewportUpdate = false;\r\n            \r\n            if (this.owner.container) {\r\n                this.parentContainer = this.owner.container;\r\n            } else if (this.owner.stage) {\r\n                this.canvas = this.canvas || platypus.game.canvas; //TODO: Probably need to find a better way to handle resizing - DDD 10/4/2015\r\n                this.parentContainer = this.owner.stage;\r\n                this.owner.width  = this.canvas.width;\r\n                this.owner.height = this.canvas.height;\r\n            } else {\r\n                platypus.debug.warn('Camera: There appears to be no Container on this entity for the camera to display.');\r\n            }\r\n            this.container = new pixi_js__WEBPACK_IMPORTED_MODULE_1__[\"Container\"]();\r\n            this.container.visible = false;\r\n            this.parentContainer.addChild(this.container);\r\n            this.movedCamera = false;\r\n        },\r\n        events: {\r\n            /**\r\n             * Sets up the camera window size on load.\r\n             *\r\n             * @method 'load'\r\n             */\r\n            \"load\": function () {\r\n                this.resize();\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the camera begins viewing the world.\r\n             *\r\n             * @method 'render-world'\r\n             * @param data {Object} Information about the world.\r\n             * @param data.world {PIXI.Container} The container containing world entities.\r\n             */\r\n            \"render-world\": function (data) {\r\n                this.world = data.world;\r\n                this.container.addChild(this.world);\r\n            },\r\n            \r\n            /**\r\n             * The viewport is flagged to update when children are added.\r\n             *\r\n             * @method 'child-entity-added'\r\n             * @param entity {platypus.Entity} Expects an entity as the message object.\r\n              **/\r\n            \"child-entity-added\": function (entity) {\r\n                this.viewportUpdate = true;\r\n                \r\n                if (this.worldIsLoaded) {\r\n                    /**\r\n                     * On receiving a \"world-loaded\" message, the camera broadcasts the world size to all children in the world.\r\n                     *\r\n                     * @event 'camera-loaded'\r\n                     * @param message\r\n                     * @param message.world {platypus.AABB} The dimensions of the world map.\r\n                     **/\r\n                    entity.triggerEvent('camera-loaded', this.cameraLoadedMessage);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Triggers \"camera-update\" on newly changed entities.\r\n             *\r\n             * @method 'child-entity-updated'\r\n             * @param entity {platypus.Entity} Expects an entity as the message object to determine whether to trigger `camera-update` on it.\r\n             * @since 0.6.8\r\n             **/\r\n            \"child-entity-updated\": function (entity) {\r\n                this.viewportUpdate = true;\r\n                \r\n                if (this.worldIsLoaded) {\r\n                    entity.triggerEvent('camera-update', this.message);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * On receiving this message, the camera updates its world location and size as necessary. An example of this message is triggered by the [TiledLoader](platypus.components.TiledLoader.html) component.\r\n             *\r\n             * @method 'world-loaded'\r\n             * @param message {Object}\r\n             * @param [message.width] {number} The width of the loaded world.\r\n             * @param [message.height] {number} The height of the loaded world.\r\n             * @param [message.camera] {platypus.Entity} An entity that the camera should follow in the loaded world.\r\n             **/\r\n            \"world-loaded\": function (values) {\r\n                var msg = this.message;\r\n                \r\n                msg.viewport.set(this.worldCamera.viewport);\r\n                this.worldDimensions.set(values.world);\r\n                \r\n                this.worldIsLoaded = true;\r\n                if (values.camera) {\r\n                    this.follow(values.camera);\r\n                }\r\n                if (this.owner.triggerEventOnChildren) {\r\n                    this.owner.triggerEventOnChildren('camera-loaded', this.cameraLoadedMessage);\r\n                }\r\n                this.updateMovementMethods();\r\n            },\r\n            \r\n            /**\r\n             * If mouse dragging should cause the camera to move, this listens for the beginning of the drag motion.\r\n             *\r\n             * @method 'pointerdown'\r\n             * @param event {Object} The pointer event.\r\n             * @since 0.9.0\r\n             **/\r\n            \"pointerdown\": function (event) {\r\n                var worldVP = this.worldCamera.viewport;\r\n\r\n                if (this.state === 'mouse-pan') {\r\n                    if (!this.mouseVector) {\r\n                        this.mouseVector = _Vector_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\r\n                        this.mouseWorldOrigin = _Vector_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\r\n                    }\r\n                    this.mouse = this.mouseVector;\r\n                    this.mouse.x = getClientX(event.event);\r\n                    this.mouse.y = getClientY(event.event);\r\n                    this.mouseWorldOrigin.x = worldVP.x;\r\n                    this.mouseWorldOrigin.y = worldVP.y;\r\n                    event.pixiEvent.stopPropagation();\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * If mouse dragging should cause the camera to move, this listens the drag motion.\r\n             *\r\n             * @method 'pressmove'\r\n             * @param event {Object} The pointer event.\r\n             * @since 0.9.0\r\n             **/\r\n            \"pressmove\": function (event) {\r\n                if (this.mouse) {\r\n                    if (this.move(this.mouseWorldOrigin.x + ((this.mouse.x - getClientX(event.event)) * DPR) / this.world.transform.worldTransform.a, this.mouseWorldOrigin.y + ((this.mouse.y - getClientY(event.event)) * DPR) / this.world.transform.worldTransform.d)) {\r\n                        this.viewportUpdate = true;\r\n                        this.movedCamera = true;\r\n                        event.pixiEvent.stopPropagation();\r\n                    }\r\n                }\r\n            },\r\n\r\n            /**\r\n             * If mouse dragging should cause the camera to move, this listens for the end of the drag motion.\r\n             *\r\n             * @method 'pressup'\r\n             * @param event {Object} The pointer event.\r\n             * @since 0.9.0\r\n             **/\r\n            \"pressup\": function (event) {\r\n                if (this.mouse) {\r\n                    this.mouse = null;\r\n                    if (this.movedCamera) {\r\n                        this.movedCamera = false;\r\n                        event.pixiEvent.stopPropagation();\r\n                    }\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * On a \"tick\" step event, the camera updates its location according to its current state.\r\n             *\r\n             * @method 'tick'\r\n             * @param message {Object}\r\n             * @param message.delta {Number} If necessary, the current camera update function may require the length of the tick to adjust movement rate.\r\n             **/\r\n            \"tick\": function (resp) {\r\n                var msg       = this.message,\r\n                    viewport  = msg.viewport,\r\n                    worldCamera = this.worldCamera;\r\n                \r\n                if ((this.state === 'following') && this.followingFunction(this.following, resp.delta)) {\r\n                    this.viewportUpdate = true;\r\n                }\r\n                \r\n                // Need to update owner's size information for changes to canvas size\r\n                if (this.canvas) {\r\n                    this.owner.width  = this.canvas.width;\r\n                    this.owner.height = this.canvas.height;\r\n                }\r\n                \r\n                // Check for owner resizing\r\n                if ((this.owner.width !== this.lastWidth) || (this.owner.height !== this.lastHeight)) {\r\n                    this.resize();\r\n                    this.lastWidth = this.owner.width;\r\n                    this.lastHeight = this.owner.height;\r\n                }\r\n                \r\n                if (this.viewportUpdate) {\r\n                    this.viewportUpdate = false;\r\n                    this.stationary = false;\r\n                    msg.stationary = false;\r\n                    \r\n                    viewport.set(worldCamera.viewport);\r\n\r\n                    if (this.shakeIncrementor < this.shakeTime) {\r\n                        this.viewportUpdate = true;\r\n                        this.shakeIncrementor += resp.delta;\r\n                        this.shakeIncrementor = Math.min(this.shakeIncrementor, this.shakeTime);\r\n                        \r\n                        if (this.shakeIncrementor < this.xShakeTime) {\r\n                            viewport.moveX(viewport.x + Math.sin((this.shakeIncrementor / this.xWaveLength) * (Math.PI * 2)) * this.xMagnitude);\r\n                        }\r\n                        \r\n                        if (this.shakeIncrementor < this.yShakeTime) {\r\n                            viewport.moveY(viewport.y + Math.sin((this.shakeIncrementor / this.yWaveLength) * (Math.PI * 2)) * this.yMagnitude);\r\n                        }\r\n                    }\r\n\r\n                    // Set up the rest of the camera message:\r\n                    msg.scaleX         = this.windowPerWorldUnitWidth;\r\n                    msg.scaleY         = this.windowPerWorldUnitHeight;\r\n                    msg.orientation    = worldCamera.orientation;\r\n                    \r\n                    // Transform the world to appear within camera\r\n                    this.world.setTransform(-viewport.x, -viewport.y, 1, 1, 0);\r\n                    this.container.setTransform(viewport.halfWidth * msg.scaleX, viewport.halfHeight * msg.scaleY, msg.scaleX, msg.scaleY, msg.orientation);\r\n                    this.container.visible = true;\r\n\r\n                    /**\r\n                     * This component fires \"camera-update\" when the position of the camera in the world has changed. This event is triggered on both the entity (typically a layer) as well as children of the entity.\r\n                     *\r\n                     * @event 'camera-update'\r\n                     * @param message {Object}\r\n                     * @param message.world {platypus.AABB} The dimensions of the world map.\r\n                     * @param message.orientation {Number} Number describing the orientation of the camera.\r\n                     * @param message.scaleX {Number} Number of window pixels that comprise a single world coordinate on the x-axis.\r\n                     * @param message.scaleY {Number} Number of window pixels that comprise a single world coordinate on the y-axis.\r\n                     * @param message.viewport {platypus.AABB} An AABB describing the world viewport area.\r\n                     * @param message.stationary {Boolean} Whether the camera is moving.\r\n                     **/\r\n                    this.owner.triggerEvent('camera-update', msg);\r\n                    if (this.owner.triggerEventOnChildren) {\r\n                        this.owner.triggerEventOnChildren('camera-update', msg);\r\n                    }\r\n                } else if (!this.stationary) {\r\n                    this.stationary = true;\r\n                    msg.stationary = true;\r\n\r\n                    this.owner.triggerEvent('camera-update', msg);\r\n                    if (this.owner.triggerEventOnChildren) {\r\n                        this.owner.triggerEventOnChildren('camera-update', msg);\r\n                    }\r\n                }\r\n                \r\n                if (this.lastFollow.begin) {\r\n                    if (this.lastFollow.begin < Date.now()) {\r\n                        this.follow(this.lastFollow);\r\n                    }\r\n                }\r\n            },\r\n            \r\n            /**\r\n            * The camera listens for this event to change its world viewport size.\r\n            *\r\n            * @method 'resize-camera'\r\n            * @param dimensions {Object} List of key/value pairs describing new viewport size\r\n            * @param dimensions.width {number} Width of the camera viewport\r\n            * @param dimensions.height {number} Height of the camera viewport\r\n            **/\r\n            \"resize-camera\": function (dimensions) {\r\n                this.width = dimensions.width;\r\n                this.height = dimensions.height;\r\n                this.resize();\r\n            },\r\n            \r\n            /**\r\n             * The camera listens for this event to change its position in the world.\r\n             *\r\n             * @method 'relocate'\r\n             * @param location {Vector|Object} List of key/value pairs describing new location\r\n             * @param location.x {Number} New position along the x-axis.\r\n             * @param location.y {Number} New position along the y-axis.\r\n             * @param [location.time] {Number} The time to transition to the new location.\r\n             * @param [location.ease] {Function} The ease function to use. Defaults to a linear transition.\r\n             */\r\n            \"relocate\": (function () {\r\n                var move = function (v) {\r\n                        if (this.move(v.x, v.y)) {\r\n                            this.viewportUpdate = true;\r\n                        }\r\n                    },\r\n                    stop = function () {\r\n                        this.recycle();\r\n                    };\r\n\r\n                return function (location) {\r\n                    var v = null,\r\n                        worldVP = this.worldCamera.viewport;\r\n\r\n                    if (location.time) {\r\n                        v = _Vector_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(worldVP.x, worldVP.y);\r\n                        new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_3__[\"TweenJS\"].Tween(v).to({x: location.x, y: location.y}, location.time).easing(location.ease).onUpdate(move.bind(this, v)).onStop(stop.bind(v)).start();\r\n                    } else if (this.move(location.x, location.y)) {\r\n                        this.viewportUpdate = true;\r\n                    }\r\n                };\r\n            }()),\r\n            \r\n            /**\r\n            * On receiving this message, the camera begins following the requested object.\r\n            *\r\n            * @method 'follow'\r\n            * @param message {Object}\r\n            * @param message.mode {String} Can be \"locked\", \"forward\", \"bounding\", \"anchor-bound\", or \"static\". \"static\" suspends following, but the other three settings require that the entity parameter be defined. Also set the bounding area parameters if sending \"bounding\" as the following method and the movement parameters if sending \"forward\" as the following method.\r\n            * @param [message.entity] {platypus.Entity} The entity that the camera should commence following.\r\n            * @param [message.top] {number} The top of a bounding box following an entity.\r\n            * @param [message.left] {number} The left of a bounding box following an entity.\r\n            * @param [message.width] {number} The width of a bounding box following an entity.\r\n            * @param [message.height] {number} The height of a bounding box following an entity.\r\n            * @param [message.movementX] {number} Movement multiplier for focusing the camera ahead of a moving entity in the horizontal direction.\r\n            * @param [message.movementY] {number} Movement multiplier for focusing the camera ahead of a moving entity in the vertical direction.\r\n            * @param [message.offsetX] {number} How far to offset the camera from the entity horizontally.\r\n            * @param [message.offsetY] {number} How far to offset the camera from the entity vertically.\r\n            * @param [message.time] {number} How many milliseconds to follow the entity.\r\n            **/\r\n            \"follow\": function (def) {\r\n                this.follow(def);\r\n            },\r\n            \r\n            /**\r\n            * On receiving this message, the camera will shake around its target location.\r\n            *\r\n            * @method 'shake'\r\n            * @param shake {Object}\r\n            * @param [shake.xMagnitude] {number} How much to move along the x axis.\r\n            * @param [shake.yMagnitude] {number} How much to move along the y axis.\r\n            * @param [shake.xFrequency] {number} How quickly to shake along the x axis.\r\n            * @param [shake.yFrequency] {number} How quickly to shake along the y axis.\r\n            * @param [shake.time] {number} How long the camera should shake.\r\n            **/\r\n            \"shake\": function (shakeDef) {\r\n                var def = shakeDef || {},\r\n                    xMag    = def.xMagnitude || 0,\r\n                    yMag    = def.yMagnitude || 0,\r\n                    xFreq   = def.xFrequency || 0, //Cycles per second\r\n                    yFreq   = def.yFrequency || 0, //Cycles per second\r\n                    second  = 1000,\r\n                    time    = def.time || 0;\r\n                \r\n                this.viewportUpdate = true;\r\n                \r\n                this.shakeIncrementor = 0;\r\n                \r\n                this.xMagnitude = xMag;\r\n                this.yMagnitude = yMag;\r\n                \r\n                if (xFreq === 0) {\r\n                    this.xWaveLength = 1;\r\n                    this.xShakeTime = 0;\r\n                } else {\r\n                    this.xWaveLength = (second / xFreq);\r\n                    this.xShakeTime = Math.ceil(time / this.xWaveLength) * this.xWaveLength;\r\n                }\r\n                \r\n                if (yFreq === 0) {\r\n                    this.yWaveLength = 1;\r\n                    this.yShakeTime = 0;\r\n                } else {\r\n                    this.yWaveLength = (second / yFreq);\r\n                    this.yShakeTime = Math.ceil(time / this.yWaveLength) * this.yWaveLength;\r\n                }\r\n                \r\n                this.shakeTime = Math.max(this.xShakeTime, this.yShakeTime);\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            follow: function (def) {\r\n                var portion = 0.1;\r\n                \r\n                if (def.time) { //save current follow\r\n                    if (!this.lastFollow.begin) {\r\n                        this.lastFollow.entity = this.following;\r\n                        this.lastFollow.mode   = this.mode;\r\n                        this.lastFollow.offsetX = this.offsetX;\r\n                        this.lastFollow.offsetY = this.offsetY;\r\n                    }\r\n                    this.lastFollow.begin  = Date.now() + def.time;\r\n                } else if (this.lastFollow.begin) {\r\n                    this.lastFollow.begin = 0;\r\n                }\r\n                \r\n                this.mode = def.mode;\r\n                \r\n                switch (def.mode) {\r\n                case 'locked':\r\n                    this.state = 'following';\r\n                    this.following = def.entity;\r\n                    this.followingFunction = this.lockedFollow;\r\n                    this.offsetX = def.offsetX || 0;\r\n                    this.offsetY = def.offsetY || 0;\r\n                    this.offsetAngle = def.offsetAngle || 0;\r\n                    break;\r\n                case 'forward':\r\n                    this.state = 'following';\r\n                    this.followFocused   = false;\r\n                    this.following       = def.entity;\r\n                    this.lastX           = def.entity.x - def.offsetX || 0;\r\n                    this.lastY           = def.entity.y - def.offsetY || 0;\r\n                    this.lastOrientation = def.entity.orientation || 0;\r\n                    this.forwardX  = def.movementX || (this.transitionX * portion);\r\n                    this.forwardY  = def.movementY || (this.transitionY * portion);\r\n                    this.averageOffsetX = 0;\r\n                    this.averageOffsetY = 0;\r\n                    this.averageOffsetAngle = 0;\r\n                    this.offsetX = def.offsetX || 0;\r\n                    this.offsetY = def.offsetY || 0;\r\n                    this.offsetAngle = def.offsetAngle || 0;\r\n                    this.followingFunction = this.forwardFollow;\r\n                    break;\r\n                case 'bounding':\r\n                    this.state = 'following';\r\n                    this.following = def.entity;\r\n                    this.offsetX = def.offsetX || 0;\r\n                    this.offsetY = def.offsetY || 0;\r\n                    this.offsetAngle = def.offsetAngle || 0;\r\n                    this.boundingBox.setAll(def.x, def.y, def.width, def.height);\r\n                    this.followingFunction = this.boundingFollow;\r\n                    break;\r\n                case 'anchor-bound':\r\n                    this.state = 'following';\r\n                    this.following = def.entity;\r\n                    this.followingFunction = anchorBound.bind(this, def.anchorAABB, def.offsetX || 0, def.offsetY || 0);\r\n                    break;\r\n                case 'pan':\r\n                    this.state = 'mouse-pan';\r\n                    this.following = null;\r\n                    this.followingFunction = null;\r\n                    if (def && (typeof def.x === 'number') && (typeof def.y === 'number')) {\r\n                        this.move(def.x, def.y, def.orientation || 0);\r\n                        this.viewportUpdate = true;\r\n                    }\r\n                    break;\r\n                default:\r\n                    this.state = 'static';\r\n                    this.following = null;\r\n                    this.followingFunction = null;\r\n                    if (def && (typeof def.x === 'number') && (typeof def.y === 'number')) {\r\n                        this.move(def.x, def.y, def.orientation || 0);\r\n                        this.viewportUpdate = true;\r\n                    }\r\n                    break;\r\n                }\r\n                \r\n                if (def.begin) { // get rid of last follow\r\n                    def.begin = 0;\r\n                }\r\n\r\n            },\r\n            \r\n            move: function (x, y, newOrientation) {\r\n                var moved = this.moveX(x);\r\n                moved = this.moveY(y) || moved;\r\n                if (this.rotate) {\r\n                    moved = this.reorient(newOrientation || 0) || moved;\r\n                }\r\n                return moved;\r\n            },\r\n            \r\n            moveX: doNothing,\r\n            \r\n            moveY: doNothing,\r\n            \r\n            reorient: function (newOrientation) {\r\n                var errMargin = 0.0001,\r\n                    worldCamera = this.worldCamera;\r\n                \r\n                if (Math.abs(worldCamera.orientation - newOrientation) > errMargin) {\r\n                    worldCamera.orientation = newOrientation;\r\n                    return true;\r\n                }\r\n                return false;\r\n            },\r\n            \r\n            lockedFollow: (function () {\r\n                var min = Math.min,\r\n                    getTransitionalPoint = function (a, b, ratio) {\r\n                        // Find point between two points according to ratio.\r\n                        return ratio * b + (1 - ratio) * a;\r\n                    },\r\n                    getRatio = function (transition, time) {\r\n                        // Look at the target transition time (in milliseconds) and set up ratio accordingly.\r\n                        if (transition) {\r\n                            return min(time / transition, 1);\r\n                        } else {\r\n                            return 1;\r\n                        }\r\n                    };\r\n                \r\n                return function (entity, time) {\r\n                    var worldCamera = this.worldCamera,\r\n                        worldVP = worldCamera.viewport,\r\n                        x = getTransitionalPoint(worldVP.x, entity.x + this.offsetX, getRatio(this.transitionX, time)),\r\n                        y = getTransitionalPoint(worldVP.y, entity.y + this.offsetY, getRatio(this.transitionY, time));\r\n\r\n                    if (this.rotate) { // Only run the orientation calculations if we need them.\r\n                        return this.move(x, y, getTransitionalPoint(worldCamera.orientation, -(entity.orientation || 0), getRatio(this.transitionAngle, time)));\r\n                    } else {\r\n                        return this.move(x, y, 0);\r\n                    }\r\n                };\r\n            }()),\r\n            \r\n            forwardFollow: function (entity, time) {\r\n                var avgFraction = 0.9,\r\n                    avgFractionFlip = 1 - avgFraction,\r\n                    ff = this.forwardFollower,\r\n                    moved  = false,\r\n                    ms = 15,\r\n                    standardizeTimeDistance = ms / time, //This allows the camera to pan appropriately on slower devices or longer ticks\r\n                    worldCamera = this.worldCamera,\r\n                    worldVP = worldCamera.viewport,\r\n                    x = entity.x + this.offsetX,\r\n                    y = entity.y + this.offsetY,\r\n                    a = (entity.orientation || 0) + this.offsetAngle;\r\n                \r\n                if (this.followFocused && (this.lastX === x) && (this.lastY === y)) {\r\n                    return this.lockedFollow(ff, time);\r\n                } else {\r\n                    // span over last 10 ticks to prevent jerkiness\r\n                    this.averageOffsetX *= avgFraction;\r\n                    this.averageOffsetY *= avgFraction;\r\n                    this.averageOffsetX += avgFractionFlip * (x - this.lastX) * standardizeTimeDistance;\r\n                    this.averageOffsetY += avgFractionFlip * (y - this.lastY) * standardizeTimeDistance;\r\n\r\n                    if (Math.abs(this.averageOffsetX) > (worldVP.width / (this.forwardX * 2))) {\r\n                        this.averageOffsetX = 0;\r\n                    }\r\n                    if (Math.abs(this.averageOffsetY) > (worldVP.height / (this.forwardY * 2))) {\r\n                        this.averageOffsetY = 0;\r\n                    }\r\n                    \r\n                    if (this.rotate) {\r\n                        this.averageOffsetAngle *= avgFraction;\r\n                        this.averageOffsetAngle += avgFractionFlip * (a - this.lastOrientation) * standardizeTimeDistance;\r\n                        if (Math.abs(this.averageOffsetAngle) > (worldCamera.orientation / (this.forwardAngle * 2))) {\r\n                            this.averageOffsetAngle = 0;\r\n                        }\r\n                    }\r\n\r\n                    ff.x = this.averageOffsetX * this.forwardX + x;\r\n                    ff.y = this.averageOffsetY * this.forwardY + y;\r\n                    ff.orientation = this.averageOffsetAngle * this.forwardAngle + a;\r\n                    \r\n                    this.lastX = x;\r\n                    this.lastY = y;\r\n                    this.lastOrientation = a;\r\n                    \r\n                    moved = this.lockedFollow(ff, time);\r\n\r\n                    if (!this.followFocused && !moved) {\r\n                        this.followFocused = true;\r\n                    }\r\n                    \r\n                    return moved;\r\n                }\r\n                \r\n                \r\n            },\r\n            \r\n            boundingFollow: function (entity, time) {\r\n                var x = 0,\r\n                    y = 0,\r\n                    ratioX  = (this.transitionX ? Math.min(time / this.transitionX, 1) : 1),\r\n                    iratioX = 1 - ratioX,\r\n                    ratioY  = (this.transitionY ? Math.min(time / this.transitionY, 1) : 1),\r\n                    iratioY = 1 - ratioY,\r\n                    worldVP = this.worldCamera.viewport;\r\n                \r\n                this.boundingBox.move(worldVP.x, worldVP.y);\r\n                \r\n                if (entity.x > this.boundingBox.right) {\r\n                    x = entity.x - this.boundingBox.halfWidth;\r\n                } else if (entity.x < this.boundingBox.left) {\r\n                    x = entity.x + this.boundingBox.halfWidth;\r\n                }\r\n                \r\n                if (entity.y > this.boundingBox.bottom) {\r\n                    y = entity.y - this.boundingBox.halfHeight;\r\n                } else if (entity.y < this.boundingBox.top) {\r\n                    y = entity.y + this.boundingBox.halfHeight;\r\n                }\r\n                \r\n                if (x !== 0) {\r\n                    x = this.moveX(ratioX * x + iratioX * worldVP.x);\r\n                }\r\n                \r\n                if (y !== 0) {\r\n                    y = this.moveY(ratioY * y + iratioY * worldVP.y);\r\n                }\r\n                \r\n                return x || y;\r\n            },\r\n            \r\n            resize: function () {\r\n                var worldAspectRatio = this.width / this.height,\r\n                    windowAspectRatio = this.owner.width / this.owner.height,\r\n                    worldVP = this.worldCamera.viewport;\r\n                \r\n                //The dimensions of the camera in the window\r\n                this.viewport.setAll(this.owner.width / 2, this.owner.height / 2, this.owner.width, this.owner.height);\r\n                \r\n                if (!this.stretch) {\r\n                    if (windowAspectRatio > worldAspectRatio) {\r\n                        if (this.overflow) {\r\n                            worldVP.resize(this.height * windowAspectRatio, this.height);\r\n                        } else {\r\n                            this.viewport.resize(this.viewport.height * worldAspectRatio, this.viewport.height);\r\n                        }\r\n                    } else if (this.overflow) {\r\n                        worldVP.resize(this.width, this.width / windowAspectRatio);\r\n                    } else {\r\n                        this.viewport.resize(this.viewport.width, this.viewport.width / worldAspectRatio);\r\n                    }\r\n                }\r\n                \r\n                this.worldPerWindowUnitWidth  = worldVP.width  / this.viewport.width;\r\n                this.worldPerWindowUnitHeight = worldVP.height / this.viewport.height;\r\n                this.windowPerWorldUnitWidth  = this.viewport.width  / worldVP.width;\r\n                this.windowPerWorldUnitHeight = this.viewport.height / worldVP.height;\r\n                \r\n                this.container.setTransform(this.viewport.x - this.viewport.halfWidth, this.viewport.y - this.viewport.halfHeight);\r\n                \r\n                this.viewportUpdate = true;\r\n                \r\n                this.updateMovementMethods();\r\n            },\r\n            \r\n            updateMovementMethods: (function () {\r\n                // This is used to change movement modes as needed rather than doing a check every tick to determine movement type. - DDD 2/29/2016\r\n                var doNot = doNothing,\r\n                    centerX = function () {\r\n                        var world = this.worldDimensions;\r\n                        \r\n                        this.worldCamera.viewport.moveX(world.width / 2 + world.left);\r\n                        this.moveX = doNot;\r\n                        return true;\r\n                    },\r\n                    centerY = function () {\r\n                        var world = this.worldDimensions;\r\n                        \r\n                        this.worldCamera.viewport.moveY(world.height / 2 + world.top);\r\n                        this.moveY = doNot;\r\n                        return true;\r\n                    },\r\n                    containX = function (x) {\r\n                        var aabb = this.worldCamera.viewport,\r\n                            d = this.worldDimensions,\r\n                            w = d.width,\r\n                            l = d.left;\r\n                        \r\n                        if (Math.abs(aabb.x - x) > this.threshold) {\r\n                            if (x + aabb.halfWidth > w + l) {\r\n                                aabb.moveX(w - aabb.halfWidth + l);\r\n                            } else if (x < aabb.halfWidth + l) {\r\n                                aabb.moveX(aabb.halfWidth + l);\r\n                            } else {\r\n                                aabb.moveX(x);\r\n                            }\r\n                            return true;\r\n                        }\r\n                        return false;\r\n                    },\r\n                    containY = function (y) {\r\n                        var aabb = this.worldCamera.viewport,\r\n                            d = this.worldDimensions,\r\n                            h = d.height,\r\n                            t = d.top;\r\n                        \r\n                        if (Math.abs(aabb.y - y) > this.threshold) {\r\n                            if (y + aabb.halfHeight > h + t) {\r\n                                aabb.moveY(h - aabb.halfHeight + t);\r\n                            } else if (y < aabb.halfHeight + t) {\r\n                                aabb.moveY(aabb.halfHeight + t);\r\n                            } else {\r\n                                aabb.moveY(y);\r\n                            }\r\n                            return true;\r\n                        }\r\n                        return false;\r\n                    },\r\n                    allX = function (x) {\r\n                        var aabb = this.worldCamera.viewport;\r\n                        \r\n                        if (Math.abs(aabb.x - x) > this.threshold) {\r\n                            aabb.moveX(x);\r\n                            return true;\r\n                        }\r\n                        return false;\r\n                    },\r\n                    allY = function (y) {\r\n                        var aabb = this.worldCamera.viewport;\r\n                        \r\n                        if (Math.abs(aabb.y - y) > this.threshold) {\r\n                            aabb.moveY(y);\r\n                            return true;\r\n                        }\r\n                        return false;\r\n                    };\r\n                \r\n                return function () {\r\n                    var threshold = this.threshold,\r\n                        worldVP = this.worldCamera.viewport,\r\n                        world = this.worldDimensions,\r\n                        w = world.width,\r\n                        h = world.height;\r\n                    \r\n                    if (!w) {\r\n                        this.moveX = allX;\r\n                    } else if (w < worldVP.width) {\r\n                        this.moveX = centerX;\r\n                    } else {\r\n                        this.moveX = containX;\r\n                    }\r\n\r\n                    if (!h) {\r\n                        this.moveY = allY;\r\n                    } else if (h < worldVP.height) {\r\n                        this.moveY = centerY;\r\n                    } else {\r\n                        this.moveY = containY;\r\n                    }\r\n\r\n                    // Make sure camera is correctly contained:\r\n                    this.threshold = -1; // forces update\r\n                    this.moveX(worldVP.x);\r\n                    this.moveY(worldVP.y);\r\n                    this.threshold = threshold;\r\n                };\r\n            }()),\r\n            \r\n            destroy: function () {\r\n                this.parentContainer.removeChild(this.container);\r\n                this.parentContainer = null;\r\n                this.container = null;\r\n                if (this.mouseVector) {\r\n                    this.mouseVector.recycle();\r\n                    this.mouseWorldOrigin.recycle();\r\n                }\r\n                \r\n                this.boundingBox.recycle();\r\n                this.viewport.recycle();\r\n                this.worldCamera.viewport.recycle();\r\n                this.worldCamera.recycle();\r\n                this.message.viewport.recycle();\r\n                this.message.recycle();\r\n                this.cameraLoadedMessage.recycle();\r\n                this.worldDimensions.recycle();\r\n    \r\n                this.forwardFollower.recycle();\r\n                this.lastFollow.recycle();\r\n            }\r\n        },\r\n\r\n        publicMethods: {\r\n            /**\r\n             * Returns whether a particular display object intersects the camera's viewport on the canvas.\r\n             *\r\n             * @method isOnCanvas\r\n             * @param bounds {PIXI.Rectangle|Object} The bounds of the display object.\r\n             * @param bounds.height {Number} The height of the display object.\r\n             * @param bounds.width {Number} The width of the display object.\r\n             * @param bounds.x {Number} The left edge of the display object.\r\n             * @param bounds.y {Number} The top edge of the display object.\r\n             * @return {Boolean} Whether the display object intersects the camera's bounds.\r\n             * @since 0.10.0\r\n             */\r\n            isOnCanvas: function (bounds) {\r\n                var canvas = this.canvas;\r\n\r\n                return !bounds || !((bounds.x + bounds.width < 0) || (bounds.x > canvas.width) || (bounds.y + bounds.height < 0) || (bounds.y > canvas.height));\r\n            },\r\n\r\n            /**\r\n             * Returns a world coordinate corresponding to a provided window coordinate.\r\n             *\r\n             * @method windowToWorld\r\n             * @param windowVector {platypus.Vector} A vector describing a window position.\r\n             * @param withOffset {Boolean} Whether to provide a world position relative to the camera's location.\r\n             * @param vector {platypus.Vector} If provided, this is used as the return vector.\r\n             * @return {platypus.Vector} A vector describing a world position.\r\n             */\r\n            windowToWorld: function (windowVector, withOffset, vector) {\r\n                var worldVector = vector || _Vector_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\r\n                \r\n                worldVector.x = windowVector.x * this.worldPerWindowUnitWidth;\r\n                worldVector.y = windowVector.y * this.worldPerWindowUnitHeight;\r\n                \r\n                if (withOffset !== false) {\r\n                    worldVector.x += this.worldCamera.viewport.left;\r\n                    worldVector.y += this.worldCamera.viewport.top;\r\n                }\r\n\r\n                return worldVector;\r\n            },\r\n            \r\n            /**\r\n             * Returns a window coordinate corresponding to a provided world coordinate.\r\n             *\r\n             * @method worldToWindow\r\n             * @param worldVector {platypus.Vector} A vector describing a world position.\r\n             * @param withOffset {Boolean} Whether to provide a window position relative to the camera's location.\r\n             * @param vector {platypus.Vector} If provided, this is used as the return vector.\r\n             * @return {platypus.Vector} A vector describing a window position.\r\n             */\r\n            worldToWindow: function (worldVector, withOffset, vector) {\r\n                var windowVector = vector || _Vector_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\r\n\r\n                windowVector.x = worldVector.x * this.windowPerWorldUnitWidth;\r\n                windowVector.y = worldVector.y * this.windowPerWorldUnitHeight;\r\n                \r\n                if (withOffset !== false) {\r\n                    windowVector.x += this.viewport.x;\r\n                    windowVector.y += this.viewport.y;\r\n                }\r\n\r\n                return windowVector;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/Camera.js?");

/***/ }),

/***/ "./src/components/CameraFollowMe.js":
/*!******************************************!*\
  !*** ./src/components/CameraFollowMe.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/**\r\n * This component can request that the camera focus on this entity.\r\n *\r\n * @namespace platypus.components\r\n * @class CameraFollowMe\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        id: 'CameraFollowMe',\r\n        \r\n        properties: {\r\n            /**\r\n             * Sets initial camera settings when the entity is being followed. This can be over-written by the \"follow-me\" call itself. If any of these attributes are not provided, the following are used by default:\r\n             *\r\n                  {\r\n                      \"time\": 500,\r\n                      // Optional. Time in milliseconds that the camera should focus before returning to the original focus.\r\n                      \r\n                      \"mode\": \"forward\",\r\n                      // Optional. Camera mode that the camera should use.\r\n                      \r\n                      \"top\": 100,\r\n                      // Optional number specifying top of viewport in world coordinates\r\n                      \r\n                      \"left\": 100,\r\n                      // Optional number specifying left of viewport in world coordinates\r\n                      \r\n                      \"width\": 100,\r\n                      // Optional number specifying width of viewport in world coordinates\r\n                      \r\n                      \"height\": 100,\r\n                      // Optional number specifying height of viewport in world coordinates\r\n                      \r\n                      \"offsetX\": 20,\r\n                      // Optional number setting how far to offset the camera from the entity horizontally.\r\n                      \r\n                      \"offsetY\": 40\r\n                      // Optional number setting how far to offset the camera from the entity vertically.\r\n                  }\r\n             *\r\n             * @property camera\r\n             * @type Object\r\n             * @default {}\r\n             */\r\n            camera: {},\r\n            \r\n            /**\r\n             * Camera mode that the camera should use.\r\n             *\r\n             * @property mode\r\n             * @type String\r\n             * @default \"forward\"\r\n             */\r\n            mode: \"forward\",\r\n\r\n            /**\r\n             * Whether to pause the game while the camera is focused.\r\n             *\r\n             * @property pause\r\n             * @type boolean\r\n             * @default false\r\n             */\r\n            pause: false\r\n        },\r\n        \r\n        initialize: function () {\r\n            this.pauseGame = (this.pause && this.camera.time) ? {\r\n                time: this.camera.time\r\n            } : null;\r\n            \r\n            this.camera = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(\r\n                \"entity\", this.owner,\r\n                \"mode\", this.camera.mode || this.mode,\r\n                \"top\", this.camera.top,\r\n                \"left\", this.camera.left,\r\n                \"offsetX\", this.camera.offsetX,\r\n                \"offsetY\", this.camera.offsetY,\r\n                \"width\", this.camera.width,\r\n                \"height\", this.camera.height,\r\n                \"time\", this.camera.time\r\n            );\r\n        },\r\n        \r\n        events: {\r\n            /**\r\n             * On receiving this message, the component will trigger a message requesting that the parent camera begin following this entity.\r\n             *\r\n             * @method 'follow-me'\r\n             * @param [options] {Object} A list of key/value paris describing camera options to set.\r\n             * @param [options.mode] {String} Camera following mode.\r\n             * @param [options.top] {number} The top of a bounding box.\r\n             * @param [options.left] {number} The left of a bounding box.\r\n             * @param [options.width] {number} The width of a bounding box.\r\n             * @param [options.height] {number} The height of a bounding box.\r\n             * @param [options.offsetX] {number} How far to offset the camera from the entity horizontally.\r\n             * @param [options.offsetY] {number} How far to offset the camera from the entity vertically.\r\n             * @param [options.time] {number} How many milliseconds to follow the entity.\r\n             */\r\n            \"follow-me\": function (options) {\r\n                var msg = null;\r\n                \r\n                if (options) {\r\n                    msg = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(\r\n                        \"entity\",  this.owner,\r\n                        \"mode\",    options.mode    || this.camera.mode,\r\n                        \"top\",     options.top     || this.camera.top,\r\n                        \"left\",    options.left    || this.camera.left,\r\n                        \"offsetX\", options.offsetX || this.camera.offsetX,\r\n                        \"offsetY\", options.offsetY || this.camera.offsetY,\r\n                        \"width\",   options.width   || this.camera.width,\r\n                        \"height\",  options.height  || this.camera.height,\r\n                        \"time\",    options.time    || this.camera.time\r\n                    );\r\n                } else {\r\n                    msg = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.camera);\r\n                }\r\n\r\n                if (this.pauseGame) {\r\n\r\n                    /**\r\n                     * This component fires this message on the parent entity to pause logic if required.\r\n                     *\r\n                     * @event 'pause-logic'\r\n                     * @param options {Object}\r\n                     * @param options.time {number} The amount of time to pause before re-enabling logic.\r\n                     */\r\n                    this.owner.parent.triggerEvent('pause-logic',  this.pauseGame);\r\n                    \r\n                    /**\r\n                     * This component fires this message on the parent entity to pause rendering if required.\r\n                     *\r\n                     * @event 'pause-render'\r\n                     * @param options {Object}\r\n                     * @param options.time {number} The amount of time to pause before re-enabling render updates.\r\n                     */\r\n                    this.owner.parent.triggerEvent('pause-render', this.pauseGame);\r\n                }\r\n                \r\n                /**\r\n                 * This component fires this message on this entity's parent so the camera will begin following this entity.\r\n                 *\r\n                 * @event 'follow'\r\n                 * @param options {Object} A list of key/value pairs describing camera options to set.\r\n                 * @param options.entity {platypus.Entity} Sends this entity for the camera to follow.\r\n                 * @param options.mode {String} Camera following mode.\r\n                 * @param options.top {number} The top of a bounding box.\r\n                 * @param options.left {number} The left of a bounding box.\r\n                 * @param options.width {number} The width of a bounding box.\r\n                 * @param options.height {number} The height of a bounding box.\r\n                 * @param options.offsetX {number} How far to offset the camera from the entity horizontally.\r\n                 * @param options.offsetY {number} How far to offset the camera from the entity vertically.\r\n                 * @param options.time {number} How many milliseconds to follow the entity.\r\n                 */\r\n                this.owner.parent.triggerEvent('follow', msg);\r\n                \r\n                msg.recycle();\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                this.camera.recycle();\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/CameraFollowMe.js?");

/***/ }),

/***/ "./src/components/CollisionBasic.js":
/*!******************************************!*\
  !*** ./src/components/CollisionBasic.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _CollisionShape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollisionShape.js */ \"./src/CollisionShape.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/**\r\n * This component causes this entity to collide with other entities. It must be part of a collision group and will receive messages when colliding with other entities in the collision group.\r\n *\r\n * Multiple collision components may be added to a single entity if distinct messages should be triggered for certain collision areas on the entity or if the soft collision area is a different shape from the solid collision area. Be aware that too many additional collision areas may adversely affect performance.\r\n *\r\n * @namespace platypus.components\r\n * @class CollisionBasic\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var\r\n        /**\r\n         * On receiving a 'hit-by' message, custom messages are triggered on the entity corresponding with the component's `solidCollisions` and `softCollisions` key/value mappings.\r\n         *\r\n         * @event *\r\n         * @param collision {Object} A list of key/value pairs describing the collision.\r\n         */\r\n        entityBroadcast = (function () {\r\n            var stringBroadcast = function (event, collisionType, solidOrSoft, value) {\r\n                    if (value.myType === collisionType) {\r\n                        if (value.hitType === solidOrSoft) {\r\n                            this.owner.triggerEvent(event, value);\r\n                        }\r\n                    }\r\n                },\r\n                arrayBroadcast = function (event, collisionType, solidOrSoft, value) {\r\n                    var i = 0;\r\n                    \r\n                    if (value.myType === collisionType) {\r\n                        if (value.hitType === solidOrSoft) {\r\n                            for (i = 0; i < event.length; i++) {\r\n                                this.owner.triggerEvent(event[i], value);\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                directionalBroadcast = function (event, collisionType, solidOrSoft, collisionInfo) {\r\n                    var dx = collisionInfo.x,\r\n                        dy = collisionInfo.y;\r\n\r\n                    if (collisionInfo.entity && !(dx || dy)) {\r\n                        dx = collisionInfo.entity.x - this.owner.x;\r\n                        dy = collisionInfo.entity.y - this.owner.y;\r\n                    }\r\n\r\n                    if (collisionInfo.myType === collisionType) {\r\n                        if (collisionInfo.hitType === solidOrSoft) {\r\n                            if ((dy > 0) && event.bottom) {\r\n                                this.owner.trigger(event.bottom, collisionInfo);\r\n                            } else if ((dy < 0) && event.top) {\r\n                                this.owner.trigger(event.top, collisionInfo);\r\n                            }\r\n                            if ((dx > 0) && event.right) {\r\n                                this.owner.trigger(event.right, collisionInfo);\r\n                            } else if ((dx < 0) && event.left) {\r\n                                this.owner.trigger(event.left, collisionInfo);\r\n                            }\r\n                            if (event.all) {\r\n                                this.owner.trigger(event.all, collisionInfo);\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n            \r\n            return function (self, event, solidOrSoft) {\r\n                if (typeof event === 'string') {\r\n                    return stringBroadcast.bind(self, event, self.collisionType, solidOrSoft);\r\n                } else if (Array.isArray(event)) {\r\n                    return arrayBroadcast.bind(self, event, self.collisionType, solidOrSoft);\r\n                } else {\r\n                    return directionalBroadcast.bind(self, event, self.collisionType, solidOrSoft);\r\n                }\r\n            };\r\n        }()),\r\n        setupCollisionFunctions = (function () {\r\n            var entityGetAABB = function (aabb, colFuncs, collisionType) {\r\n                    var keys = colFuncs.keys,\r\n                        i = keys.length,\r\n                        funcs = null;\r\n\r\n                    if (!collisionType) {\r\n                        aabb.reset();\r\n                        while (i--) {\r\n                            aabb.include(colFuncs.get(keys[i]).getAABB());\r\n                        }\r\n                        return aabb;\r\n                    } else {\r\n                        funcs = colFuncs.get(collisionType);\r\n                        if (funcs) {\r\n                            return funcs.getAABB();\r\n                        } else {\r\n                            return null;\r\n                        }\r\n                    }\r\n                },\r\n                entityGetPreviousAABB = function (colFuncs, collisionType) {\r\n                    var colFunc = colFuncs.get(collisionType);\r\n                    \r\n                    if (colFunc) {\r\n                        return colFunc.getPreviousAABB();\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                },\r\n                entityGetShapes = function (colFuncs, collisionType) {\r\n                    var colFunc = colFuncs.get(collisionType);\r\n                    \r\n                    if (colFunc) {\r\n                        return colFunc.getShapes();\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                },\r\n                entityGetPrevShapes = function (colFuncs, collisionType) {\r\n                    var colFunc = colFuncs.get(collisionType);\r\n                    \r\n                    if (colFunc) {\r\n                        return colFunc.getPrevShapes();\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                },\r\n                entityPrepareCollision = function (colFuncs, x, y) {\r\n                    var keys = colFuncs.keys,\r\n                        i = keys.length;\r\n                    \r\n                    while (i--) {\r\n                        colFuncs.get(keys[i]).prepareCollision(x, y);\r\n                    }\r\n                },\r\n                entityRelocateEntity = (function () {\r\n                    var handleStuck = function (position, data, owner) {\r\n                            var m = 0,\r\n                                s = data.stuck;\r\n\r\n                            if (s) {\r\n                                m = position.magnitude();\r\n                                if (data.thatShape.owner && (Math.abs(s) > 1)) {\r\n                                    s *= 0.05;\r\n                                }\r\n                                if (!m || (m > Math.abs(s))) {\r\n                                    if (data.vector.x) {\r\n                                        position.x = s;\r\n                                        position.y = 0;\r\n                                    }\r\n                                    if (data.vector.y) {\r\n                                        position.x = 0;\r\n                                        position.y = s;\r\n                                    }\r\n                                    if (owner.stuckWith) {\r\n                                        owner.stuckWith.recycle();\r\n                                    }\r\n                                    owner.stuckWith = _Vector_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].setUp(data.thatShape.x, data.thatShape.y);\r\n                                }\r\n                            }\r\n                        },\r\n                        message = {\r\n                            position: null,\r\n                            unstick: null\r\n                        };\r\n                    \r\n                    return function (vector, collisionData) {\r\n                        var colX = collisionData.xData[0],\r\n                            colY = collisionData.yData[0],\r\n                            msg = message,\r\n                            v = null;\r\n\r\n                        if (colX) {\r\n                            v = _Vector_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].setUp(0, 0, 0);\r\n                            handleStuck(v, colX, this);\r\n                        }\r\n\r\n                        if (colY) {\r\n                            v = v || _Vector_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].setUp(0, 0, 0);\r\n                            handleStuck(v, colY, this);\r\n                        }\r\n\r\n                        msg.position = vector;\r\n                        msg.unstick = v;\r\n                        this.triggerEvent('relocate-entity', msg);\r\n                        \r\n                        if (v) {\r\n                            v.recycle();\r\n                        }\r\n                    };\r\n                }()),\r\n                entityMovePreviousX = function (colFuncs, x) {\r\n                    var keys = colFuncs.keys,\r\n                        i = keys.length;\r\n                    \r\n                    while (i--) {\r\n                        colFuncs.get(keys[i]).movePreviousX(x);\r\n                    }\r\n                },\r\n                entityGetCollisionTypes = function () {\r\n                    return this.collisionTypes;\r\n                },\r\n                entityGetSolidCollisions = function () {\r\n                    return this.solidCollisionMap;\r\n                },\r\n                getAABB = function () {\r\n                    return this.getAABB();\r\n                },\r\n                getPreviousAABB = function () {\r\n                    return this.getPreviousAABB();\r\n                },\r\n                getShapes = function () {\r\n                    return this.getShapes();\r\n                },\r\n                getPrevShapes = function () {\r\n                    return this.getPrevShapes();\r\n                },\r\n                prepareCollision = function (x, y) {\r\n                    this.prepareCollision(x, y);\r\n                },\r\n                movePreviousX = function (x) {\r\n                    this.movePreviousX(x);\r\n                };\r\n            \r\n            return function (self, entity) {\r\n                var colFuncs = entity.collisionFunctions;\r\n                \r\n                // This allows the same component type to be added multiple times.\r\n                if (!colFuncs) {\r\n                    colFuncs = entity.collisionFunctions = _DataMap_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\r\n                    entity.aabb = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\r\n                    entity.getAABB = entityGetAABB.bind(entity, entity.aabb, colFuncs);\r\n                    entity.getPreviousAABB = entityGetPreviousAABB.bind(entity, colFuncs);\r\n                    entity.getShapes = entityGetShapes.bind(entity, colFuncs);\r\n                    entity.getPrevShapes = entityGetPrevShapes.bind(entity, colFuncs);\r\n                    entity.prepareCollision = entityPrepareCollision.bind(entity, colFuncs);\r\n                    entity.relocateEntity = entityRelocateEntity.bind(entity);\r\n                    entity.movePreviousX = entityMovePreviousX.bind(entity, colFuncs);\r\n                    entity.getCollisionTypes = entityGetCollisionTypes.bind(entity);\r\n                    entity.getSolidCollisions = entityGetSolidCollisions.bind(entity);\r\n                }\r\n\r\n                colFuncs.set(self.collisionType, _Data_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setUp(\r\n                    \"getAABB\", getAABB.bind(self),\r\n                    \"getPreviousAABB\", getPreviousAABB.bind(self),\r\n                    \"getShapes\", getShapes.bind(self),\r\n                    \"getPrevShapes\", getPrevShapes.bind(self),\r\n                    \"prepareCollision\", prepareCollision.bind(self),\r\n                    \"movePreviousX\", movePreviousX.bind(self)\r\n                ));\r\n            };\r\n        }());\r\n\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'CollisionBasic',\r\n\r\n        properties: {\r\n            /**\r\n             * Defines how this entity should be recognized by other colliding entities.\r\n             *\r\n             * @property collisionType\r\n             * @type String\r\n             * @default \"none\"\r\n             */\r\n            collisionType: \"none\",\r\n\r\n            /**\r\n             * Defines the type of colliding shape.\r\n             *\r\n             * @property shapeType\r\n             * @type String\r\n             * @default \"rectangle\"\r\n             */\r\n            shapeType: \"rectangle\",\r\n            \r\n            /**\r\n             * Determines whether the collision area should transform on orientation changes.\r\n             *\r\n             * @property ignoreOrientation\r\n             * @type boolean\r\n             * @default false\r\n             */\r\n            ignoreOrientation: false,\r\n            \r\n            /**\r\n             * Determines the x-axis center of the collision shape.\r\n             *\r\n             * @property regX\r\n             * @type number\r\n             * @default width / 2\r\n             */\r\n            regX: null,\r\n            \r\n            /**\r\n             * Determines the y-axis center of the collision shape.\r\n             *\r\n             * @property regY\r\n             * @type number\r\n             * @default height / 2\r\n             */\r\n            regY: null,\r\n            \r\n            /**\r\n             * Sets the width of the collision area in world coordinates.\r\n             *\r\n             * @property width\r\n             * @type number\r\n             * @default 0\r\n             */\r\n            width: 0,\r\n            \r\n            /**\r\n             * Sets the height of the collision area in world coordinates.\r\n             *\r\n             * @property height\r\n             * @type number\r\n             * @default 0\r\n             */\r\n            height: 0,\r\n            \r\n            /**\r\n             * Sets the radius of a circle collision area in world coordinates.\r\n             *\r\n             * @property radius\r\n             * @type number\r\n             * @default 0\r\n             */\r\n            radius: 0,\r\n            \r\n            /**\r\n             * Determines which collision types this entity should consider soft, meaning this entity may pass through them, but triggers collision messages on doing so. Example:\r\n             *\r\n             *     {\r\n             *         \"water\": \"soaked\",       // This triggers a \"soaked\" message on the entity when it passes over a \"water\" collision-type entity.\r\n             *         \"lava\": [\"burn\", \"ouch\"] // This triggers both messages on the entity when it passes over a \"lava\" collision-type entity.\r\n             *     }\r\n             *\r\n             * @property softCollisions\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            softCollisions: null,\r\n            \r\n            /**\r\n             * Determines which collision types this entity should consider solid, meaning this entity should not pass through them. Example:\r\n             *\r\n             *     {\r\n             *         \"boulder\": \"\",                       // This specifies that this entity should not pass through other \"boulder\" collision-type entities.\r\n             *         \"diamond\": \"crack-up\",               // This specifies that this entity should not pass through \"diamond\" collision-type entities, but if it touches one, it triggers a \"crack-up\" message on the entity.\r\n             *         \"marble\": [\"flip\", \"dance\", \"crawl\"] // This specifies that this entity should not pass through \"marble\" collision-type entities, but if it touches one, it triggers all three specified messages on the entity.\r\n             *     }\r\n             *\r\n             * @property solidCollisions\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            solidCollisions: null,\r\n            \r\n            /**\r\n             * This is the margin around the entity's width and height. This is an alternative method for specifying the collision shape in terms of the size of the entity. Can also pass in an object specifying the following parameters if the margins vary per side: top, bottom, left, and right.\r\n             *\r\n             * @property margin\r\n             * @type number|Object\r\n             * @default 0\r\n             */\r\n            margin: 0,\r\n            \r\n            /**\r\n             * Defines one or more shapes to create the collision area. Defaults to a single shape with the width, height, regX, and regY properties of the entity if not specified. See [CollisionShape](CollisionShape.html) for the full list of properties.\r\n             *\r\n             * @property shapes\r\n             * @type Array\r\n             * @default null\r\n             */\r\n            shapes: null\r\n        },\r\n        \r\n        publicProperties: {\r\n            /**\r\n             * This property should be set to true if entity doesn't move for better optimization. This causes other entities to check against this entity, but this entity performs no checks of its own. Available on the entity as `entity.immobile`.\r\n             *\r\n             * @property immobile\r\n             * @type boolean\r\n             * @default false\r\n             */\r\n            immobile: false,\r\n\r\n            /**\r\n             * Whether this entity should be tested across its entire movement path. This is necessary for fast-moving entities, but shouldn't be used for others due to the processing overhead. Available on the entity as `entity.bullet`.\r\n             *\r\n             * @property bullet\r\n             * @type boolean\r\n             * @default false\r\n             */\r\n            bullet: false,\r\n            \r\n            /**\r\n             * Whether the entity is only solid when being collided with from the top.\r\n             *\r\n             * @property jumpThrough\r\n             * @type boolean\r\n             * @default: false\r\n             */\r\n            jumpThrough: false\r\n        },\r\n        \r\n        initialize: function (definition) {\r\n            var arr = null,\r\n                x            = 0,\r\n                key          = '',\r\n                shapes       = null,\r\n                regX         = this.regX,\r\n                regY         = this.regY,\r\n                width        = this.width,\r\n                height       = this.height,\r\n                radius       = this.radius,\r\n                marginLeft   = 0,\r\n                marginRight  = 0,\r\n                marginTop    = 0,\r\n                marginBottom = 0;\r\n\r\n            if (typeof this.margin === \"number\") {\r\n                marginLeft   = this.margin;\r\n                marginRight  = this.margin;\r\n                marginTop    = this.margin;\r\n                marginBottom = this.margin;\r\n            } else {\r\n                marginLeft   = this.margin.left || 0;\r\n                marginRight  = this.margin.right || 0;\r\n                marginTop    = this.margin.top || 0;\r\n                marginBottom = this.margin.bottom || 0;\r\n            }\r\n            \r\n            if (regX === null) {\r\n                regX = this.regX = width / 2;\r\n            }\r\n            \r\n            if (regY === null) {\r\n                regY = this.regY = height / 2;\r\n            }\r\n            \r\n            _Vector_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].assign(this.owner, 'position', 'x', 'y', 'z');\r\n            _Vector_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].assign(this.owner, 'previousPosition', 'previousX', 'previousY', 'previousZ');\r\n            this.owner.previousX = this.owner.previousX || this.owner.x;\r\n            this.owner.previousY = this.owner.previousY || this.owner.y;\r\n            \r\n            this.aabb     = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\r\n            this.prevAABB = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\r\n            \r\n            if (this.shapes) {\r\n                shapes = this.shapes;\r\n            } else if (this.shapeType === 'circle') {\r\n                radius = radius || (((width || 0) + (height || 0)) / 4);\r\n                shapes = [{\r\n                    regX: (isNaN(regX) ? radius : regX) - (marginRight - marginLeft) / 2,\r\n                    regY: (isNaN(regY) ? radius : regY) - (marginBottom - marginTop) / 2,\r\n                    radius: radius,\r\n                    type: this.shapeType\r\n                }];\r\n            } else {\r\n                shapes = [{\r\n                    //regX: (isNaN(regX) ? (width  || 0) / 2 : regX) - (marginRight  - marginLeft) / 2,\r\n                    //regY: (isNaN(regY) ? (height || 0) / 2 : regY) - (marginBottom - marginTop)  / 2,\r\n                    regX: (isNaN(regX) ? (width  || 0) / 2 : regX) + marginLeft,\r\n                    regY: (isNaN(regY) ? (height || 0) / 2 : regY) + marginTop,\r\n                    points: definition.points,\r\n                    width: (width  || 0) + marginLeft + marginRight,\r\n                    height: (height || 0) + marginTop  + marginBottom,\r\n                    type: this.shapeType\r\n                }];\r\n            }\r\n            \r\n            this.owner.collisionTypes = this.owner.collisionTypes || _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.owner.collisionTypes.push(this.collisionType);\r\n            \r\n            this.shapes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.prevShapes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.entities = null;\r\n            for (x = 0; x < shapes.length; x++) {\r\n                this.shapes.push(_CollisionShape_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(this.owner, shapes[x], this.collisionType));\r\n                this.prevShapes.push(_CollisionShape_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(this.owner, shapes[x], this.collisionType));\r\n                this.prevAABB.include(this.prevShapes[x].aABB);\r\n                this.aabb.include(this.shapes[x].aABB);\r\n            }\r\n            \r\n            setupCollisionFunctions(this, this.owner);\r\n            \r\n            this.owner.solidCollisionMap = this.owner.solidCollisionMap || _DataMap_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\r\n            arr = this.owner.solidCollisionMap.set(this.collisionType, _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp());\r\n            if (this.solidCollisions) {\r\n                for (key in this.solidCollisions) {\r\n                    if (this.solidCollisions.hasOwnProperty(key)) {\r\n                        arr.push(key);\r\n                        if (this.solidCollisions[key]) { // To make sure it's not an empty string.\r\n                            this.addEventListener('hit-by-' + key, entityBroadcast(this, this.solidCollisions[key], 'solid'));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n    \r\n            this.owner.softCollisionMap = this.owner.softCollisionMap || _DataMap_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\r\n            arr = this.owner.softCollisionMap.set(this.collisionType, _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp());\r\n            if (this.softCollisions) {\r\n                for (key in this.softCollisions) {\r\n                    if (this.softCollisions.hasOwnProperty(key)) {\r\n                        arr.push(key);\r\n                        if (this.softCollisions[key]) { // To make sure it's not an empty string.\r\n                            this.addEventListener('hit-by-' + key, entityBroadcast(this, this.softCollisions[key], 'soft'));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            this.active = true;\r\n            this.stuck = false;\r\n        },\r\n        \r\n        events: {\r\n            /**\r\n             * On receiving this message, the component triggers `add-collision-entity` on the parent.\r\n             *\r\n             * @method 'collide-on'\r\n             * @param type {String} If specified, only collision components of this type are added to the collision list.\r\n             */\r\n            \"collide-on\": function (type) {\r\n                var owner = this.owner,\r\n                    colType = this.collisionType,\r\n                    colTypes = owner.collisionTypes;\r\n                \r\n                /**\r\n                 * On receiving 'collide-on', this message is triggered on the parent to turn on collision.\r\n                 *\r\n                 * @event 'add-collision-entity'\r\n                 * @param entity {platypus.Entity} The entity this component is attached to.\r\n                 */\r\n                if (!this.active && ((typeof type !== 'string') || (type === colType))) {\r\n                    if (colTypes.indexOf(colType) === -1) {\r\n                        colTypes.push(colType);\r\n                    }\r\n                    owner.parent.triggerEvent('add-collision-entity', owner);\r\n                    this.active = true;\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the component triggers `remove-collision-entity` on the parent.\r\n             *\r\n             * @method 'collide-off'\r\n             * @param type {String} If specified, only collision components of this type are removed from the collision list.\r\n             */\r\n            \"collide-off\": function (type) {\r\n                var index = 0,\r\n                    owner = this.owner,\r\n                    parent = owner.parent,\r\n                    colType = this.collisionType,\r\n                    colTypes = owner.collisionTypes;\r\n                \r\n                /**\r\n                 * On receiving 'collide-off', this message is triggered on the parent to turn off collision.\r\n                 *\r\n                 * @event 'remove-collision-entity'\r\n                 * @param entity {platypus.Entity} The entity this component is attached to.\r\n                 */\r\n                if (this.active && ((typeof type !== 'string') || (type === colType))) {\r\n                    parent.triggerEvent('remove-collision-entity', owner);\r\n                    index = colTypes.indexOf(colType);\r\n                    if (index >= 0) {\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(colTypes, index);\r\n                    }\r\n                    this.active = false;\r\n\r\n                    if (colTypes.length) {\r\n                        parent.triggerEvent('add-collision-entity', owner);\r\n                    }\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * This message causes the entity's x,y coordinates to update.\r\n             *\r\n             * @method 'relocate-entity'\r\n             * @param position {platypus.Vector} The new coordinates.\r\n             * @param [position.relative=false] {boolean} Determines whether the provided x,y coordinates are relative to the entity's current position.\r\n             */\r\n            \"relocate-entity\": function (resp) {\r\n                var unstick = resp.unstick,\r\n                    um      = 0,\r\n                    i       = 0,\r\n                    x       = 0,\r\n                    y       = 0,\r\n                    aabb    = this.aabb,\r\n                    owner   = this.owner,\r\n                    shape   = null,\r\n                    shapes  = this.shapes;\r\n                \r\n                if (unstick) {\r\n                    um = unstick.magnitude();\r\n                }\r\n                \r\n                if (this.move) {\r\n                    this.move.recycle();\r\n                    this.move = null;\r\n                }\r\n                \r\n                if (resp.relative) {\r\n                    owner.position.setVector(owner.previousPosition).add(resp.position);\r\n                } else {\r\n                    owner.position.setVector(resp.position);\r\n                }\r\n\r\n                if (this.stuck) {\r\n                    if (um > 0) {\r\n                        owner.position.add(unstick);\r\n                    } else {\r\n                        this.stuck = false;\r\n                    }\r\n                }\r\n                \r\n                x = owner.x;\r\n                y = owner.y;\r\n                \r\n                aabb.reset();\r\n                i = shapes.length;\r\n                while (i--) {\r\n                    shape = shapes[i];\r\n                    shape.update(x, y);\r\n                    aabb.include(shape.aABB);\r\n                }\r\n\r\n                owner.previousPosition.setVector(owner.position);\r\n                \r\n                if (um > 0) { // to force check in all directions for ultimate stuck resolution (esp. for stationary entities)\r\n                    if (!this.stuck) {\r\n                        this.stuck = true;\r\n                    }\r\n                    this.move = owner.stuckWith.copy().add(-x, -y).normalize();\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * If the entity is stuck to another entity, this component tries to unstick the entity on each logic step.\r\n             *\r\n             * @method 'handle-logic'\r\n             */\r\n            \"handle-logic\": function () {\r\n                if (this.move) {\r\n                    this.owner.position.add(this.move); // By trying to move into it, we should get pushed back out.\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * Collision shapes are updated to reflect the new orientation when this message occurs.\r\n             *\r\n             * @method 'orientation-updated'\r\n             * @param matrix {Array} A 2D matrix describing the new orientation.\r\n             */\r\n            \"orientation-updated\": function (matrix) {\r\n                var i = 0;\r\n                \r\n                if (!this.ignoreOrientation) {\r\n                    for (i = 0; i < this.shapes.length; i++) {\r\n                        this.shapes[i].multiply(matrix);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            getAABB: function () {\r\n                return this.aabb;\r\n            },\r\n            \r\n            getPreviousAABB: function () {\r\n                return this.prevAABB;\r\n            },\r\n            \r\n            getShapes: function () {\r\n                return this.shapes;\r\n            },\r\n            \r\n            getPrevShapes: function () {\r\n                return this.prevShapes;\r\n            },\r\n            \r\n            prepareCollision: function (x, y) {\r\n                var i          = 0,\r\n                    shape      = null,\r\n                    prevShapes = this.shapes,\r\n                    shapes     = this.prevShapes,\r\n                    aabb       = this.aabb;\r\n                \r\n                this.owner.x = x;\r\n                this.owner.y = y;\r\n                \r\n                this.prevShapes = prevShapes;\r\n                this.shapes = shapes;\r\n                \r\n                this.prevAABB.set(aabb);\r\n                aabb.reset();\r\n                \r\n                // update shapes\r\n                i = shapes.length;\r\n                while (i--) {\r\n                    shape = shapes[i];\r\n                    shape.update(x, y);\r\n                    aabb.include(shape.aABB);\r\n                }\r\n            },\r\n            \r\n            movePreviousX: function (x) {\r\n                var i = 0;\r\n                \r\n                this.prevAABB.moveX(x);\r\n                for (i = 0; i < this.prevShapes.length; i++) {\r\n                    this.prevShapes[i].setXWithEntityX(x);\r\n                }\r\n            },\r\n            \r\n            destroy: function () {\r\n                var colFuncs = this.owner.collisionFunctions,\r\n                    collisionType = this.collisionType,\r\n                    i = this.owner.collisionTypes.indexOf(collisionType),\r\n                    owner = this.owner;\r\n                \r\n                owner.parent.triggerEvent('remove-collision-entity', owner);\r\n\r\n                this.aabb.recycle();\r\n                delete this.aabb;\r\n                this.prevAABB.recycle();\r\n                delete this.prevAABB;\r\n                \r\n                if (i >= 0) {\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(owner.collisionTypes, i);\r\n                }\r\n                \r\n                if (owner.solidCollisionMap.has(collisionType)) {\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(owner.solidCollisionMap.delete(collisionType));\r\n                }\r\n                if (owner.softCollisionMap.has(collisionType)) {\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(owner.softCollisionMap.delete(collisionType));\r\n                }\r\n\r\n                colFuncs.delete(collisionType).recycle();\r\n                \r\n                i = this.shapes.length;\r\n                while (i--) {\r\n                    this.shapes[i].recycle();\r\n                    this.prevShapes[i].recycle();\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.shapes);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.prevShapes);\r\n                this.shapes = null;\r\n                this.prevShapes = null;\r\n\r\n                this.entities = null;\r\n\r\n                if (owner.collisionTypes.length) {\r\n                    owner.parent.triggerEvent('add-collision-entity', owner);\r\n                } else { //remove collision functions\r\n                    colFuncs.recycle();\r\n                    owner.collisionFunctions = null;\r\n                    owner.solidCollisionMap.recycle();\r\n                    owner.solidCollisionMap = null;\r\n                    owner.softCollisionMap.recycle();\r\n                    owner.softCollisionMap = null;\r\n                    owner.aabb.recycle();\r\n                    owner.aabb = null;\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(owner.collisionTypes);\r\n                    owner.collisionTypes = null;\r\n                }\r\n            }\r\n        }\r\n    });\r\n}());\r\n    \r\n\n\n//# sourceURL=webpack://platypus/./src/components/CollisionBasic.js?");

/***/ }),

/***/ "./src/components/CollisionFilter.js":
/*!*******************************************!*\
  !*** ./src/components/CollisionFilter.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * This component will listen for a particular collision message and, depending on a given entity.state attribute, retrigger the collision as another collision message.\r\n *\r\n * @namespace platypus.components\r\n * @class CollisionFilter\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n\r\n    var collidePos = function (state, event, collInfo) {\r\n            if (this.state.get(state)) {\r\n                this.trigger(event, collInfo);\r\n            }\r\n        },\r\n        collideNeg = function (state, event, collInfo) {\r\n            if (!this.state.get(state)) {\r\n                this.trigger(event, collInfo);\r\n            }\r\n        };\r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'CollisionFilter',\r\n        \r\n        properties: {\r\n            /**\r\n             * One or more collision events for which to listen. For example, if the state property is set to \"allergic\":\r\n             *\r\n                   {\r\n                       \"hitting-flowers\": \"sneeze\",\r\n                       // Listen for \"hitting-flowers\", and if the entity is \"allergic\", trigger a \"sneeze\" event.\r\n                    \r\n                       \"in-the-weeds\": \"cough\"\r\n                       // Another collision event that triggers \"cough\" if the entity is \"allergic\".\r\n                   }\r\n             *\r\n             * @property collisions\r\n             * @type Object\r\n             * @default {}\r\n             */\r\n            collisions: {},\r\n            \r\n            /**\r\n             * The entity state that should cause the following list of collisions to trigger events. If this state is not true, no events are triggered. To trigger events on the inverse of a state, place \"!\" before the state such as \"!allergic\".\r\n             *\r\n             * @property state\r\n             * @type String\r\n             * @default \"\"\r\n             */\r\n            state: \"\"\r\n        },\r\n        \r\n        initialize: function () {\r\n            var event      = \"\",\r\n                collisions = this.collisions,\r\n                state      = this.state;\r\n            \r\n            if (collisions) {\r\n                /**\r\n                 * Events defined by the `collisions` property trigger whenever collisions happen while in the defined state.\r\n                 *\r\n                 * @event *\r\n                 * @param collisionData {CollisionData} Information regarding the collision that occurred.\r\n                 */\r\n                if (state[0] === '!') {\r\n                    state = state.substring(1);\r\n                    for (event in collisions) {\r\n                        if (collisions.hasOwnProperty(event)) {\r\n                            this.addEventListener(event, collideNeg.bind(this.owner, state, collisions[event]));\r\n                        }\r\n                    }\r\n                } else {\r\n                    for (event in collisions) {\r\n                        if (collisions.hasOwnProperty(event)) {\r\n                            this.addEventListener(event, collidePos.bind(this.owner, state, collisions[event]));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/CollisionFilter.js?");

/***/ }),

/***/ "./src/components/CollisionGroup.js":
/*!******************************************!*\
  !*** ./src/components/CollisionGroup.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/**\r\n * This component groups other entities with this entity for collision checking. This is useful for carrying and moving platforms. It uses `EntityContainer` component messages if triggered to add to its collision list and also listens for explicit add/remove messages (useful in the absence of an `EntityContainer` component).\r\n *\r\n * @namespace platypus.components\r\n * @class CollisionGroup\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        id: 'CollisionGroup',\r\n        \r\n        initialize: function () {\r\n            this.solidEntities = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            \r\n            // These are used as return values for methods, but are instantiated here for recycling later.\r\n            this.collisionTypes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.shapes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.prevShapes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            \r\n            this.terrain  = null;\r\n            this.aabb     = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(this.owner.x, this.owner.y);\r\n            this.prevAABB = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(this.owner.x, this.owner.y);\r\n            this.filteredAABB = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\r\n\r\n            _Vector_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].assign(this.owner, 'position', 'x', 'y', 'z');\r\n            _Vector_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].assign(this.owner, 'previousPosition', 'previousX', 'previousY', 'previousZ');\r\n            this.owner.previousX = this.owner.previousX || this.owner.x;\r\n            this.owner.previousY = this.owner.previousY || this.owner.y;\r\n            \r\n            this.collisionGroup = this.owner.collisionGroup = {\r\n                getAllEntities: function () {\r\n                    var x           = 0,\r\n                        count       = 0,\r\n                        childEntity = null;\r\n                    \r\n                    for (x = 0; x < this.solidEntities.length; x++) {\r\n                        childEntity = this.solidEntities[x];\r\n                        if ((childEntity !== this.owner) && childEntity.collisionGroup) {\r\n                            count += childEntity.collisionGroup.getAllEntities();\r\n                        } else {\r\n                            count += 1;\r\n                        }\r\n                    }\r\n\r\n                    return count;\r\n                }.bind(this),\r\n                getSize: function () {\r\n                    return this.solidEntities.length;\r\n                }.bind(this),\r\n                getCollisionTypes: function () {\r\n                    return this.getCollisionTypes();\r\n                }.bind(this),\r\n                getSolidCollisions: function () {\r\n                    return this.getSolidCollisions();\r\n                }.bind(this),\r\n                getAABB: function (collisionType) {\r\n                    return this.getAABB(collisionType);\r\n                }.bind(this),\r\n                getPreviousAABB: function (collisionType) {\r\n                    return this.getPreviousAABB(collisionType);\r\n                }.bind(this),\r\n                getShapes: function (collisionType) {\r\n                    return this.getShapes(collisionType);\r\n                }.bind(this),\r\n                getPrevShapes: function (collisionType) {\r\n                    return this.getPrevShapes(collisionType);\r\n                }.bind(this),\r\n                prepareCollision: function (x, y) {\r\n                    return this.prepareCollision(x, y);\r\n                }.bind(this),\r\n                relocateEntity: function (vector, collisionData) {\r\n                    return this.relocateEntity(vector, collisionData);\r\n                }.bind(this),\r\n                movePreviousX: function (x) {\r\n                    return this.movePreviousX(x);\r\n                }.bind(this),\r\n                getSolidEntities: function () {\r\n                    return this.solidEntities;\r\n                }.bind(this),\r\n                jumpThrough: false //TODO: this introduces odd behavior - not sure how to resolve yet. - DDD\r\n            };\r\n        },\r\n        \r\n        events: {\r\n            /**\r\n             * On receiving this message, the component checks the entity to determine whether it listens for collision messages. If so, the entity is added to the collision group.\r\n             *\r\n             * @method 'child-entity-added'\r\n             * @param entity {platypus.Entity} The entity to be added.\r\n             */\r\n            \"child-entity-added\": function (entity) {\r\n                this.addCollisionEntity(entity);\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the component checks the entity to determine whether it listens for collision messages. If so, the entity is added to the collision group.\r\n             *\r\n             * @method 'add-collision-entity'\r\n             * @param entity {platypus.Entity} The entity to be added.\r\n             */\r\n            \"add-collision-entity\": function (entity) {\r\n                this.addCollisionEntity(entity);\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the component looks for the entity in its collision group and removes it.\r\n             *\r\n             * @method 'child-entity-removed'\r\n             * @param entity {platypus.Entity} The entity to be removed.\r\n             */\r\n            \"child-entity-removed\": function (entity) {\r\n                this.removeCollisionEntity(entity);\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the component looks for the entity in its collision group and removes it.\r\n             *\r\n             * @method 'remove-collision-entity'\r\n             * @param entity {platypus.Entity} The entity to be removed.\r\n             */\r\n            \"remove-collision-entity\": function (entity) {\r\n                this.removeCollisionEntity(entity);\r\n            },\r\n            \r\n            /**\r\n             * When this message is triggered, the collision group updates its record of the owner's last (x, y) coordinate.\r\n             *\r\n             * @method 'relocate-entity'\r\n             */\r\n            \"relocate-entity\": function () {\r\n                this.owner.previousPosition.setVector(this.owner.position);\r\n                this.updateAABB();\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            addCollisionEntity: function (entity) {\r\n                var i     = 0,\r\n                    types = entity.collisionTypes;\r\n                \r\n                if (types) {\r\n                    i = types.length;\r\n                    while (i--) {\r\n                        if (entity.solidCollisionMap.get(types[i]).length && !entity.immobile) {\r\n                            this.solidEntities[this.solidEntities.length] = entity;\r\n                        }\r\n                    }\r\n                    this.updateAABB();\r\n                }\r\n            },\r\n            \r\n            removeCollisionEntity: function (entity) {\r\n                var x     = 0,\r\n                    i     = 0,\r\n                    types = entity.collisionTypes;\r\n\r\n                if (types) {\r\n                    i = types.length;\r\n                    while (i--) {\r\n                        if (entity.solidCollisionMap.get(types[i]).length) {\r\n                            x = this.solidEntities.indexOf(entity);\r\n                            if (x >= 0) {\r\n                                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.solidEntities, x);\r\n                            }\r\n                        }\r\n                    }\r\n                    this.updateAABB();\r\n                }\r\n            },\r\n            \r\n            getCollisionTypes: function () {\r\n                var childEntity  = null,\r\n                    compiledList = this.collisionTypes,\r\n                    se = this.solidEntities,\r\n                    i = se.length;\r\n                \r\n                compiledList.length = 0;\r\n                \r\n                while (i--) {\r\n                    childEntity = se[i];\r\n                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {\r\n                        childEntity = childEntity.collisionGroup;\r\n                    }\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(compiledList, childEntity.getCollisionTypes());\r\n                }\r\n                \r\n                return compiledList;\r\n            },\r\n\r\n            getSolidCollisions: function () {\r\n                var x            = 0,\r\n                    key          = '',\r\n                    keys = null,\r\n                    childEntity  = null,\r\n                    compiledList = _DataMap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(),\r\n                    entityList   = null,\r\n                    i = 0,\r\n                    toList = null,\r\n                    fromList = null,\r\n                    recycle = false;\r\n                \r\n                for (x = 0; x < this.solidEntities.length; x++) {\r\n                    recycle = false;\r\n                    childEntity = this.solidEntities[x];\r\n                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {\r\n                        childEntity = childEntity.collisionGroup;\r\n                        recycle = true;\r\n                    }\r\n                    entityList = childEntity.getSolidCollisions();\r\n                    keys = entityList.keys;\r\n                    i = keys.length;\r\n                    while (i--) {\r\n                        key = keys[i];\r\n                        toList = compiledList.get(key);\r\n                        fromList = entityList.get(key);\r\n                        if (!toList) {\r\n                            toList = compiledList.set(key, _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp());\r\n                        }\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(toList, fromList);\r\n                        if (recycle) {\r\n                            fromList.recycle();\r\n                        }\r\n                    }\r\n                    if (recycle) {\r\n                        entityList.recycle();\r\n                    }\r\n                }\r\n                \r\n                return compiledList; // TODO: Track down where this is used and make sure the arrays are recycled. - DDD 2/1/2016\r\n            },\r\n            \r\n            getAABB: function (collisionType) {\r\n                var i = 0,\r\n                    aabb        = this.filteredAABB,\r\n                    childEntity = null,\r\n                    incAABB = null,\r\n                    sE = this.solidEntities;\r\n                \r\n                if (!collisionType) {\r\n                    return this.aabb;\r\n                } else {\r\n                    aabb.reset();\r\n                    i = sE.length;\r\n                    while (i--) {\r\n                        childEntity = sE[i];\r\n                        if ((childEntity !== this.owner) && childEntity.collisionGroup) {\r\n                            childEntity = childEntity.collisionGroup;\r\n                        }\r\n                        incAABB = childEntity.getAABB(collisionType);\r\n                        if (incAABB) {\r\n                            aabb.include(incAABB);\r\n                        }\r\n                    }\r\n                    return aabb;\r\n                }\r\n            },\r\n\r\n            getPreviousAABB: function (collisionType) {\r\n                var i = 0,\r\n                    aabb        = this.filteredAABB,\r\n                    childEntity = null,\r\n                    incAABB = null,\r\n                    sE = this.solidEntities;\r\n                \r\n                if (!collisionType) {\r\n                    return this.prevAABB;\r\n                } else {\r\n                    aabb.reset();\r\n                    i = sE.length;\r\n                    while (i--) {\r\n                        childEntity = sE[i];\r\n                        if ((childEntity !== this.owner) && childEntity.collisionGroup) {\r\n                            childEntity = childEntity.collisionGroup;\r\n                        }\r\n\r\n                        incAABB = childEntity.getPreviousAABB(collisionType);\r\n                        if (incAABB) {\r\n                            aabb.include(incAABB);\r\n                        }\r\n                    }\r\n                    return aabb;\r\n                }\r\n            },\r\n            \r\n            updateAABB: function () {\r\n                var aabb = this.aabb,\r\n                    sE = this.solidEntities,\r\n                    entity = null,\r\n                    x = sE.length,\r\n                    owner = this.owner;\r\n                \r\n                aabb.reset();\r\n                while (x--) {\r\n                    entity = sE[x];\r\n                    aabb.include(((entity !== owner) && entity.getCollisionGroupAABB) ? entity.getCollisionGroupAABB() : entity.getAABB());\r\n                }\r\n            },\r\n            \r\n            getShapes: function (collisionType) {\r\n                var x           = 0,\r\n                    childEntity = null,\r\n                    shapes      = this.shapes,\r\n                    newShapes   = null;\r\n                    \r\n                shapes.length = 0;\r\n                \r\n                for (x = 0; x < this.solidEntities.length; x++) {\r\n                    childEntity = this.solidEntities[x];\r\n                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {\r\n                        childEntity = childEntity.collisionGroup;\r\n                    }\r\n                    newShapes = childEntity.getShapes(collisionType);\r\n                    if (newShapes) {\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(shapes, newShapes);\r\n                    }\r\n                }\r\n                return shapes;\r\n            },\r\n\r\n            getPrevShapes: function (collisionType) {\r\n                var x           = 0,\r\n                    childEntity = null,\r\n                    newShapes   = null,\r\n                    shapes      = this.prevShapes;\r\n                    \r\n                shapes.length = 0;\r\n                \r\n                for (x = 0; x < this.solidEntities.length; x++) {\r\n                    childEntity = this.solidEntities[x];\r\n                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {\r\n                        childEntity = childEntity.collisionGroup;\r\n                    }\r\n                    newShapes = childEntity.getPrevShapes(collisionType);\r\n                    if (newShapes) {\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(shapes, newShapes);\r\n                    }\r\n                }\r\n                return shapes;\r\n            },\r\n            \r\n            prepareCollision: function (x, y) {\r\n                var i           = 0,\r\n                    childEntity = null,\r\n                    oX          = 0,\r\n                    oY          = 0;\r\n                \r\n                for (i = 0; i < this.solidEntities.length; i++) {\r\n                    childEntity = this.solidEntities[i];\r\n                    childEntity.saveDX = childEntity.x - childEntity.previousX;\r\n                    childEntity.saveDY = childEntity.y - childEntity.previousY;\r\n                    oX = childEntity.saveOX = this.owner.previousX - childEntity.previousX;\r\n                    oY = childEntity.saveOY = this.owner.previousY - childEntity.previousY;\r\n                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {\r\n                        childEntity = childEntity.collisionGroup;\r\n                    }\r\n                    childEntity.prepareCollision(x - oX, y - oY);\r\n                }\r\n            },\r\n            \r\n            movePreviousX: function (x) {\r\n                var childEntity = null,\r\n                    offset      = 0,\r\n                    i           = 0;\r\n                \r\n                for (i = 0; i < this.solidEntities.length; i++) {\r\n                    childEntity = this.solidEntities[i];\r\n                    offset = childEntity.saveOX;\r\n                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {\r\n                        childEntity = childEntity.collisionGroup;\r\n                    }\r\n                    childEntity.movePreviousX(x - offset);\r\n                }\r\n            },\r\n            \r\n            relocateEntity: function (vector, collisionData) {\r\n                var childEntity = null,\r\n                    entity      = null,\r\n                    i           = 0,\r\n                    list        = null,\r\n                    owner       = this.owner,\r\n                    solids      = this.solidEntities,\r\n                    v           = null;\r\n                \r\n                owner.saveDX -= vector.x - owner.previousX;\r\n                owner.saveDY -= vector.y - owner.previousY;\r\n\r\n                list = collisionData.xData;\r\n                i = list.length;\r\n                while (i--) {\r\n                    if (list[i].thisShape.owner === owner) {\r\n                        owner.saveDX = 0;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                list = collisionData.yData;\r\n                i = list.length;\r\n                while (i--) {\r\n                    if (list[i].thisShape.owner === owner) {\r\n                        owner.saveDY = 0;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                for (i = 0; i < solids.length; i++) {\r\n                    childEntity = entity = solids[i];\r\n                    if ((childEntity !== owner) && childEntity.collisionGroup) {\r\n                        childEntity = childEntity.collisionGroup;\r\n                    }\r\n                    v = _Vector_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setUp(vector.x - entity.saveOX, vector.y - entity.saveOY, childEntity.z);\r\n                    childEntity.relocateEntity(v, collisionData);\r\n                    v.recycle();\r\n                    entity.x += entity.saveDX;\r\n                    entity.y += entity.saveDY;\r\n                    if (entity !== owner) {\r\n                        entity.x += owner.saveDX;\r\n                        entity.y += owner.saveDY;\r\n                    }\r\n                }\r\n            },\r\n\r\n            destroy: function () {\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.solidEntities);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.collisionTypes);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.shapes);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.prevShapes);\r\n                this.aabb.recycle();\r\n                this.prevAABB.recycle();\r\n                this.filteredAABB.recycle();\r\n            }\r\n        },\r\n        \r\n        publicMethods: {\r\n            /**\r\n             * Gets the bounding box of the group of entities.\r\n             *\r\n             * @method getCollisionGroupAABB\r\n             * @return platypus.AABB\r\n             */\r\n            getCollisionGroupAABB: function () {\r\n                return this.getAABB();\r\n            },\r\n            \r\n            /**\r\n             * Gets a list of all the entities in the world.\r\n             *\r\n             * @method getWorldEntities\r\n             * @return Array\r\n             */\r\n            getWorldEntities: function () {\r\n                return this.owner.parent.getWorldEntities();\r\n            },\r\n            \r\n            /**\r\n             * Gets the collision entity representing the world's terrain.\r\n             *\r\n             * @method getWorldTerrain\r\n             * @return platypus.Entity\r\n             */\r\n            getWorldTerrain: function () {\r\n                return this.owner.parent.getWorldTerrain();\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/CollisionGroup.js?");

/***/ }),

/***/ "./src/components/CollisionTiles.js":
/*!******************************************!*\
  !*** ./src/components/CollisionTiles.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _CollisionShape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CollisionShape.js */ \"./src/CollisionShape.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n * This component causes the tile-map to collide with other entities. It must be part of a collision group and will cause \"hit-by-tile\" messages to fire on colliding entities.\r\n *\r\n * @namespace platypus.components\r\n * @class CollisionTiles\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var maskJumpThrough = 0x10000000,\r\n        maskRotation = 0x20000000,\r\n        maskXFlip = 0x80000000,\r\n        maskYFlip = 0x40000000,\r\n        maskIndex = 0x0fffffff,\r\n        getDefaultType = function () {\r\n            return this.collisionType;\r\n        },\r\n        getCollisionType = function (index) {\r\n            return this.collisionTypeMap[index & maskIndex] || this.collisionType;\r\n        },\r\n        flipDiagonal = function (num) {\r\n            if (num === 0) {\r\n                return num;\r\n            } else {\r\n                return num ^ maskYFlip ^ maskRotation;\r\n            }\r\n        },\r\n        flipDiagonalInverse = function (num) {\r\n            if (num === 0) {\r\n                return num;\r\n            } else {\r\n                return num ^ maskXFlip ^ maskRotation;\r\n            }\r\n        },\r\n        flipX = function (num) {\r\n            if (num === 0) {\r\n                return num;\r\n            } else {\r\n                return num ^ maskXFlip;\r\n            }\r\n        },\r\n        flipY = function (num) {\r\n            if (num === 0) {\r\n                return num;\r\n            } else {\r\n                return num ^ maskYFlip;\r\n            }\r\n        },\r\n        rotate90 = function (num) {\r\n            if (num === 0) {\r\n                return num;\r\n            } else if (maskRotation & num) {\r\n                return num ^ maskYFlip ^ maskRotation;\r\n            } else {\r\n                return num ^ maskXFlip ^ maskRotation;\r\n            }\r\n        },\r\n        rotate180 = function (num) {\r\n            if (num === 0) {\r\n                return num;\r\n            } else {\r\n                return num ^ maskXFlip ^ maskYFlip;\r\n            }\r\n        },\r\n        rotate270 = function (num) {\r\n            if (num === 0) {\r\n                return num;\r\n            } else if (maskRotation & num) {\r\n                return num ^ maskXFlip ^ maskRotation;\r\n            } else {\r\n                return num ^ maskYFlip ^ maskRotation;\r\n            }\r\n        },\r\n        copySection = function (array, originX, originY, width, height) {\r\n            var x   = 0,\r\n                y   = 0,\r\n                arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].setUp();\r\n\r\n            for (y = 0; y < height; y++) {\r\n                arr[y] = _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].setUp();\r\n                for (x = 0; x < width; x++) {\r\n                    arr[y][x] = array[originX + x][originY + y];\r\n                }\r\n            }\r\n            return arr;\r\n        },\r\n        cutSection = function (array, originX, originY, width, height) {\r\n            var x   = 0,\r\n                y   = 0,\r\n                arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].setUp();\r\n\r\n            for (y = 0; y < height; y++) {\r\n                arr[y] = _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].setUp();\r\n                for (x = 0; x < width; x++) {\r\n                    arr[y][x] = array[originX + x][originY + y];\r\n                    array[originX + x][originY + y] = -1;\r\n                }\r\n            }\r\n            return arr;\r\n        },\r\n        pasteSection = function (destinationArray, sourceArray, originX, originY, width, height) {\r\n            var x = 0,\r\n                y = 0;\r\n\r\n            for (y = 0; y < height; y++) {\r\n                for (x = 0; x < width; x++) {\r\n                    destinationArray[originX + x][originY + y] = sourceArray[y][x];\r\n                }\r\n            }\r\n            return destinationArray;\r\n        },\r\n        transforms = {\r\n            \"diagonal\": function (array, originX, originY, width, height) {\r\n                var arr   = copySection(array, originX, originY, width, height),\r\n                    fD    = flipDiagonal,\r\n                    x     = 0,\r\n                    y     = 0;\r\n\r\n                for (x = 0; x < width; x++) {\r\n                    for (y = 0; y < height; y++) {\r\n                        array[originX + x][originY + y] = fD(arr[x][y]);\r\n                    }\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\r\n                return array;\r\n            },\r\n            \"diagonal-inverse\": function (array, originX, originY, width, height) {\r\n                var arr   = copySection(array, originX, originY, width, height),\r\n                    fDI   = flipDiagonalInverse,\r\n                    x     = 0,\r\n                    y     = 0;\r\n\r\n                for (x = 0; x < width; x++) {\r\n                    for (y = 0; y < height; y++) {\r\n                        array[originX + width - x - 1][originY + height - y - 1] = fDI(arr[x][y]);\r\n                    }\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\r\n                return array;\r\n            },\r\n            \"horizontal\": function (array, originX, originY, width, height) {\r\n                var arr   = copySection(array, originX, originY, width, height),\r\n                    fX    = flipX,\r\n                    x     = 0,\r\n                    y     = 0;\r\n\r\n                for (y = 0; y < height; y++) {\r\n                    for (x = 0; x < width; x++) {\r\n                        array[originX + width - x - 1][originY + y] = fX(arr[y][x]);\r\n                    }\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\r\n                return array;\r\n            },\r\n            \"vertical\": function (array, originX, originY, width, height) {\r\n                var arr   = copySection(array, originX, originY, width, height),\r\n                    fY    = flipY,\r\n                    x     = 0,\r\n                    y     = 0;\r\n\r\n                for (y = 0; y < height; y++) {\r\n                    for (x = 0; x < width; x++) {\r\n                        array[originX + x][originY + height - y - 1] = fY(arr[y][x]);\r\n                    }\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\r\n                return array;\r\n            },\r\n            \"rotate-90\": function (array, originX, originY, width, height) {\r\n                var arr   = copySection(array, originX, originY, width, height),\r\n                    r90   = rotate90,\r\n                    x     = 0,\r\n                    y     = 0;\r\n\r\n                for (y = 0; y < height; y++) {\r\n                    for (x = 0; x < width; x++) {\r\n                        array[originX + height - y - 1][originY + x] = r90(arr[y][x]);\r\n                    }\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\r\n                return array;\r\n            },\r\n            \"rotate-180\": function (array, originX, originY, width, height) {\r\n                var arr   = copySection(array, originX, originY, width, height),\r\n                    r180  = rotate180,\r\n                    x     = 0,\r\n                    y     = 0;\r\n\r\n                for (y = 0; y < height; y++) {\r\n                    for (x = 0; x < width; x++) {\r\n                        array[originX + width - x - 1][originY + height - y - 1] = r180(arr[y][x]);\r\n                    }\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\r\n                return array;\r\n            },\r\n            \"rotate-270\": function (array, originX, originY, width, height) {\r\n                var arr   = copySection(array, originX, originY, width, height),\r\n                    r270  = rotate270,\r\n                    x     = 0,\r\n                    y     = 0;\r\n\r\n                for (y = 0; y < height; y++) {\r\n                    for (x = 0; x < width; x++) {\r\n                        array[originX + y][originY + width - x - 1] = r270(arr[y][x]);\r\n                    }\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\r\n                return array;\r\n            },\r\n            \"translate\": function (array, originX, originY, width, height, dx, dy) {\r\n                var arr = cutSection(array, originX, originY, width, height),\r\n                    x   = 0,\r\n                    y   = 0;\r\n\r\n                for (y = 0; y < height; y++) {\r\n                    for (x = 0; x < width; x++) {\r\n                        array[originX + x + dx][originY + y + dy] = arr[y][x];\r\n                    }\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(arr, 2);\r\n                return array;\r\n            }\r\n        };\r\n\r\n    return platypus.createComponentClass({\r\n        id: 'CollisionTiles',\r\n        \r\n        properties: {\r\n            /**\r\n             * Maps tile indexes to particular collision types. This defaults to a \"tiles\" collision type for all non-zero values if a particular collision map is not provided.\r\n             *\r\n             * @property collisionTypeMap\r\n             * @type Object\r\n             * @default null\r\n             * @since 0.8.3\r\n             */\r\n            collisionTypeMap: null,\r\n            \r\n            /**\r\n             * Sets the default collision type for non-zero map tiles.\r\n             *\r\n             * @property collisionType\r\n             * @type String\r\n             * @default \"tiles\"\r\n             * @since 0.8.3\r\n             */\r\n            collisionType: 'tiles',\r\n            \r\n            /**\r\n             * The map's top offset.\r\n             *\r\n             * @property top\r\n             * @type Number\r\n             * @default 0\r\n             * @since 0.7.5\r\n             */\r\n            top: 0,\r\n            \r\n            /**\r\n             * The map's left offset.\r\n             *\r\n             * @property left\r\n             * @type Number\r\n             * @default 0\r\n             * @since 0.7.5\r\n             */\r\n            left: 0\r\n        },\r\n        \r\n        publicProperties: {\r\n            /**\r\n             * A 2D array describing the tile-map with off (0) and on (!0) states. The indexes match Tiled map data indexes with an additional bit setting (0x2000000) for jumpthrough tiles. Example: `[[0, 0, 0], [1, 0, 0], [1, 1, 1]]`. Available on the entity as `entity.collisionMap`.\r\n             *\r\n             * @property collisionMap\r\n             * @type Array\r\n             * @default []\r\n             */\r\n            collisionMap: [],\r\n            \r\n            /**\r\n             * The width of tiles in world coordinates. Available on the entity as `entity.tileWidth`.\r\n             *\r\n             * @property tileWidth\r\n             * @type number\r\n             * @default 10\r\n             */\r\n            tileWidth: 10,\r\n\r\n            /**\r\n             * The height of tiles in world coordinates. Available on the entity as `entity.tileHeight`.\r\n             *\r\n             * @property tileWidth\r\n             * @type number\r\n             * @default 10\r\n             */\r\n            tileHeight: 10\r\n        },\r\n        initialize: function () {\r\n            this.tileOffsetLeft  = this.tileWidth / 2 + this.left;\r\n            this.tileOffsetTop = this.tileHeight / 2 + this.top;\r\n            \r\n            this.columns = this.collisionMap.length;\r\n            this.rows = this.collisionMap[0].length;\r\n            \r\n            this.shapeDefinition = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                \"x\", 0,\r\n                \"y\", 0,\r\n                \"type\", 'rectangle',\r\n                \"width\", this.tileWidth,\r\n                \"height\", this.tileHeight\r\n            );\r\n            \r\n            this.storedTiles = _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].setUp();\r\n            this.serveTiles = _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].setUp();\r\n            this.storedTileIndex = 0;\r\n            \r\n            this.aabb = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\r\n            this.aabb.setBounds(this.left, this.top, this.tileWidth * this.columns + this.left, this.tileHeight * this.rows + this.top);\r\n            \r\n            if (this.collisionTypeMap) {\r\n                this.getType = getCollisionType;\r\n            } else {\r\n                this.getType = getDefaultType;\r\n            }\r\n        },\r\n        \r\n        events: {\r\n            /**\r\n             * Performs a transform of a subset of the collision tile grid.\r\n             *\r\n             * @method 'transform'\r\n             * @param [transform] {Object} A list of key/value pairs describing the transform.\r\n             * @param [transform.type=\"horizontal\"] {String} The type of transform; one of the following: \"horizontal\", \"vertical\", \"diagonal\", \"diagonal-inverse\", \"rotate-90\", \"rotate-180\", \"rotate-270\". Height and width should match for diagonal flips and 90 degree rotations.\r\n             * @param [transform.left=0] {number} Grid coordinate for the left side of the bounding box.\r\n             * @param [transform.top=0] {number} Grid coordinate for the top of the bounding box.\r\n             * @param [transform.width=grid.width] {number} Cell width of the bounding box.\r\n             * @param [transform.height=grid.height] {number} Cell height of the bounding box.\r\n             */\r\n            \"transform\": function (transform) {\r\n                this.transform(transform);\r\n            },\r\n\r\n            /**\r\n             * Performs a translation of a subset of the collision tile grid.\r\n             *\r\n             * @method 'translate'\r\n             * @param [translate] {Object} A list of key/value pairs describing the translation.\r\n             * @param [translate.dx=0] {number} Movement in columns.\r\n             * @param [translate.dy=0] {number} Movement in rows.\r\n             * @param [translate.left=0] {number} Grid coordinate for the left side of the bounding box.\r\n             * @param [translate.top=0] {number} Grid coordinate for the top of the bounding box.\r\n             * @param [translate.width=grid.width] {number} Cell width of the bounding box.\r\n             * @param [translate.height=grid.height] {number} Cell height of the bounding box.\r\n             */\r\n            \"translate\": function (translate) {\r\n                this.translate(translate);\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            getShape: function (x, y, type) {\r\n                var i = this.storedTileIndex,\r\n                    shape = null,\r\n                    storedTiles = this.storedTiles;\r\n                \r\n                if (i === storedTiles.length) {\r\n                    shape = _CollisionShape_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(null, this.shapeDefinition, type);\r\n                    storedTiles.push(shape);\r\n                } else {\r\n                    shape = storedTiles[i];\r\n                    shape.collisionType = type;\r\n                }\r\n                \r\n                shape.update(x * this.tileWidth + this.tileOffsetLeft, y * this.tileHeight + this.tileOffsetTop);\r\n\r\n                this.storedTileIndex += 1;\r\n                \r\n                return shape;\r\n            },\r\n            \r\n            addShape: function (shapes, prevAABB, x, y, collisionType) {\r\n                var xy = this.collisionMap[x][y],\r\n                    index = xy & maskIndex,\r\n                    jumpThrough = maskJumpThrough,\r\n                    rotation = maskRotation,\r\n                    xFlip = maskXFlip,\r\n                    yFlip = maskYFlip;\r\n                \r\n                if (xy && (this.getType(index) === collisionType)) {\r\n                    jumpThrough &= xy;\r\n                    if (jumpThrough) {\r\n                        rotation &= xy;\r\n                        xFlip &= xy;\r\n                        yFlip &= xy;\r\n                        if (rotation && xFlip) { // Right\r\n                            if (prevAABB.left >= (x + 1) * this.tileWidth + this.left) {\r\n                                shapes.push(this.getShape(x, y, collisionType));\r\n                            }\r\n                        } else if (rotation) { // Left\r\n                            if (prevAABB.right <= x * this.tileWidth + this.left) {\r\n                                shapes.push(this.getShape(x, y, collisionType));\r\n                            }\r\n                        } else if (yFlip) { // Bottom\r\n                            if (prevAABB.top >= (y + 1) * this.tileHeight + this.top) {\r\n                                shapes.push(this.getShape(x, y, collisionType));\r\n                            }\r\n                        } else if (prevAABB.bottom <= y * this.tileHeight + this.top) { // Top\r\n                            shapes.push(this.getShape(x, y, collisionType));\r\n                        }\r\n                    } else {\r\n                        shapes.push(this.getShape(x, y, collisionType));\r\n                    }\r\n                }\r\n\r\n                return shapes;\r\n            },\r\n            \r\n            destroy: function () {\r\n                var store = this.storedTiles,\r\n                    i = store.length;\r\n                \r\n                this.shapeDefinition.recycle();\r\n                this.shapeDefinition = null;\r\n                \r\n                while (i--) {\r\n                    store[i].recycle();\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(store);\r\n                this.storedTiles = null;\r\n\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_3__[\"arrayCache\"].recycle(this.serveTiles);\r\n                this.serveTiles = null;\r\n                \r\n                this.aabb.recycle();\r\n                this.aabb = null;\r\n            }\r\n        },\r\n        \r\n        publicMethods: {\r\n            /**\r\n             * Returns the axis-aligned bounding box of the entire map.\r\n             *\r\n             * @method getAABB\r\n             * @return aabb {platypus.AABB} The returned object provides the top, left, width, and height of the collision map.\r\n             */\r\n            getAABB: function () {\r\n                return this.aabb;\r\n            },\r\n            \r\n            /**\r\n             * Confirms whether a particular map grid coordinate contains a tile.\r\n             *\r\n             * @method isTile\r\n             * @param x {number} Integer specifying the column of tiles in the collision map to check.\r\n             * @param y {number} Integer specifying the row of tiles in the collision map to check.\r\n             * @return {boolean} Returns `true` if the coordinate contains a collision tile, `false` if it does not.\r\n             */\r\n            isTile: function (x, y) {\r\n                return !((x < 0) || (y < 0) || (x >= this.columns) || (y >= this.rows) || (this.collisionMap[x][y] === -1));\r\n            },\r\n            \r\n            /**\r\n             * Returns all the collision tiles within the provided axis-aligned bounding box as an array of shapes.\r\n             *\r\n             * @method getTileShapes\r\n             * @param aabb {platypus.AABB} The axis-aligned bounding box for which tiles should be returned.\r\n             * @param prevAABB {platypus.AABB} The axis-aligned bounding box for a previous location to test for jump-through tiles.\r\n             * @param [collisionType] {String} The type of collision to check for. If not specified, \"tiles\" is used. (Since 0.8.3)\r\n             * @return {Array} Each returned object provides the [CollisionShape](CollisionShape.html) of a tile.\r\n             */\r\n            getTileShapes: function (aabb, prevAABB, collisionType) {\r\n                var colType = collisionType || 'tiles',\r\n                    l = this.left,\r\n                    t = this.top,\r\n                    th = this.tileHeight,\r\n                    tw = this.tileWidth,\r\n                    left   = Math.max(Math.floor((aabb.left - l) / tw),  0),\r\n                    top    = Math.max(Math.floor((aabb.top - t) / th), 0),\r\n                    right  = Math.min(Math.ceil((aabb.right - l) / tw),  this.columns),\r\n                    bottom = Math.min(Math.ceil((aabb.bottom - t) / th), this.rows),\r\n                    x      = 0,\r\n                    y      = 0,\r\n                    shapes = this.serveTiles;\r\n                \r\n                shapes.length = 0;\r\n                this.storedTileIndex = 0;\r\n                \r\n                for (x = left; x < right; x++) {\r\n                    for (y = top; y < bottom; y++) {\r\n                        this.addShape(shapes, prevAABB, x, y, colType);\r\n                    }\r\n                }\r\n                \r\n                return shapes;\r\n            },\r\n            \r\n            /**\r\n             * Performs a transform of a subset of the collision tile grid.\r\n             *\r\n             * @method transform\r\n             * @param [transform] {Object} A list of key/value pairs describing the transform.\r\n             * @param [transform.type=\"horizontal\"] {String} The type of transform; one of the following: \"horizontal\", \"vertical\", \"diagonal\", \"diagonal-inverse\", \"rotate-90\", \"rotate-180\", \"rotate-270\". Height and width should match for diagonal flips and 90 degree rotations.\r\n             * @param [transform.left=0] {number} Grid coordinate for the left side of the bounding box.\r\n             * @param [transform.top=0] {number} Grid coordinate for the top of the bounding box.\r\n             * @param [transform.width=grid.width] {number} Cell width of the bounding box.\r\n             * @param [transform.height=grid.height] {number} Cell height of the bounding box.\r\n             */\r\n            transform: function (transform) {\r\n                var t      = transform || {},\r\n                    x      = t.left    || 0,\r\n                    y      = t.top     || 0,\r\n                    width  = t.width   || this.rows,\r\n                    height = t.height  || this.columns,\r\n                    type   = t.type    || \"horizontal\";\r\n                \r\n                if (transforms[type]) {\r\n                    return transforms[type](this.collisionMap, x, y, width, height);\r\n                } else {\r\n                    return null;\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * Performs a translation of a subset of the collision tile grid.\r\n             *\r\n             * @method translate\r\n             * @param [translate] {Object} A list of key/value pairs describing the translation.\r\n             * @param [translate.dx=0] {number} Movement in columns.\r\n             * @param [translate.dy=0] {number} Movement in rows.\r\n             * @param [translate.left=0] {number} Grid coordinate for the left side of the bounding box.\r\n             * @param [translate.top=0] {number} Grid coordinate for the top of the bounding box.\r\n             * @param [translate.width=grid.width] {number} Cell width of the bounding box.\r\n             * @param [translate.height=grid.height] {number} Cell height of the bounding box.\r\n             */\r\n            translate: function (translate) {\r\n                var t      = translate || {},\r\n                    x      = t.left    || 0,\r\n                    y      = t.top     || 0,\r\n                    width  = t.width   || this.rows,\r\n                    height = t.height  || this.columns,\r\n                    dx     = t.dx      || 0,\r\n                    dy     = t.dy      || 0;\r\n                \r\n                return transforms.translate(this.collisionMap, x, y, width, height, dx, dy);\r\n            },\r\n            \r\n            /**\r\n             * Gets a subset of the collision tile grid as a 2D array.\r\n             *\r\n             * @method getCollisionMatrix\r\n             * @param originX {number} Grid coordinate for the left side of the bounding box.\r\n             * @param originY {number} Grid coordinate for the top of the bounding box.\r\n             * @param width {number} Cell width of the bounding box.\r\n             * @param height {number} Cell height of the bounding box.\r\n             * @return {Array}\r\n             */\r\n            getCollisionMatrix: function (originX, originY, width, height) {\r\n                return copySection(this.collisionMap, originX, originY, width, height);\r\n            },\r\n            \r\n            /**\r\n             * Sets a subset of the collision tile grid.\r\n             *\r\n             * @method setCollisionMatrix\r\n             * @param sourceArray {Array} A 2D array describing the collision tiles to insert into the collision tile grid.\r\n             * @param originX {number} Grid coordinate for the left side of the bounding box.\r\n             * @param originY {number} Grid coordinate for the top of the bounding box.\r\n             * @param width {number} Cell width of the bounding box.\r\n             * @param height {number} Cell height of the bounding box.\r\n             */\r\n            setCollisionMatrix: function (sourceArray, originX, originY, width, height) {\r\n                return pasteSection(this.collisionMap, sourceArray, originX, originY, width, height);\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/CollisionTiles.js?");

/***/ }),

/***/ "./src/components/ComponentSwitcher.js":
/*!*********************************************!*\
  !*** ./src/components/ComponentSwitcher.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n * This component listens for messages and, according to its preset settings, will remove and add components to the entity. This is useful if certain events should modify the behavior of the entity in some way: for example, acquiring a pogo-stick might add a jumping component so the hero can jump.\r\n *\r\n * @namespace platypus.components\r\n * @class ComponentSwitcher\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var\r\n        addSwitch = function (event) {\r\n            this.switches.push(event);\r\n        };\r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'ComponentSwitcher',\r\n        \r\n        properties: {\r\n            /**\r\n             * This is the list of messages to listen for (as the keys) with the settings as two arrays of components to add and components to remove.\r\n             *\r\n                {\r\n                    \"found-pogostick\":{\r\n                      \"add\":[\r\n                      // This is a list of components to add when \"found-pogostick\" is triggered on the entity. If it's adding a single component, \"add\" can be a reference to the component definition itself rather than an array of one object.\r\n                        {\"type\": \"Mover\"},\r\n                        {\"type\": \"HeadGear\"}\r\n                      ]\r\n                      \r\n                      \"remove\": [\"CarSeat\"]\r\n                      // This is a string list of component ids to remove when \"found-pogostick\" is triggered on the entity. It will ignore listed components that are not connected to the entity.\r\n                    },\r\n                    \r\n                    // Multiple events can cause unique components to be added or removed\r\n                    \"walking-indoors\":{\r\n                      \"remove\": [\"HeadGear\"]\r\n                    },\r\n                    \r\n                    \"contemplate\":{\r\n                      \"add\": {\"type\": \"AIPacer\"}\r\n                    }\r\n                  }\r\n                }\r\n             *\r\n             * @property componentMap\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            componentMap: null\r\n        },\r\n        \r\n        initialize: function () {\r\n            var event = '';\r\n            \r\n            this.switches = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(); // The list of switches to make.\r\n            \r\n            if (this.componentMap) {\r\n                for (event in this.componentMap) {\r\n                    if (this.componentMap.hasOwnProperty(event)) {\r\n                        /**\r\n                         * Message(s) listed by `componentMap` will add or remove components.\r\n                         *\r\n                         * @method '*'\r\n                         */\r\n                        this.addEventListener(event, addSwitch.bind(this, event));\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        events: {\r\n            /**\r\n             * This component handles component-switching on this call so that it doesn't interfere with the \"handle-logic\" loop.\r\n             *\r\n             * @method 'prepare-logic'\r\n             */\r\n            \"prepare-logic\": function () {\r\n                var i = 0;\r\n                \r\n                if (this.switches.length) {\r\n                    for (i = 0; i < this.switches.length; i++) {\r\n                        this.switchComponents(this.componentMap[this.switches[i]]);\r\n                    }\r\n                    this.switches.length = 0;\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            switchComponents: function (definition) {\r\n                var i = 0,\r\n                    j = 0,\r\n                    owner = this.owner,\r\n                    components = owner.components,\r\n                    remove = definition.remove,\r\n                    add = definition.add;\r\n                    \r\n                if (remove) {\r\n                    if (!Array.isArray(remove)) {\r\n                        for (i = components.length - 1; i > -1; i--) {\r\n                            if (components[i].type === remove) {\r\n                                owner.removeComponent(components[i]);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        for (i = 0; i < remove.length; i++) {\r\n                            for (j = components.length - 1; j > -1; j--) {\r\n                                if (components[j].type === remove[i]) {\r\n                                    owner.removeComponent(components[j]);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (add) {\r\n                    if (!Array.isArray(add)) {\r\n                        owner.addComponent(new platypus.components[add.type](owner, add));\r\n                    } else {\r\n                        for (i = 0; i < add.length; i++) {\r\n                            owner.addComponent(new platypus.components[add[i].type](owner, add[i]));\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                /**\r\n                * This message is triggered on the parent when the entity's components change.\r\n                *\r\n                * @event 'child-entity-updated'\r\n                * @param entity {platypus.Entity} This is the entity itself.\r\n                */\r\n                owner.parent.triggerEvent('child-entity-updated', owner);\r\n\r\n                /**\r\n                * This message is triggered on the entity itself when its components change.\r\n                *\r\n                * @event 'add-remove-component-complete'\r\n                */\r\n                owner.triggerEvent('add-remove-component-complete');\r\n            },\r\n            \r\n            destroy: function () {\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.switches);\r\n            }\r\n        },\r\n        \r\n        getAssetList: function (def, props, defaultProps) {\r\n            var map = def.componentMap || props.componentMap || defaultProps.componentMap,\r\n                event = '',\r\n                i = 0,\r\n                component = null,\r\n                assets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                arr = null;\r\n            \r\n            for (event in map) {\r\n                if (map.hasOwnProperty(event)) {\r\n                    for (i = 0; i < map[event].add.length; i++) {\r\n                        component = platypus.components[map[event].add[i].type];\r\n                        if (component) {\r\n                            arr = component.getAssetList(map[event].add[i], props, defaultProps);\r\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\r\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            return assets;\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/ComponentSwitcher.js?");

/***/ }),

/***/ "./src/components/Counter.js":
/*!***********************************!*\
  !*** ./src/components/Counter.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/**\r\n * A simple component that keeps count of something and sends messages each time the count changes. Can also have a total. When it does it will display 'count / total'.\r\n *\r\n * @namespace platypus.components\r\n * @class Counter\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n\r\n        id: 'Counter',\r\n\r\n        publicProperties: {\r\n            /**\r\n             * A total the counter is incrementing toward.\r\n             *\r\n             * @property total\r\n             * @type number\r\n             * @default 0\r\n             */\r\n            total: 0\r\n        },\r\n\r\n        initialize: function () {\r\n            this.count = 0;\r\n            this.lastTotal = 0;\r\n            this.lastCount = 0;\r\n            this.message = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(\r\n                \"text\", \"\"\r\n            );\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * Each step, this component detects whether the count has changed and triggers an 'update-content' event if so.\r\n             *\r\n             * @method 'handle-logic'\r\n             */\r\n            \"handle-logic\": function () {\r\n                var update  = false,\r\n                    msg = this.message;\r\n                \r\n                if (this.total !== this.lastTotal) {\r\n                    this.lastTotal = this.total;\r\n                    update = true;\r\n                }\r\n                \r\n                if (this.count !== this.lastCount) {\r\n                    this.lastCount = this.count;\r\n                    update = true;\r\n                }\r\n                \r\n                if (update) {\r\n                    if (this.total) {\r\n                        msg.text = String(this.count) + \"/\" + String(this.total);\r\n                    } else {\r\n                        msg.text = String(this.count);\r\n                    }\r\n                    \r\n                    /**\r\n                     * A call used to notify other components that the count or total has changed.\r\n                     *\r\n                     * @event 'update-content'\r\n                     * @param update.text {string} String describing the current count.\r\n                     */\r\n                    this.owner.triggerEvent('update-content', msg);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Changes the total to the given value.\r\n             *\r\n             * @method 'change-total'\r\n             * @param data.total {number} The new total value.\r\n             */\r\n            \"change-total\": function (total) {\r\n                this.total = total;\r\n            },\r\n\r\n            /**\r\n             * Changes the count to the given value.\r\n             *\r\n             * @method 'change-count'\r\n             * @param data.count {number} The new count value.\r\n             */\r\n            \"change-count\": function (count) {\r\n                this.count = count;\r\n            },\r\n\r\n            /**\r\n             * Increments the count by 1.\r\n             *\r\n             * @method 'increment-count'\r\n             */\r\n            \"increment-count\": function () {\r\n                this.count += 1;\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                this.message.recycle();\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/Counter.js?");

/***/ }),

/***/ "./src/components/EntityContainer.js":
/*!*******************************************!*\
  !*** ./src/components/EntityContainer.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Async_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Async.js */ \"./src/Async.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var _Messenger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Messenger.js */ \"./src/Messenger.js\");\n/**\r\n * This component allows the entity to contain child entities. It will add several methods to the entity to manage adding and removing entities.\r\n *\r\n * @namespace platypus.components\r\n * @class EntityContainer\r\n * @extends platypus.Messenger\r\n * @uses platypus.Component\r\n */\r\n/**\r\n### Local Broadcasts:\r\n- **child-entity-added** - This message is triggered when a new entity has been added to the list of children entities.\r\n  - @param message ([[Entity]] object) - The entity that was just added.\r\n- **child-entity-removed** - This message is triggered when an entity has been removed from the list of children entities.\r\n  - @param message ([[Entity]] object) - The entity that was just removed.\r\n\r\n### Child Broadcasts:\r\n- **peer-entity-added** - This message is triggered when a new entity has been added to the parent's list of children entities.\r\n  - @param message ([[Entity]] object) - The entity that was just added.\r\n- **peer-entity-removed** - This message is triggered when an entity has been removed from the parent's list of children entities.\r\n  - @param message ([[Entity]] object) - The entity that was just removed.\r\n- **[Messages specified in definition]** - Listens for specified messages and on receiving them, re-triggers them on child entities.\r\n  - @param message (object) - sends the message object received by the original message.\r\n\r\n## Entity Methods:\r\n- **addEntity** -  This method will add the provided entity to this component's list of entities.\r\n  - @param entity ([[Entity]] object) - Required. This is the entity to be added as a child.\r\n  - @return entity ([[Entity]] object) - Returns the entity that was just added.\r\n- **removeEntity** - This method will remove the provided entity from the list of child entities.\r\n  - @param message ([[Entity]] object) - Required. The entity to remove.\r\n  - @return entity ([[Entity]] object | false) - Returns the entity that was just removed. If the entity was not foudn as a child, `false` is returned, indicated that the provided entity was not a child of this entity.\r\n- **getEntitiesByType** - This method will return all child entities (including grandchildren) that match the provided type.\r\n  - @param type (string) - Required. The entity type to find.\r\n  - @return entities (Array of [[Entity]] objects) - Returns the entities that match the specified entity type.\r\n- **getEntityById** - This method will return the first child entity it finds with a matching id (including grandchildren).\r\n  - @param id (string) - Required. The entity id to find.\r\n  - @return entity ([[Entity]] object) - Returns the entity that matches the specified entity id.\r\n- **triggerOnChildren** - This method is used by both internal components and external entities to trigger messages on the child entities.\r\n  - @param event (variant) - This is the message(s) to process. This can be a string, an object containing an \"event\" property (and optionally a \"message\" property, overriding the value below), or an array of the same.\r\n  - @param value (variant) - This is a message object or other value to pass along to component functions.\r\n  - @param debug (boolean) - This flags whether to output message contents and subscriber information to the console during game development. A \"value\" object parameter (above) will also set this flag if value.debug is set to true.\r\n  - @return integer - The number of handlers for the triggered message: this is useful for determining how many child entities care about a given message.\r\n- **triggerEvent** - This method is used by both internal components and external entities to trigger messages on the child entities.\r\n  - @param event (string) - This is the message to process.\r\n  - @param value (variant) - This is a message object or other value to pass along to component functions.\r\n  - @param debug (boolean) - This flags whether to output message contents and subscriber information to the console during game development. A \"value\" object parameter (above) will also set this flag if value.debug is set to true.\r\n  - @return integer - The number of handlers for the triggered message: this is useful for determining how many child entities care about a given message.\r\n*/\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var childBroadcast = function (event) {\r\n            return function (value, debug) {\r\n                this.triggerOnChildren(event, value, debug);\r\n            };\r\n        },\r\n        EntityContainer = platypus.createComponentClass({\r\n            id: 'EntityContainer',\r\n            \r\n            properties: {\r\n                /**\r\n                 * An Array listing messages that are triggered on the entity and should be triggered on the children as well.\r\n                 *\r\n                 * @property childEvents\r\n                 * @type Array\r\n                 * @default []\r\n                 */\r\n                childEvents: []\r\n            },\r\n            \r\n            initialize: (function () {\r\n                var\r\n                    entityInit = function (entityDefinition, callback) {\r\n                        this.addEntity(entityDefinition, callback);\r\n                    };\r\n\r\n                return function (definition, callback) {\r\n                    var i = 0,\r\n                        entities = null,\r\n                        events = this.childEvents,\r\n                        entityInits = null;\r\n            \r\n                    _Messenger_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].initialize(this);\r\n\r\n                    this.newAdds = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n\r\n                    //saving list of entities for load message\r\n                    if (definition.entities && this.owner.entities) { //combine component list and entity list into one if they both exist.\r\n                        entities = definition.entities.concat(this.owner.entities);\r\n                    } else {\r\n                        entities = definition.entities || this.owner.entities || null;\r\n                    }\r\n\r\n                    this.owner.entities = this.entities = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                    \r\n                    this.childEvents = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                    for (i = 0; i < events.length; i++) {\r\n                        this.addNewPublicEvent(events[i]);\r\n                    }\r\n                    this.addNewPrivateEvent('peer-entity-added');\r\n                    this.addNewPrivateEvent('peer-entity-removed');\r\n\r\n                    if (entities) {\r\n                        entityInits = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                        for (i = 0; i < entities.length; i++) {\r\n                            entityInits.push(entityInit.bind(this, entities[i]));\r\n                        }\r\n                        _Async_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(entityInits, callback);\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(entityInits);\r\n                        return true; // notifies owner that this component is asynchronous.\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                };\r\n            } ()),\r\n            \r\n            events: {\r\n                /**\r\n                 * This message will added the given entity to this component's list of entities.\r\n                 *\r\n                 * @method 'add-entity'\r\n                 * @param entity {platypus.Entity} This is the entity to be added as a child.\r\n                 * @param [callback] {Function} A function to run once all of the components on the Entity have been loaded.\r\n                 */\r\n                \"add-entity\": function (entity, callback) {\r\n                    this.addEntity(entity, callback);\r\n                },\r\n                \r\n                /**\r\n                 * On receiving this message, the provided entity will be removed from the list of child entities.\r\n                 *\r\n                 * @method 'remove-entity'\r\n                 * @param entity {platypus.Entity} The entity to remove.\r\n                 */\r\n                \"remove-entity\": function (entity) {\r\n                    this.removeEntity(entity);\r\n                },\r\n                \r\n                /**\r\n                 * On receiving this message, the provided entity will be updated in the list of child entities to reflect changes in its listeners.\r\n                 *\r\n                 * @method 'child-entity-updated'\r\n                 * @param entity {platypus.Entity} The entity to remove.\r\n                 */\r\n                \"child-entity-updated\": function (entity) {\r\n                    this.updateChildEventListeners(entity);\r\n                },\r\n\r\n                /**\r\n                 * On receiving this message, this component checks to see if any entities being added are ready. If so, they are added to the world. This is so ready entities don't have to wait until the end of a complete tick, but can be inserted between logic ticks.\r\n                 *\r\n                 * @method 'handle-logic'\r\n                 * @since v2.0.0\r\n                 */\r\n                \"handle-logic\": function () {\r\n                    var adding = null,\r\n                        adds = this.newAdds,\r\n                        l = adds.length,\r\n                        i = 0,\r\n                        removals = null;\r\n\r\n                    if (l) {\r\n                        removals = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n\r\n                        //must go in order so entities are added in the expected order.\r\n                        for (i = 0; i < l; i++) {\r\n                            adding = adds[i];\r\n                            if (adding.destroyed || !adding.loadingComponents || adding.loadingComponents.attemptResolution()) {\r\n                                removals.push(i);\r\n                            }\r\n                        }\r\n\r\n                        i = removals.length;\r\n                        while (i--) {\r\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(adds, removals[i]);\r\n                        }\r\n\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(removals);\r\n                    }\r\n                }\r\n            },\r\n            \r\n            methods: {\r\n                addNewPublicEvent: function (event) {\r\n                    var i = 0;\r\n                    \r\n                    this.addNewPrivateEvent(event);\r\n                    \r\n                    for (i = 0; i < this.childEvents.length; i++) {\r\n                        if (this.childEvents[i] === event) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    this.childEvents.push(event);\r\n                    /**\r\n                     * Listens for specified messages and on receiving them, re-triggers them on child entities.\r\n                     *\r\n                     * @method '*'\r\n                     * @param message {Object} Accepts a message object that it will include in the new message to be triggered.\r\n                     */\r\n                    this.addEventListener(event, childBroadcast(event));\r\n                    \r\n                    return true;\r\n                },\r\n                \r\n                addNewPrivateEvent: function (event) {\r\n                    var x = 0,\r\n                        y = 0;\r\n                    \r\n                    if (this._listeners[event]) {\r\n                        return false; // event is already added.\r\n                    }\r\n\r\n                    this._listeners[event] = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(); //to signify it's been added even if not used\r\n                    \r\n                    //Listen for message on children\r\n                    for (x = 0; x < this.entities.length; x++) {\r\n                        if (this.entities[x]._listeners[event]) {\r\n                            for (y = 0; y < this.entities[x]._listeners[event].length; y++) {\r\n                                this.addChildEventListener(this.entities[x], event, this.entities[x]._listeners[event][y]);\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n                    return true;\r\n                },\r\n                \r\n                updateChildEventListeners: function (entity) {\r\n                    this.removeChildEventListeners(entity);\r\n                    this.addChildEventListeners(entity);\r\n                },\r\n                \r\n                addChildEventListeners: function (entity) {\r\n                    var y     = 0,\r\n                        event = '';\r\n                    \r\n                    for (event in this._listeners) {\r\n                        if (this._listeners.hasOwnProperty(event) && entity._listeners[event]) {\r\n                            for (y = 0; y < entity._listeners[event].length; y++) {\r\n                                this.addChildEventListener(entity, event, entity._listeners[event][y]);\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                \r\n                removeChildEventListeners: function (entity) {\r\n                    var i        = 0,\r\n                        events   = null,\r\n                        messages = null;\r\n                    \r\n                    if (entity.containerListener) {\r\n                        events   = entity.containerListener.events;\r\n                        messages = entity.containerListener.messages;\r\n\r\n                        for (i = 0; i < events.length; i++) {\r\n                            this.removeChildEventListener(entity, events[i], messages[i]);\r\n                        }\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(events);\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(messages);\r\n                        entity.containerListener.recycle();\r\n                        entity.containerListener = null;\r\n                    }\r\n                },\r\n                \r\n                addChildEventListener: function (entity, event, callback) {\r\n                    if (!entity.containerListener) {\r\n                        entity.containerListener = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                            \"events\", _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                            \"messages\", _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp()\r\n                        );\r\n                    }\r\n                    entity.containerListener.events.push(event);\r\n                    entity.containerListener.messages.push(callback);\r\n                    this.on(event, callback, callback._priority || 0);\r\n                },\r\n                \r\n                removeChildEventListener: function (entity, event, callback) {\r\n                    var i        = 0,\r\n                        events   = entity.containerListener.events,\r\n                        messages = entity.containerListener.messages;\r\n                    \r\n                    for (i = 0; i < events.length; i++) {\r\n                        if ((events[i] === event) && (!callback || (messages[i] === callback))) {\r\n                            this.off(event, messages[i]);\r\n                        }\r\n                    }\r\n                },\r\n\r\n                destroy: function () {\r\n                    var entities = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(this.entities), // Make a copy to handle entities being destroyed while processing list.\r\n                        i = entities.length,\r\n                        entity = null;\r\n                    \r\n                    while (i--) {\r\n                        entity = entities[i];\r\n                        this.removeChildEventListeners(entity);\r\n                        entity.destroy();\r\n                    }\r\n                    \r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(entities);\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.entities);\r\n                    this.owner.entities = null;\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.childEvents);\r\n                    this.childEvents = null;\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.newAdds);\r\n                    this.newAdds = null;\r\n                }\r\n            },\r\n            \r\n            publicMethods: {\r\n                getEntityById: function (id) {\r\n                    var i         = 0,\r\n                        selection = null;\r\n                    \r\n                    for (i = 0; i < this.entities.length; i++) {\r\n                        if (this.entities[i].id === id) {\r\n                            return this.entities[i];\r\n                        }\r\n                        if (this.entities[i].getEntityById) {\r\n                            selection = this.entities[i].getEntityById(id);\r\n                            if (selection) {\r\n                                return selection;\r\n                            }\r\n                        }\r\n                    }\r\n                    return null;\r\n                },\r\n\r\n                getEntitiesByType: function (type) {\r\n                    var i         = 0,\r\n                        selection = null,\r\n                        entities  = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                    \r\n                    for (i = 0; i < this.entities.length; i++) {\r\n                        if (this.entities[i].type === type) {\r\n                            entities.push(this.entities[i]);\r\n                        }\r\n                        if (this.entities[i].getEntitiesByType) {\r\n                            selection = this.entities[i].getEntitiesByType(type);\r\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(entities, selection);\r\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(selection);\r\n                        }\r\n                    }\r\n                    return entities;\r\n                },\r\n\r\n                /**\r\n                 * This method adds an entity to the owner's group. If an entity definition or a reference to an entity definition is provided, the entity is created and then added to the owner's group.\r\n                 *\r\n                 * @method addEntity\r\n                 * @param newEntity {platypus.Entity|Object|String} Specifies the entity to add. If an object with a \"type\" property is provided or a String is provided, this component looks up the entity definition to create the entity.\r\n                 * @param [newEntity.type] {String} If an object with a \"type\" property is provided, this component looks up the entity definition to create the entity.\r\n                 * @param [newEntity.properties] {Object} A list of key/value pairs that sets the initial properties on the new entity.\r\n                 * @param [callback] {Function} A function to run once all of the components on the Entity have been loaded.\r\n                 * @return {platypus.Entity} The entity that was just added.\r\n                 */\r\n                addEntity: (function () {\r\n                    var\r\n                        whenReady = function (callback, entity) {\r\n                            var owner = this.owner,\r\n                                entities = this.entities,\r\n                                i = entities.length;\r\n\r\n                            entity.triggerEvent('adopted', entity);\r\n                            \r\n                            while (i--) {\r\n                                if (!entity.triggerEvent('peer-entity-added', entities[i])) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            this.triggerEventOnChildren('peer-entity-added', entity);\r\n\r\n                            this.addChildEventListeners(entity);\r\n                            entities.push(entity);\r\n                            owner.triggerEvent('child-entity-added', entity);\r\n\r\n                            if (callback) {\r\n                                callback(entity);\r\n                            }\r\n                        };\r\n\r\n                    return function (newEntity, callback) {\r\n                        var entity = null,\r\n                            owner = this.owner;\r\n                        \r\n                        if (newEntity instanceof _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]) {\r\n                            entity = newEntity;\r\n                            entity.parent = owner;\r\n                            whenReady.call(this, callback, entity);\r\n                        } else {\r\n                            if (typeof newEntity === 'string') {\r\n                                entity = new _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](platypus.game.settings.entities[newEntity], null, whenReady.bind(this, callback), owner);\r\n                            } else if (newEntity.id) {\r\n                                entity = new _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](newEntity, null, whenReady.bind(this, callback), owner);\r\n                            } else {\r\n                                entity = new _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](platypus.game.settings.entities[newEntity.type], newEntity, whenReady.bind(this, callback), owner);\r\n                            }\r\n                            this.owner.triggerEvent('entity-created', entity);\r\n                        }\r\n\r\n                        this.newAdds.push(entity);\r\n\r\n                        return entity;\r\n                    };\r\n                }()),\r\n                \r\n                removeEntity: function (entity) {\r\n                    var i = this.entities.indexOf(entity);\r\n\r\n                    if (i >= 0) {\r\n                        this.removeChildEventListeners(entity);\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.entities, i);\r\n                        this.triggerEventOnChildren('peer-entity-removed', entity);\r\n                        this.owner.triggerEvent('child-entity-removed', entity);\r\n                        entity.destroy();\r\n                        entity.parent = null;\r\n                        return entity;\r\n                    }\r\n                    return false;\r\n                },\r\n                \r\n                triggerEventOnChildren: function (event, message, debug) {\r\n                    if (this.destroyed) {\r\n                        return 0;\r\n                    }\r\n                    \r\n                    if (!this._listeners[event]) {\r\n                        this.addNewPrivateEvent(event);\r\n                    }\r\n                    return this.triggerEvent(event, message, debug);\r\n                },\r\n\r\n                triggerOnChildren: function (event) {\r\n                    if (this.destroyed) {\r\n                        return 0;\r\n                    }\r\n                    \r\n                    if (!this._listeners[event]) {\r\n                        this.addNewPrivateEvent(event);\r\n                    }\r\n                    return this.trigger.apply(this, arguments);\r\n                }\r\n            },\r\n            \r\n            getAssetList: function (def, props, defaultProps) {\r\n                var i = 0,\r\n                    assets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                    entities = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                    arr = null;\r\n                \r\n                if (def.entities) {\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(entities, def.entities);\r\n                }\r\n                \r\n                if (props && props.entities) {\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(entities, props.entities);\r\n                } else if (defaultProps && defaultProps.entities) {\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(entities, defaultProps.entities);\r\n                }\r\n\r\n                for (i = 0; i < entities.length; i++) {\r\n                    arr = _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getAssetList(entities[i]);\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\r\n                }\r\n                \r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(entities);\r\n                \r\n                return assets;\r\n            }\r\n        });\r\n    \r\n    _Messenger_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].mixin(EntityContainer);\r\n\r\n    return EntityContainer;\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/EntityContainer.js?");

/***/ }),

/***/ "./src/components/EntityController.js":
/*!********************************************!*\
  !*** ./src/components/EntityController.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ActionState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ActionState.js */ \"./src/ActionState.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../StateMap.js */ \"./src/StateMap.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n * This component listens for input messages triggered on the entity and updates the state of any controller inputs it is listening for. It then broadcasts messages on the entity corresponding to the input it received.\r\n *\r\n * @namespace platypus.components\r\n * @class EntityController\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var distance = function (origin, destination) {\r\n            var x = destination.x - origin.x,\r\n                y = destination.y - origin.y;\r\n\r\n            return Math.sqrt((x * x) + (y * y));\r\n        },\r\n        angle = function (origin, destination, distance) {\r\n            var x      = destination.x - origin.x,\r\n                y      = destination.y - origin.y,\r\n                a      = 0,\r\n                circle = Math.PI * 2;\r\n\r\n            if (!distance) {\r\n                return a;\r\n            }\r\n\r\n            a = Math.acos(x / distance);\r\n            if (y < 0) {\r\n                a = circle - a;\r\n            }\r\n            return a;\r\n        },\r\n        directions = [null, null, null, null, //joystick directions\r\n            ['east', 'south', 'west', 'north'], null, null, null,\r\n            ['east', 'southeast', 'south', 'southwest', 'west', 'northwest', 'north', 'northeast'], null, null, null, null, null, null, null,\r\n            ['east', 'east-southeast', 'southeast', 'south-southeast', 'south', 'south-southwest', 'southwest', 'west-southwest', 'west', 'west-northwest', 'northwest', 'north-northwest', 'north', 'north-northeast', 'northeast', 'east-northeast']\r\n        ],\r\n        mouseMap = ['left-button', 'middle-button', 'right-button'],\r\n        trigger = function (event, message) {\r\n            if (!this.paused) {\r\n                this.owner.trigger(event, message);\r\n            }\r\n        },\r\n        filteredTrigger = function (state, event, message) {\r\n            if (!this.paused && message[state]) {\r\n                this.owner.trigger(event, message);\r\n            }\r\n        };\r\n\r\n    return platypus.createComponentClass({\r\n        id: 'EntityController',\r\n        \r\n        properties: {\r\n            /**\r\n             * Use the controlMap property object to map inputs to messages that should be triggered. At least one control mapping should be included. The following are a few examples:\r\n             *\r\n             *       {\r\n             *           \"key:x\": \"run-left\",\r\n             *           // This causes an \"x\" keypress to fire \"run-left\" on the entity. For a full listing of key names, check out the `HandlerController` component.\r\n             *\r\n             *           \"button-pressed\": \"throw-block\",\r\n             *           // custom input messages can be fired on this entity from other entities, allowing for on-screen input buttons to run through the same controller channel as other inputs.\r\n             *\r\n             *           \"mouse:left-button\"\r\n             *           // The controller can also handle mouse events on the entity if the entity's render component triggers mouse events on the entity (for example, the `RenderSprite` component).\r\n             *       }\r\n             *\r\n             * @property controlMap\r\n             * @type Object\r\n             * @default {}\r\n             */\r\n            controlMap: {},\r\n\r\n            /**\r\n             * Determines whether this entity should listen for mouse events to trigger directional events. Can be set simply to \"true\" to accept all joystick defaults.\r\n             *\r\n             *       \"joystick\": {\r\n             *           \"directions\": 8, // Optional: 4, 8, or 16. Determines how many directions to broadcast. Default is 4 (\"north\", \"east\", \"south\", and \"west\").\r\n             *           \"innerRadius\": 30, // Optional. Number determining how far the mouse must be from the entity's position before joystick events should be triggered. Default is 0.\r\n             *           \"outerRadius\": 60 // Optional. Number determining how far the mouse can move away from the entity's position before the joystick stops triggering events. Default is Infinity.\r\n             *       }\r\n             *\r\n             * @property joystick\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            joystick: null,\r\n            \r\n            /**\r\n             * The stateMaps property can hold multiple control maps. Use this if certain controls should only be available for certain states. The controller finds the first valid state and falls back to the base `controlMap` as default if no matches are found.\r\n             *\r\n             * @property stateMaps\r\n             * @type Object\r\n             * @default {}\r\n             * @since 0.6.7\r\n             */\r\n            stateMaps: {}\r\n        },\r\n        \r\n        publicProperties: {\r\n            /**\r\n             * Whether input controls should be deactivated.\r\n             *\r\n             * @property paused\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            paused: false\r\n        },\r\n        \r\n        initialize: function (definition) {\r\n            var key = '',\r\n                filter = null;\r\n            \r\n            this.actions = _DataMap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp();\r\n            \r\n            if (this.stateMaps) {\r\n                for (key in this.stateMaps) {\r\n                    if (this.stateMaps.hasOwnProperty(key)) {\r\n                        filter = _StateMap_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setUp(key);\r\n                        this.addMap(this.stateMaps[key], key, filter);\r\n                        filter.recycle();\r\n                    }\r\n                }\r\n            }\r\n            \r\n            this.addMap(this.controlMap, 'default');\r\n\r\n            if (definition.joystick) {\r\n                this.joystick = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\r\n                    \"directions\",  definition.joystick.directions  || 4, // 4 = n,e,s,w; 8 = n,ne,e,se,s,sw,w,nw; 16 = n,nne,ene,e...\r\n                    \"handleEdge\",  definition.joystick.handleEdge  || false,\r\n                    \"innerRadius\", definition.joystick.innerRadius || 0,\r\n                    \"outerRadius\", definition.joystick.outerRadius || Infinity\r\n                );\r\n            }\r\n        },\r\n        \r\n        events: {\r\n            /**\r\n             * On each `handle-controller` message, this component checks its list of actions and if any of their states are currently true or were true on the last call, that action message is triggered.\r\n             *\r\n             * @method 'handle-controller'\r\n             */\r\n            \"handle-controller\": function () {\r\n                var actions = this.actions,\r\n                    keys = actions.keys,\r\n                    i = keys.length,\r\n                    action = '',\r\n                    resolution = _utils_array_js__WEBPACK_IMPORTED_MODULE_4__[\"arrayCache\"].setUp(),\r\n                    state = this.owner.state;\r\n                \r\n                while (i--) {\r\n                    action = actions.get(keys[i]);\r\n                    if (action.update(state)) {\r\n                        resolution.push(action);\r\n                    }\r\n                }\r\n                \r\n                i = resolution.length;\r\n                while (i--) {\r\n                    resolution[i].resolve();\r\n                }\r\n                \r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_4__[\"arrayCache\"].recycle(resolution);\r\n            },\r\n            \r\n            /**\r\n             * This message triggers a new message on the entity that includes what button on the mouse was pressed: \"mouse:left-button:down\", \"mouse:middle-button:down\", or \"mouse:right-button:down\".\r\n             *\r\n             * @method 'pointerdown'\r\n             * @param value.event {DOM Event object} This event object is passed along with the new message.\r\n             */\r\n            \"pointerdown\": function (value) {\r\n                if (value.pixiEvent.data.pointerType === 'mouse') {\r\n                    /**\r\n                     * This component triggers the state of mouse inputs on the entity if a render component of the entity accepts mouse input.\r\n                     *\r\n                     * @event 'mouse:mouse-left:down'\r\n                     * @param message {DOM Event object} The original mouse event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * This component triggers the state of mouse inputs on the entity if a render component of the entity accepts mouse input (for example [[Render-Animation]]).\r\n                     *\r\n                     * @event 'mouse:mouse-middle:down'\r\n                     * @param message {DOM Event object} The original mouse event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * This component triggers the state of mouse inputs on the entity if a render component of the entity accepts mouse input (for example [[Render-Animation]]).\r\n                     *\r\n                     * @event 'mouse:mouse-right:down'\r\n                     * @param message {DOM Event object} The original mouse event object is passed along with the control message.\r\n                     */\r\n                    this.owner.triggerEvent('mouse:' + mouseMap[value.event.button || 0] + ':down', value.event);\r\n                }\r\n\r\n                if (this.joystick) {\r\n                    /**\r\n                     * This event is triggered when there is an active touch in the joystick area.\r\n                     *\r\n                     * @event 'joystick:down'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    this.owner.triggerEvent('joystick:down', value.event);\r\n                    this.handleJoy(value);\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * This message triggers a new message on the entity that includes what button on the mouse was released: \"mouse:left-button:up\", \"mouse:middle-button:up\", or \"mouse:right-button:up\".\r\n             *\r\n             * @method 'pressup'\r\n             * @param value.event {DOM Event object} This event object is passed along with the new message.\r\n             */\r\n            \"pressup\": function (value) {\r\n                var owner = this.owner;\r\n\r\n                if (value.pixiEvent.data.pointerType === 'mouse') {\r\n                    /**\r\n                     * This component triggers the state of mouse inputs on the entity if a render component of the entity accepts mouse input (for example [[Render-Animation]]).\r\n                     *\r\n                     * @event 'mouse:mouse-left:up'\r\n                     * @param message {DOM Event object} The original mouse event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * This component triggers the state of mouse inputs on the entity if a render component of the entity accepts mouse input (for example [[Render-Animation]]).\r\n                     *\r\n                     * @event 'mouse:mouse-middle:up'\r\n                     * @param message {DOM Event object} The original mouse event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * This component triggers the state of mouse inputs on the entity if a render component of the entity accepts mouse input (for example [[Render-Animation]]).\r\n                     *\r\n                     * @event 'mouse:mouse-right:up'\r\n                     * @param message {DOM Event object} The original mouse event object is passed along with the control message.\r\n                     */\r\n                    owner.triggerEvent('mouse:' + mouseMap[value.event.button || 0] + ':up', value.event);\r\n                }\r\n\r\n                if (this.joystick) {\r\n                    /**\r\n                     * This event is triggered when there is an active touch is released from the joystick area.\r\n                     *\r\n                     * @event 'joystick:up'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    owner.triggerEvent('joystick:up', value.event);\r\n                    /**\r\n                     * This event is triggered to stop movement once the joystick is released.\r\n                     *\r\n                     * @event 'stop'\r\n                     */\r\n                    owner.triggerEvent('stop');\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * Updates joystick input if joystick is enabled.\r\n             *\r\n             * @method 'pressmove'\r\n             * @param value {platypus.Data} This event object is passed along with the joystick messages.\r\n             */\r\n            \"pressmove\": function (value) {\r\n                if (this.joystick) {\r\n                    this.handleJoy(value);\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * This message will stop the controller from triggering messages until \"unpause-controls\" is triggered on the entity.\r\n             *\r\n             * @method 'pause-controls'\r\n             */\r\n            \"pause-controls\": function () {\r\n                this.paused = true;\r\n            },\r\n            \r\n            /**\r\n             * This message will allow the controller to trigger messages until \"pause-controls\" is triggered on the entity.\r\n             *\r\n             * @method 'unpause-controls'\r\n             */\r\n            \"unpause-controls\": function () {\r\n                this.paused = false;\r\n            }\r\n        },\r\n\r\n        methods: {\r\n            handleJoy: function (event) {\r\n                // The following translate mouse and touch events into messages that this controller can handle in a systematic way\r\n                var joystick = this.joystick,\r\n                    owner = this.owner,\r\n                    segment     = Math.PI / (joystick.directions / 2),\r\n                    dist        = distance(owner, event),\r\n                    orientation = 0,\r\n                    direction   = '',\r\n                    accuracy    = '';\r\n                \r\n                if ((dist > joystick.outerRadius) || (dist < joystick.innerRadius)) {\r\n                    return;\r\n                } else if (!this.paused) {\r\n                    orientation = angle(owner, event, dist);\r\n                    direction   = directions[joystick.directions][Math.floor(((orientation + segment / 2) % (Math.PI * 2)) / segment)];\r\n                    \r\n                    if (joystick.handleEdge) {\r\n                        segment  = Math.PI / joystick.directions;\r\n                        accuracy = directions[joystick.directions * 2][Math.floor(((orientation + segment / 2) % (Math.PI * 2)) / segment)];\r\n                        if (accuracy !== direction) {\r\n                            owner.triggerEvent(accuracy.replace(direction, '').replace('-', ''), event);  //There's probably a better way to perform this, but the current method is functional. - DDD\r\n                        }\r\n                    }\r\n\r\n                    owner.triggerEvent('stop');\r\n\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due north.\r\n                     *\r\n                     * @event 'north'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due north-northeast.\r\n                     *\r\n                     * @event 'north-northeast'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due northeast.\r\n                     *\r\n                     * @event 'northeast'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due east-northeast.\r\n                     *\r\n                     * @event 'east-northeast'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due east.\r\n                     *\r\n                     * @event 'east'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due east-southeast.\r\n                     *\r\n                     * @event 'east-southeast'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due southeast.\r\n                     *\r\n                     * @event 'southeast'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due south-southeast.\r\n                     *\r\n                     * @event 'south-southeast'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due south.\r\n                     *\r\n                     * @event 'south'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due south-southwest.\r\n                     *\r\n                     * @event 'south-southwest'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due southwest.\r\n                     *\r\n                     * @event 'southwest'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due west-southwest.\r\n                     *\r\n                     * @event 'west-southwest'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due west.\r\n                     *\r\n                     * @event 'west'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due west-northwest.\r\n                     *\r\n                     * @event 'west-northwest'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due northwest.\r\n                     *\r\n                     * @event 'northwest'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, it will broadcast this directional message if the joystick is dragged due north-northwest.\r\n                     *\r\n                     * @event 'north-northwest'\r\n                     * @param message {DOM Event object} The original pointer event object is passed along with the control message.\r\n                     */\r\n                    owner.triggerEvent(direction, event);\r\n\r\n                    /**\r\n                     * If the soft joystick is enabled on this component, this message will trigger to provide the current orientation of the joystick.\r\n                     *\r\n                     * @event 'joystick-orientation'\r\n                     * @param orientation (number) - A number in radians representing the orientation of the joystick.\r\n                     */\r\n                    owner.triggerEvent(\"joystick-orientation\", orientation);\r\n                }\r\n            },\r\n            \r\n            addController: (function () {\r\n                var up = function (index) {\r\n                        this.inputs[index] = false;\r\n                    },\r\n                    down = function (index) {\r\n                        this.inputs[index] = true;\r\n                    };\r\n                \r\n                return function (key, stateId, controller, states, controllerState) {\r\n                    var actions = this.actions,\r\n                        id = stateId + '-' + controller + '-' + (controllerState || 'all'),\r\n                        actionState = actions.get(id); // If there's already a state storage object for this action, reuse it: there are multiple keys mapped to the same action.\r\n                        \r\n                    // Otherwise create a new state storage object\r\n                    if (!actionState) {\r\n\r\n                        /**\r\n                         * Broadcasts active states using the JSON-defined message on each `handle-controller` message. Active states include `pressed` being true or `released` being true. If both of these states are false, the message is not broadcasted.\r\n                         *\r\n                         * @event '*'\r\n                         * @param message.pressed {Boolean} Whether the current input is active.\r\n                         * @param message.released {Boolean} Whether the current input was active last tick but is no longer active.\r\n                         * @param message.triggered {Boolean} Whether the current input is active but was not active last tick.\r\n                         * @param message.over {Boolean} Whether the mouse was over the entity when pressed, released, or triggered. This value is always false for non-mouse input messages.\r\n                         */\r\n                        if (controllerState) {\r\n                            actionState = actions.set(id, _ActionState_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(controller, states, filteredTrigger.bind(this, controllerState)));\r\n                        } else {\r\n                            actionState = actions.set(id, _ActionState_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(controller, states, trigger.bind(this)));\r\n                        }\r\n                    }\r\n                    \r\n                    // Set up listeners and input flag.\r\n                    this.addEventListener(key + ':up',   up.bind(actionState, actionState.inputs.length));\r\n                    this.addEventListener(key + ':down', down.bind(actionState, actionState.inputs.length));\r\n                    actionState.inputs.push(false);\r\n                };\r\n            }()),\r\n\r\n            addMap: function (map, id, states) {\r\n                var controller = null,\r\n                    i = 0,\r\n                    j = '',\r\n                    key = '';\r\n                \r\n                for (key in map) {\r\n                    if (map.hasOwnProperty(key)) {\r\n                        controller = map[key];\r\n                        if (typeof controller === 'string') {\r\n                            this.addController(key, id, controller, states);\r\n                        } else if (Array.isArray(controller)) {\r\n                            for (i = 0; i < controller.length; i++) {\r\n                                this.addController(key, id, controller[i], states);\r\n                            }\r\n                        } else {\r\n                            for (j in controller) {\r\n                                if (controller.hasOwnProperty(j)) {\r\n                                    if (typeof controller[j] === 'string') {\r\n                                        this.addController(key, id, controller[j], states, j);\r\n                                    } else {\r\n                                        for (i = 0; i < controller[j].length; i++) {\r\n                                            this.addController(key, id, controller[j][i], states, j);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            \r\n            destroy: function () {\r\n                var actions = this.actions,\r\n                    keys = actions.keys,\r\n                    i = keys.length;\r\n                \r\n                while (i--) {\r\n                    actions.get(keys[i]).recycle();\r\n                }\r\n                actions.recycle();\r\n                if (this.joystick) {\r\n                    this.joystick.recycle();\r\n                }\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/EntityController.js?");

/***/ }),

/***/ "./src/components/HandlerCollision.js":
/*!********************************************!*\
  !*** ./src/components/HandlerCollision.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _CollisionData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollisionData.js */ \"./src/CollisionData.js\");\n/* harmony import */ var _CollisionDataContainer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CollisionDataContainer.js */ \"./src/CollisionDataContainer.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/**\r\n * This component checks for collisions between entities which typically have either a [CollisionTiles](platypus.components.CollisionTiles.html) component for tile maps or a [CollisionBasic](platypus.components.CollisionBasic.html) component for other entities. It uses `EntityContainer` component messages if triggered to add to its collision list and also listens for explicit add/remove messages (useful in the absence of an `EntityContainer` component).\r\n *\r\n * @namespace platypus.components\r\n * @class HandlerCollision\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    /**\r\n     * When an entity collides with an entity of a listed collision-type, this message is triggered on the entity. * is the other entity's collision-type.\r\n     *\r\n     * @event 'hit-by-*'\r\n     * @param collision {Object}\r\n     * @param collision.entity {Entity} The entity with which the collision occurred.\r\n     * @param collision.target {Entity} The entity that's receiving the collision event.\r\n     * @param collision.type {String} The collision type of the other entity.\r\n     * @param collision.shape {CollisionShape} This is the shape of the other entity that caused the collision.\r\n     * @param collision.x {number} Returns -1, 0, or 1 indicating on which side of this entity the collision occurred: left, neither, or right respectively.\r\n     * @param collision.y {number} Returns -1, 0, or 1 indicating on which side of this entity the collision occurred: top, neither, or bottom respectively.\r\n     */\r\n    var BIT_16 = 0xffff,\r\n        combine = function (x, y) {\r\n            return (x << 16) | (y & BIT_16);\r\n        },\r\n        getBucketId = function (x, y, bits) {\r\n            return combine(x >> bits, y >> bits);\r\n        },\r\n        triggerMessage = {\r\n            entity: null,\r\n            target: null,\r\n            type: null,\r\n            x: 0,\r\n            y: 0,\r\n            hitType: null,\r\n            myType: null\r\n        },\r\n        groupSortBySize = function (a, b) {\r\n            return a.collisionGroup.getAllEntities() - b.collisionGroup.getAllEntities();\r\n        };\r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'HandlerCollision',\r\n        \r\n        properties: {\r\n            /**\r\n             *\r\n             */\r\n            gridBits: 8\r\n        },\r\n        \r\n        initialize: function () {\r\n            this.againstGrid = _Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp();\r\n            \r\n            this.solidEntitiesLive = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.softEntitiesLive = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.allEntitiesLive = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.groupsLive = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.nonColliders = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            \r\n            this.terrain = null;\r\n            this.owner.previousX = this.owner.previousX || this.owner.x;\r\n            this.owner.previousY = this.owner.previousY || this.owner.y;\r\n            \r\n            this.relocationMessage = _Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(\r\n                \"position\", _Vector_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].setUp(),\r\n                \"relative\", false\r\n            );\r\n        },\r\n        \r\n        events: {\r\n            /**\r\n             * On receiving this message, the component checks the entity to determine whether it listens for collision messages. If so, the entity is added to the collision group.\r\n             *\r\n             * @method 'child-entity-added'\r\n             * @param entity {Entity} The entity to be added.\r\n             */\r\n            \"child-entity-added\": function (entity) {\r\n                if (!entity.collideOff) {\r\n                    this.addCollisionEntity(entity);\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the component checks the entity to determine whether it listens for collision messages. If so, the entity is added to the collision group.\r\n             *\r\n             * @method 'add-collision-entity'\r\n             * @param entity {Entity} The entity to be added.\r\n             */\r\n            \"add-collision-entity\": function (entity) {\r\n                this.addCollisionEntity(entity);\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the component looks for the entity in its collision group and removes it.\r\n             *\r\n             * @method 'child-entity-removed'\r\n             * @param message {platypus.Entity} The entity to be removed.\r\n             */\r\n            \"child-entity-removed\": function (entity) {\r\n                this.removeCollisionEntity(entity);\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the component looks for the entity in its collision group and removes it.\r\n             *\r\n             * @method 'remove-collision-entity'\r\n             * @param message {platypus.Entity} The entity to be removed.\r\n             */\r\n            \"remove-collision-entity\": function (entity) {\r\n                this.removeCollisionEntity(entity);\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the component looks for the entity in its collision group and updates it.\r\n             *\r\n             * @method 'child-entity-updated'\r\n             * @param message {platypus.Entity} The entity to be updated.\r\n             */\r\n            \"child-entity-updated\": function (entity) {\r\n                this.removeCollisionEntity(entity);\r\n                this.addCollisionEntity(entity);\r\n            },\r\n            \r\n            /**\r\n             * This message causes the component to go through the entities and check for collisions.\r\n             *\r\n             * @method 'check-collision-group'\r\n             * @param options {Object}\r\n             * @param [options.camera] {Object} Specifies a region in which to check for collisions. Expects the camera object to contain the following properties: top, left, width, height, and buffer.\r\n             */\r\n            \"check-collision-group\": function (resp) {\r\n                this.checkCamera(resp.camera, resp.entities);\r\n                this.checkGroupCollisions();\r\n                this.checkSolidCollisions();\r\n                this.resolveNonCollisions();\r\n                this.checkSoftCollisions(resp);\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            mapDown: function (aabb2) {\r\n                var aabb1 = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(),\r\n                    gb = this.gridBits;\r\n                \r\n                return aabb1.setBounds(aabb2.left >> gb, aabb2.top >> gb, aabb2.right >> gb, aabb2.bottom >> gb);\r\n            },\r\n            \r\n            getAgainstGrid: function (entity, sweep, types) {\r\n                var aabb = this.mapDown(sweep),\r\n                    arr = null,\r\n                    data = _Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(),\r\n                    i = 0,\r\n                    list = null,\r\n                    thisAgainstGrid = this.againstGrid,\r\n                    tList = null,\r\n                    type = '',\r\n                    x = 0,\r\n                    y = 0;\r\n                \r\n                if (entity && sweep.equals(entity.againstAABB)) {\r\n                    return this.getEntityAgainstGrid(entity, types);\r\n                }\r\n\r\n                for (x = aabb.left; x <= aabb.right; x++) {\r\n                    for (y = aabb.top; y <= aabb.bottom; y++) {\r\n                        list = thisAgainstGrid[combine(x, y)];\r\n                        if (list) {\r\n                            i = types.length;\r\n                            while (i--) {\r\n                                type = types[i];\r\n                                arr = list.get(type);\r\n                                if (arr && arr.length) {\r\n                                    tList = data[type];\r\n                                    if (!tList) {\r\n                                        data[type] = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp.apply(null, arr);\r\n                                    } else {\r\n                                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(tList, arr);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                aabb.recycle();\r\n                return data;\r\n            },\r\n            \r\n            getEntityAgainstGrid: function (entity, types) {\r\n                var ag = entity.againstGrid,\r\n                    arr = null,\r\n                    data = _Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(),\r\n                    i = ag.length,\r\n                    j = 0,\r\n                    list = null,\r\n                    tList = null,\r\n                    type = '';\r\n\r\n                while (i--) {\r\n                    list = ag[i];\r\n                    j = types.length;\r\n                    while (j--) {\r\n                        type = types[j];\r\n                        arr = list.get(type);\r\n                        if (arr && arr.length) {\r\n                            tList = data[type];\r\n                            if (!tList) {\r\n                                data[type] = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp.apply(null, arr);\r\n                            } else {\r\n                                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(tList, arr);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                return data;\r\n            },\r\n            \r\n            removeAgainst: function (entity) {\r\n                var ag = entity.againstGrid,\r\n                    types = entity.collisionTypes,\r\n                    arr = null,\r\n                    i = ag.length,\r\n                    j = 0,\r\n                    id = 0,\r\n                    len = types.length,\r\n                    list = null;\r\n                    \r\n                while (i--) {\r\n                    list = ag[i];\r\n                    j = len;\r\n                    while (j--) {\r\n                        arr = list.get(types[j]);\r\n                        if (arr) {\r\n                            id = arr.indexOf(entity);\r\n                            if (id >= 0) {\r\n                                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(arr, id);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                ag.length = 0;\r\n            },\r\n            \r\n            updateAgainst: function (entity) {\r\n                var arr = null,\r\n                    i = 0,\r\n                    type = '',\r\n                    types = entity.collisionTypes,\r\n                    aabb = this.mapDown(entity.getAABB()),\r\n                    ag = entity.againstGrid,\r\n                    id = 0,\r\n                    list = null,\r\n                    thisAgainstGrid = this.againstGrid,\r\n                    x = 0,\r\n                    y = 0;\r\n                \r\n                if (!aabb.equals(entity.againstAABB)) {\r\n                    entity.againstAABB.set(aabb);\r\n                    this.removeAgainst(entity);\r\n\r\n                    for (x = aabb.left; x <= aabb.right; x++) {\r\n                        for (y = aabb.top; y <= aabb.bottom; y++) {\r\n                            id = combine(x, y);\r\n                            list = thisAgainstGrid[id];\r\n                            if (!list) {\r\n                                list = thisAgainstGrid[id] = _DataMap_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].setUp();\r\n                            }\r\n                            i = types.length;\r\n                            while (i--) {\r\n                                type = types[i];\r\n                                arr = list.get(type);\r\n                                if (!arr) {\r\n                                    arr = list.set(type, _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp());\r\n                                }\r\n                                arr.push(entity);\r\n                            }\r\n                            ag.push(list);\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                aabb.recycle();\r\n            },\r\n            \r\n            addCollisionEntity: function (entity) {\r\n                if (entity.getTileShapes) { // Has a CollisionTiles component\r\n                    this.terrain = entity;\r\n                } else if (entity.collisionTypes && !entity.againstGrid) {\r\n                    entity.againstGrid = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                    entity.againstAABB = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\r\n                    this.updateAgainst(entity);\r\n                }\r\n            },\r\n\r\n            removeCollisionEntity: function (entity) {\r\n                if (entity.againstGrid) {\r\n                    this.removeAgainst(entity);\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(entity.againstGrid);\r\n                    entity.againstGrid = null;\r\n                    entity.againstAABB.recycle();\r\n                    entity.againstAABB = null;\r\n                }\r\n            },\r\n            \r\n            checkCamera: function (camera, all) {\r\n                var i        = all.length,\r\n                    j        = 0,\r\n                    allLive  = this.allEntitiesLive,\r\n                    softs    = this.softEntitiesLive,\r\n                    solids   = this.solidEntitiesLive,\r\n                    nons     = this.nonColliders,\r\n                    groups   = this.groupsLive,\r\n                    entity        = null,\r\n                    types = null,\r\n                    collides = false;\r\n                \r\n                allLive.length = 0;\r\n                solids.length = 0;\r\n                softs.length = 0;\r\n                nons.length = 0;\r\n                groups.length = 0;\r\n\r\n                while (i--) {\r\n                    collides = false;\r\n                    entity = all[i];\r\n                    types = entity.collisionTypes;\r\n                    if (!entity.immobile && types && types.length) {\r\n                        allLive.push(entity);\r\n\r\n                        if (entity !== this.owner) {\r\n                            j = types.length;\r\n                            while (j--) {\r\n                                if (entity.solidCollisionMap.get(types[j]).length) {\r\n                                    solids.push(entity);\r\n                                    collides = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        j = types.length;\r\n                        while (j--) {\r\n                            if (entity.softCollisionMap.get(types[j]).length) {\r\n                                softs.push(entity);\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        if (!collides) {\r\n                            nons.push(entity);\r\n                        }\r\n\r\n                        if (entity.collisionGroup) {\r\n                            groups.push(entity);\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                groups.sort(groupSortBySize);\r\n            },\r\n            \r\n            resolveNonCollisions: function () {\r\n                var entity = null,\r\n                    msg    = this.relocationMessage,\r\n                    nons   = this.nonColliders,\r\n                    i      = nons.length;\r\n                \r\n                msg.relative = false;\r\n                while (i--) {\r\n                    entity = nons[i];\r\n                    if ((entity.position.x !== entity.previousPosition.x) || (entity.position.y !== entity.previousPosition.y)) {\r\n                        msg.position.setVector(entity.position);\r\n\r\n                        /**\r\n                         * This message is triggered on an entity that has been repositioned due to a solid collision.\r\n                         *\r\n                         * @event 'relocate-entity'\r\n                         * @param object {Object}\r\n                         * @param object.position {Vector} The relocated position of the entity.\r\n                         */\r\n                        entity.triggerEvent('relocate-entity', msg);\r\n                        this.updateAgainst(entity);\r\n                    }\r\n                }\r\n            },\r\n            \r\n            checkGroupCollisions: (function () {\r\n                var triggerCollisionMessages = function (entity, otherEntity, thisType, thatType, x, y, hitType, vector) {\r\n                    var msg = triggerMessage;\r\n                    \r\n                    msg.entity    = otherEntity;\r\n                    msg.target    = entity;\r\n                    msg.myType    = thisType;\r\n                    msg.type      = thatType;\r\n                    msg.x         = x;\r\n                    msg.y         = y;\r\n                    msg.direction = vector;\r\n                    msg.hitType   = hitType;\r\n                    entity.triggerEvent('hit-by-' + thatType, msg);\r\n                    \r\n                    if (otherEntity) {\r\n                        msg.entity    = entity;\r\n                        msg.target    = otherEntity;\r\n                        msg.type      = thisType;\r\n                        msg.myType    = thatType;\r\n                        msg.x         = -x;\r\n                        msg.y         = -y;\r\n                        msg.direction = vector.getInverse();\r\n                        msg.hitType   = hitType;\r\n                        otherEntity.triggerEvent('hit-by-' + thisType, msg);\r\n                        \r\n                        msg.direction.recycle();\r\n                    }\r\n                };\r\n\r\n                return function () {\r\n                    var i           = 0,\r\n                        entities    = this.groupsLive,\r\n                        x           = entities.length,\r\n                        entity      = null,\r\n                        list        = null,\r\n                        messageData = null,\r\n                        entityCDC   = null;\r\n                    \r\n                    while (x--) {\r\n                        entity = entities[x];\r\n                        if (entity.collisionGroup.getSize() > 1) {\r\n                            entityCDC = this.checkSolidEntityCollision(entity, entity.collisionGroup);\r\n                            \r\n                            list = entityCDC.xData;\r\n                            i = list.length;\r\n                            while (i--) {\r\n                                messageData = list[i];\r\n                                triggerCollisionMessages(messageData.thisShape.owner, messageData.thatShape.owner, messageData.thisShape.collisionType, messageData.thatShape.collisionType, messageData.direction, 0, 'solid', messageData.vector);\r\n                            }\r\n                            \r\n                            list = entityCDC.yData;\r\n                            i = list.length;\r\n                            while (i--) {\r\n                                messageData = list[i];\r\n                                triggerCollisionMessages(messageData.thisShape.owner, messageData.thatShape.owner, messageData.thisShape.collisionType, messageData.thatShape.collisionType, 0, messageData.direction, 'solid', messageData.vector);\r\n                            }\r\n                            \r\n                            entityCDC.recycle();\r\n                        }\r\n                    }\r\n                };\r\n            }()),\r\n            \r\n            checkSolidCollisions: (function () {\r\n                var triggerCollisionMessages = function (entity, otherEntity, thisType, thatType, x, y, hitType, vector) {\r\n                    var msg = triggerMessage;\r\n                    \r\n                    msg.entity    = otherEntity;\r\n                    msg.target    = entity;\r\n                    msg.myType    = thisType;\r\n                    msg.type      = thatType;\r\n                    msg.x         = x;\r\n                    msg.y         = y;\r\n                    msg.direction = vector;\r\n                    msg.hitType   = hitType;\r\n                    entity.triggerEvent('hit-by-' + thatType, msg);\r\n                    \r\n                    if (otherEntity) {\r\n                        msg.entity    = entity;\r\n                        msg.target    = otherEntity;\r\n                        msg.type      = thisType;\r\n                        msg.myType    = thatType;\r\n                        msg.x         = -x;\r\n                        msg.y         = -y;\r\n                        msg.direction = vector.getInverse();\r\n                        msg.hitType   = hitType;\r\n                        otherEntity.triggerEvent('hit-by-' + thisType, msg);\r\n                        \r\n                        msg.direction.recycle();\r\n                    }\r\n                };\r\n\r\n                return function () {\r\n                    var i           = 0,\r\n                        entities    = this.solidEntitiesLive,\r\n                        x           = entities.length,\r\n                        entity      = null,\r\n                        list        = null,\r\n                        messageData = null,\r\n                        entityCDC   = null,\r\n                        trigger = triggerCollisionMessages;\r\n                    \r\n                    while (x--) {\r\n                        entity = entities[x];\r\n                        entityCDC = this.checkSolidEntityCollision(entity, entity);\r\n                        \r\n                        list = entityCDC.xData;\r\n                        i = list.length;\r\n                        while (i--) {\r\n                            messageData = list[i];\r\n                            trigger(messageData.thisShape.owner, messageData.thatShape.owner, messageData.thisShape.collisionType, messageData.thatShape.collisionType, messageData.direction, 0, 'solid', messageData.vector);\r\n                        }\r\n                        \r\n                        list = entityCDC.yData;\r\n                        i = list.length;\r\n                        while (i--) {\r\n                            messageData = list[i];\r\n                            trigger(messageData.thisShape.owner, messageData.thatShape.owner, messageData.thisShape.collisionType, messageData.thatShape.collisionType, 0, messageData.direction, 'solid', messageData.vector);\r\n                        }\r\n                        \r\n                        entityCDC.recycle();\r\n                    }\r\n                };\r\n            }()),\r\n            \r\n            checkSolidEntityCollision: function (ent, entityOrGroup) {\r\n                var collisionDataCollection = _CollisionDataContainer_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].setUp(),\r\n                    step              = 0,\r\n                    finalMovementInfo = null,\r\n                    aabb              = null,\r\n                    pX                = ent.previousX,\r\n                    pY                = ent.previousY,\r\n                    dX                = ent.x - pX,\r\n                    dY                = ent.y - pY,\r\n                    sW                = Infinity,\r\n                    sH                = Infinity,\r\n                    collisionTypes    = entityOrGroup.getCollisionTypes(),\r\n                    i                 = 0,\r\n                    ignoredEntities   = false,\r\n                    min               = null;\r\n                \r\n                if (entityOrGroup.getSolidEntities) {\r\n                    ignoredEntities = entityOrGroup.getSolidEntities();\r\n                }\r\n                \r\n                finalMovementInfo = _Vector_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].setUp(ent.position);\r\n\r\n                if (dX || dY) {\r\n                    \r\n                    if (ent.bullet) {\r\n                        min = Math.min;\r\n                        \r\n                        i = collisionTypes.length;\r\n                        while (i--) {\r\n                            aabb = entityOrGroup.getAABB(collisionTypes[i]);\r\n                            sW = min(sW, aabb.width);\r\n                            sH = min(sH, aabb.height);\r\n                        }\r\n\r\n                        //Stepping to catch really fast entities - this is not perfect, but should prevent the majority of fallthrough cases.\r\n                        step = Math.ceil(Math.max(Math.abs(dX) / sW, Math.abs(dY) / sH));\r\n                        step = min(step, 100); //Prevent memory overflow if things move exponentially far.\r\n                        dX   = dX / step;\r\n                        dY   = dY / step;\r\n\r\n                        while (step--) {\r\n                            entityOrGroup.prepareCollision(ent.previousX + dX, ent.previousY + dY);\r\n\r\n                            finalMovementInfo = this.processCollisionStep(ent, entityOrGroup, ignoredEntities, collisionDataCollection, finalMovementInfo.setVector(ent.position), dX, dY, collisionTypes);\r\n                            \r\n                            if ((finalMovementInfo.x === ent.previousX) && (finalMovementInfo.y === ent.previousY)) {\r\n                                entityOrGroup.relocateEntity(finalMovementInfo, collisionDataCollection);\r\n                                //No more movement so we bail!\r\n                                break;\r\n                            } else {\r\n                                entityOrGroup.relocateEntity(finalMovementInfo, collisionDataCollection);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        entityOrGroup.prepareCollision(ent.previousX + dX, ent.previousY + dY);\r\n                        finalMovementInfo = this.processCollisionStep(ent, entityOrGroup, ignoredEntities, collisionDataCollection, finalMovementInfo, dX, dY, collisionTypes);\r\n                        entityOrGroup.relocateEntity(finalMovementInfo, collisionDataCollection);\r\n                    }\r\n\r\n                    if ((finalMovementInfo.x !== pX) || (finalMovementInfo.y !== pY)) {\r\n                        this.updateAgainst(ent);\r\n                    }\r\n                }\r\n                \r\n                finalMovementInfo.recycle();\r\n                \r\n                return collisionDataCollection;\r\n            },\r\n            \r\n            processCollisionStep: (function () {\r\n                var sweeper       = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(),\r\n                    includeEntity = function (thisEntity, aabb, otherEntity, otherAABB, ignoredEntities, sweepAABB) {\r\n                        var i = 0;\r\n                        \r\n                        //Chop out all the special case entities we don't want to check against.\r\n                        if (otherEntity === thisEntity) {\r\n                            return false;\r\n                        } else if (otherEntity.jumpThrough && (aabb.bottom > otherAABB.top)) {\r\n                            return false;\r\n                        } else if (thisEntity.jumpThrough  && (otherAABB.bottom > aabb.top)) { // This will allow platforms to hit something solid sideways if it runs into them from the side even though originally they were above the top. - DDD\r\n                            return false;\r\n                        } else if (ignoredEntities) {\r\n                            i = ignoredEntities.length;\r\n                            while (i--) {\r\n                                if (otherEntity === ignoredEntities[i]) {\r\n                                    return false;\r\n                                }\r\n                            }\r\n                        }\r\n                        \r\n                        return sweepAABB.collides(otherAABB);\r\n                    };\r\n\r\n                return function (ent, entityOrGroup, ignoredEntities, collisionDataCollection, finalMovementInfo, entityDeltaX, entityDeltaY, collisionTypes) {\r\n                    var i = collisionTypes.length,\r\n                        j = 0,\r\n                        k = 0,\r\n                        l = 0,\r\n                        isIncluded = includeEntity,\r\n                        potentialCollision       = false,\r\n                        potentialCollidingShapes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                        pcsGroup                 = null,\r\n                        previousAABB             = null,\r\n                        currentAABB              = null,\r\n                        collisionType            = null,\r\n                        otherEntity              = null,\r\n                        otherCollisionType       = '',\r\n                        otherAABB                = null,\r\n                        otherShapes              = null,\r\n                        otherEntities            = null,\r\n                        terrain                  = this.terrain,\r\n                        againstGrid          = null,\r\n                        solidCollisionMap        = entityOrGroup.getSolidCollisions(),\r\n                        collisionSubTypes        = null,\r\n                        sweepAABB                = sweeper;\r\n                    \r\n//                    if (!entityOrGroup.jumpThrough || (entityDeltaY >= 0)) { //TODO: Need to extend jumpthrough to handle different directions and forward motion - DDD\r\n    \r\n                    while (i--) {\r\n                        //Sweep the full movement of each collision type\r\n                        potentialCollidingShapes[i] = pcsGroup = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                        collisionType = collisionTypes[i];\r\n                        previousAABB = entityOrGroup.getPreviousAABB(collisionType);\r\n                        currentAABB = entityOrGroup.getAABB(collisionType);\r\n\r\n                        sweepAABB.set(currentAABB);\r\n                        sweepAABB.include(previousAABB);\r\n                        \r\n                        collisionSubTypes = solidCollisionMap.get(collisionType);\r\n                        againstGrid = this.getAgainstGrid(ent, sweepAABB, collisionSubTypes);\r\n                        j = collisionSubTypes.length;\r\n                        while (j--) {\r\n                            otherCollisionType = collisionSubTypes[j];\r\n                            otherEntities = againstGrid[otherCollisionType];\r\n\r\n                            if (otherEntities) {\r\n                                k = otherEntities.length;\r\n                                while (k--) {\r\n                                    otherEntity = otherEntities[k];\r\n                                    otherAABB = otherEntity.getAABB(otherCollisionType);\r\n\r\n                                    //Do our sweep check against the AABB of the other object and add potentially colliding shapes to our list.\r\n                                    if (isIncluded(ent, previousAABB, otherEntity, otherAABB, ignoredEntities, sweepAABB)) {\r\n                                        otherShapes = otherEntity.getShapes(otherCollisionType);\r\n                                        \r\n                                        l = otherShapes.length;\r\n                                        while (l--) {\r\n                                            //Push the shapes on the end!\r\n                                            pcsGroup.push(otherShapes[l]);\r\n                                        }\r\n                                        potentialCollision = true;\r\n                                    }\r\n                                }\r\n                                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(otherEntities);\r\n                            } else if (terrain) {\r\n                                //Do our sweep check against the tiles and add potentially colliding shapes to our list.\r\n                                otherShapes = terrain.getTileShapes(sweepAABB, previousAABB, otherCollisionType);\r\n                                k = otherShapes.length;\r\n                                while (k--) {\r\n                                    //Push the shapes on the end!\r\n                                    pcsGroup.push(otherShapes[k]);\r\n                                    potentialCollision = true;\r\n                                }\r\n                            }\r\n                        }\r\n                        againstGrid.recycle();\r\n                    }\r\n\r\n                    if (potentialCollision) {\r\n                        finalMovementInfo = this.resolveCollisionPosition(ent, entityOrGroup, finalMovementInfo, potentialCollidingShapes, collisionDataCollection, collisionTypes, entityDeltaX, entityDeltaY);\r\n                    }\r\n                    \r\n                    // Array recycling\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(potentialCollidingShapes, 2);\r\n                    \r\n                    return finalMovementInfo;\r\n                };\r\n            }()),\r\n            \r\n            resolveCollisionPosition: function (ent, entityOrGroup, finalMovementInfo, potentialCollidingShapes, collisionDataCollection, collisionTypes, entityDeltaX, entityDeltaY) {\r\n                var j = 0,\r\n                    cd = null;\r\n                \r\n                if (entityDeltaX !== 0) {\r\n                    j = collisionTypes.length;\r\n                    while (j--) {\r\n                        //Move each collision type in X to find the min X movement\r\n                        cd = this.findMinAxisMovement(ent, entityOrGroup, collisionTypes[j], 'x', potentialCollidingShapes[j]);\r\n                        \r\n                        if (!cd.occurred || !collisionDataCollection.tryToAddX(cd)) {\r\n                            cd.recycle();\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                cd = collisionDataCollection.xData[0];\r\n                if (cd) {\r\n                    finalMovementInfo.x = ent.previousX + cd.deltaMovement * cd.direction;\r\n                } else {\r\n                    finalMovementInfo.x = ent.x;\r\n                }\r\n                \r\n                // This moves the previous position of everything so that the check in Y can begin.\r\n                entityOrGroup.movePreviousX(finalMovementInfo.x);\r\n                \r\n                if (entityDeltaY !== 0) {\r\n                    j = collisionTypes.length;\r\n                    while (j--) {\r\n                        //Move each collision type in Y to find the min Y movement\r\n                        cd = this.findMinAxisMovement(ent, entityOrGroup, collisionTypes[j], 'y', potentialCollidingShapes[j]);\r\n                        \r\n                        if (!cd.occurred || !collisionDataCollection.tryToAddY(cd)) {\r\n                            cd.recycle();\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                cd = collisionDataCollection.yData[0];\r\n                if (cd) {\r\n                    finalMovementInfo.y = ent.previousY + cd.deltaMovement * cd.direction;\r\n                } else {\r\n                    finalMovementInfo.y = ent.y;\r\n                }\r\n                \r\n                return finalMovementInfo;\r\n            },\r\n            \r\n            findMinAxisMovement: function (ent, entityOrGroup, collisionType, axis, potentialCollidingShapes) {\r\n                //Loop through my shapes of this type vs the colliding shapes and do precise collision returning the shortest movement in axis direction\r\n                var bestCD     = _CollisionData_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(),\r\n                    shapes     = entityOrGroup.getShapes(collisionType),\r\n                    prevShapes = entityOrGroup.getPrevShapes(collisionType),\r\n                    cd         = null,\r\n                    i          = shapes.length;\r\n                \r\n                while (i--) {\r\n                    cd = this.findMinShapeMovementCollision(prevShapes[i], shapes[i], axis, potentialCollidingShapes);\r\n                    \r\n                    if (cd.occurred && (!bestCD.occurred //if a collision occurred and we haven't already had a collision.\r\n                        || (cd.deltaMovement < bestCD.deltaMovement))) { //if a collision occurred and the diff is smaller than our best diff.\r\n                        bestCD.recycle();\r\n                        bestCD = cd;\r\n                    } else {\r\n                        cd.recycle();\r\n                    }\r\n                }\r\n                \r\n                return bestCD;\r\n            },\r\n            \r\n            /**\r\n             * Find the earliest point at which this shape collides with one of the potential colliding shapes along this axis.\r\n             * For example, cycles through shapes a, b, and c to find the earliest position:\r\n             *\r\n             *    O---->   [b]  [a]     [c]\r\n             *\r\n             *    Returns collision location for:\r\n             *\r\n             *            O[b]\r\n             *\r\n             */\r\n            findMinShapeMovementCollision: (function () {\r\n                var returnInfo = {\r\n                        position: 0,\r\n                        contactVector: _Vector_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].setUp()\r\n                    },\r\n                    getMovementDistance = function (currentDistance, minimumDistance) {\r\n                        var pow = Math.pow;\r\n                        \r\n                        return Math.sqrt(pow(minimumDistance, 2) - pow(currentDistance, 2));\r\n                    },\r\n                    getCorner = function (circlePos, rectanglePos, half) {\r\n                        var diff = circlePos - rectanglePos;\r\n                        \r\n                        return diff - (diff / Math.abs(diff)) * half;\r\n                    },\r\n                    getOffsetForCircleVsAABBX = function (circle, rect, moving, direction, v) {\r\n                        var newAxisPosition = 0,\r\n                            aabb = rect.aABB,\r\n                            hw = aabb.halfWidth,\r\n                            x = circle.x,\r\n                            y = circle.y;\r\n\r\n                        if (y >= aabb.top && y <= aabb.bottom) {\r\n                            return hw + circle.radius;\r\n                        } else {\r\n                            y = getCorner(y, rect.y, aabb.halfHeight); // reusing y.\r\n                            newAxisPosition = hw + getMovementDistance(y, circle.radius);\r\n                            if (moving === circle) {\r\n                                v.x = -getCorner(x - direction * newAxisPosition, rect.x, hw) / 2;\r\n                                y = -y;\r\n                            } else {\r\n                                v.x = getCorner(x, rect.x - direction * newAxisPosition, hw) / 2;\r\n                            }\r\n                            v.y = y;\r\n                            v.normalize();\r\n                            return newAxisPosition;\r\n                        }\r\n                    },\r\n                    getOffsetForCircleVsAABBY = function (circle, rect, moving, direction, v) {\r\n                        var newAxisPosition = 0,\r\n                            aabb = rect.aABB,\r\n                            hh = aabb.halfHeight,\r\n                            x = circle.x,\r\n                            y = circle.y;\r\n\r\n                        if (x >= aabb.left && x <= aabb.right) {\r\n                            return hh + circle.radius;\r\n                        } else {\r\n                            x = getCorner(x, rect.x, aabb.halfWidth); // reusing x.\r\n                            newAxisPosition = hh + getMovementDistance(x, circle.radius);\r\n                            if (moving === circle) {\r\n                                x = -x;\r\n                                v.y = -getCorner(y - direction * newAxisPosition, rect.y, hh) / 2;\r\n                            } else {\r\n                                v.y = getCorner(y, rect.y - direction * newAxisPosition, hh) / 2;\r\n                            }\r\n                            v.x = x;\r\n                            v.normalize();\r\n                            return newAxisPosition;\r\n                        }\r\n                    },\r\n                    findAxisCollisionPosition = { // Decision tree for quicker access, optimized for mobile devices.\r\n                        x: {\r\n                            rectangle: {\r\n                                rectangle: function (direction, thisShape, thatShape) {\r\n                                    var ri = returnInfo;\r\n\r\n                                    ri.position = thatShape.x - direction * (thatShape.aABB.halfWidth + thisShape.aABB.halfWidth);\r\n                                    ri.contactVector.setXYZ(direction, 0);\r\n\r\n                                    return ri;\r\n                                },\r\n                                circle: function (direction, thisShape, thatShape) {\r\n                                    var ri = returnInfo;\r\n\r\n                                    ri.position = thatShape.x - direction * getOffsetForCircleVsAABBX(thatShape, thisShape, thisShape, direction, ri.contactVector.setXYZ(direction, 0));\r\n\r\n                                    return ri;\r\n                                }\r\n                            },\r\n                            circle: {\r\n                                rectangle: function (direction, thisShape, thatShape) {\r\n                                    var ri = returnInfo;\r\n\r\n                                    ri.position = thatShape.x - direction * getOffsetForCircleVsAABBX(thisShape, thatShape, thisShape, direction, ri.contactVector.setXYZ(direction, 0));\r\n\r\n                                    return ri;\r\n                                },\r\n                                circle: function (direction, thisShape, thatShape) {\r\n                                    var y = thatShape.y - thisShape.y,\r\n                                        position = thatShape.x - direction * getMovementDistance(y, thisShape.radius + thatShape.radius),\r\n                                        ri = returnInfo;\r\n                                        \r\n                                    ri.contactVector.setXYZ(thatShape.x - position, y).normalize();\r\n                                    ri.position = position;\r\n\r\n                                    return ri;\r\n                                }\r\n                            }\r\n                        },\r\n                        y: {\r\n                            rectangle: {\r\n                                rectangle: function (direction, thisShape, thatShape) {\r\n                                    var ri = returnInfo;\r\n\r\n                                    ri.position = thatShape.y - direction * (thatShape.aABB.halfHeight + thisShape.aABB.halfHeight);\r\n                                    ri.contactVector.setXYZ(0, direction);\r\n                                    \r\n                                    return ri;\r\n                                },\r\n                                circle: function (direction, thisShape, thatShape) {\r\n                                    var ri = returnInfo;\r\n\r\n                                    ri.position = thatShape.y - direction * getOffsetForCircleVsAABBY(thatShape, thisShape, thisShape, direction, ri.contactVector.setXYZ(0, direction));\r\n\r\n                                    return ri;\r\n                                }\r\n                            },\r\n                            circle: {\r\n                                rectangle: function (direction, thisShape, thatShape) {\r\n                                    var ri = returnInfo;\r\n\r\n                                    ri.position = thatShape.y - direction * getOffsetForCircleVsAABBY(thisShape, thatShape, thisShape, direction, ri.contactVector.setXYZ(0, direction));\r\n\r\n                                    return ri;\r\n                                },\r\n                                circle: function (direction, thisShape, thatShape) {\r\n                                    var x = thatShape.x - thisShape.x,\r\n                                        position = thatShape.y - direction * getMovementDistance(x, thisShape.radius + thatShape.radius),\r\n                                        ri = returnInfo;\r\n                                        \r\n                                    ri.contactVector.setXYZ(x, thatShape.y - position).normalize();\r\n                                    ri.position = position;\r\n\r\n                                    return ri;\r\n                                }\r\n                            }\r\n                        }\r\n                    };\r\n                \r\n                return function (prevShape, currentShape, axis, potentialCollidingShapes) {\r\n                    var i = 0,\r\n                        initialPoint    = prevShape[axis],\r\n                        goalPoint       = currentShape[axis],\r\n                        translatedShape = prevShape,\r\n                        direction       = ((initialPoint < goalPoint) ? 1 : -1),\r\n                        position        = goalPoint,\r\n                        pcShape         = null,\r\n                        cd              = _CollisionData_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(),\r\n                        collisionInfo   = null,\r\n                        finalPosition   = goalPoint,\r\n                        findACP         = null;\r\n                    \r\n                    if (initialPoint !== goalPoint) {\r\n                        findACP = findAxisCollisionPosition[axis][translatedShape.type];\r\n                        \r\n                        if (axis === 'x') {\r\n                            translatedShape.moveX(goalPoint);\r\n                        } else if (axis === 'y') {\r\n                            translatedShape.moveY(goalPoint);\r\n                        }\r\n                        \r\n                        i = potentialCollidingShapes.length;\r\n                        while (i--) {\r\n                            pcShape = potentialCollidingShapes[i];\r\n                            position = goalPoint;\r\n                            if (translatedShape.collides(pcShape)) {\r\n                                collisionInfo = findACP[pcShape.type](direction, translatedShape, pcShape);\r\n                                position = collisionInfo.position;\r\n                                if (direction > 0) {\r\n                                    if (position < finalPosition) {\r\n                                        if (position < initialPoint) { // Reality check: I think this is necessary due to floating point inaccuracies. - DDD\r\n                                            position = initialPoint;\r\n                                        }\r\n                                        finalPosition = position;\r\n                                        cd.set(true, direction, finalPosition, Math.abs(finalPosition - initialPoint), pcShape.aABB, currentShape, pcShape, collisionInfo.contactVector, 0);\r\n                                    }\r\n                                } else if (position > finalPosition) {\r\n                                    if (position > initialPoint) { // Reality check: I think this is necessary due to floating point inaccuracies. - DDD\r\n                                        position = initialPoint;\r\n                                    }\r\n                                    finalPosition = position;\r\n                                    cd.set(true, direction, finalPosition, Math.abs(finalPosition - initialPoint), pcShape.aABB, currentShape, pcShape, collisionInfo.contactVector, 0);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n                    return cd;\r\n                };\r\n            }()),\r\n            \r\n            checkSoftCollisions: (function () {\r\n                var\r\n                    trigger = function (collision) {\r\n                        this.triggerEvent('hit-by-' + collision.type, collision);\r\n                    };\r\n                \r\n                return function () {\r\n                    var softs = this.softEntitiesLive,\r\n                        entity = null,\r\n                        i = softs.length,\r\n                        t = trigger;\r\n                        \r\n                    while (i--) {\r\n                        entity = softs[i];\r\n                        this.checkEntityForSoftCollisions(entity, t.bind(entity));\r\n                    }\r\n                };\r\n            }()),\r\n            \r\n            checkEntityForSoftCollisions: function (ent, callback) {\r\n                var againstGrid = null,\r\n                    otherEntity = null,\r\n                    message = triggerMessage,\r\n                    i   = ent.collisionTypes.length,\r\n                    j   = 0,\r\n                    k   = 0,\r\n                    l   = 0,\r\n                    m   = 0,\r\n                    collisionType = null,\r\n                    softCollisionMap = null,\r\n                    otherEntities  = null,\r\n                    otherCollisionType = null,\r\n                    shapes = null,\r\n                    otherShapes = null,\r\n                    collisionFound = false;\r\n\r\n                message.x = 0;\r\n                message.y = 0;\r\n\r\n                while (i--) {\r\n                    collisionType = ent.collisionTypes[i];\r\n                    softCollisionMap = ent.softCollisionMap.get(collisionType);\r\n                    againstGrid = this.getEntityAgainstGrid(ent, softCollisionMap);\r\n                    j = softCollisionMap.length;\r\n                    while (j--) {\r\n                        otherCollisionType = softCollisionMap[j];\r\n                        otherEntities = againstGrid[otherCollisionType];\r\n                        if (otherEntities) {\r\n                            k = otherEntities.length;\r\n                            while (k--) {\r\n                                otherEntity = otherEntities[k];\r\n                                if ((otherEntity !== ent) && (ent.getAABB(collisionType).collides(otherEntity.getAABB(otherCollisionType)))) {\r\n                                    collisionFound = false;\r\n                                    shapes = ent.getShapes(collisionType);\r\n                                    otherShapes = otherEntity.getShapes(otherCollisionType);\r\n                                    l = shapes.length;\r\n                                    while (l--) {\r\n                                        m = otherShapes.length;\r\n                                        while (m--) {\r\n                                            if (shapes[l].collides(otherShapes[m])) {\r\n                                                //TML - We're only reporting the first shape we hit even though there may be multiple that we could be hitting.\r\n                                                message.entity  = otherEntity;\r\n                                                message.target  = ent;\r\n                                                message.type    = otherCollisionType;\r\n                                                message.myType  = collisionType;\r\n                                                message.shape   = otherShapes[m];\r\n                                                message.hitType = 'soft';\r\n                                                \r\n                                                callback(message);\r\n                                                \r\n                                                collisionFound = true;\r\n                                                break;\r\n                                            }\r\n                                        }\r\n                                        if (collisionFound) {\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(otherEntities);\r\n                        }\r\n                    }\r\n                    againstGrid.recycle();\r\n                }\r\n            },\r\n\r\n\r\n            checkShapeForCollisions: function (shape, softCollisionMap, callback) {\r\n                var againstGrid = null,\r\n                    otherEntity = null,\r\n                    message = triggerMessage,\r\n                    j   = 0,\r\n                    k   = 0,\r\n                    m   = 0,\r\n                    otherEntities  = null,\r\n                    otherCollisionType = null,\r\n                    otherShapes = null,\r\n                    collisionFound = false;\r\n\r\n                message.x = 0;\r\n                message.y = 0;\r\n\r\n                againstGrid = this.getAgainstGrid(null, shape.getAABB(), softCollisionMap);\r\n                j = softCollisionMap.length;\r\n                while (j--) {\r\n                    otherCollisionType = softCollisionMap[j];\r\n                    otherEntities = againstGrid[otherCollisionType];\r\n                    if (otherEntities) {\r\n                        k = otherEntities.length;\r\n                        while (k--) {\r\n                            otherEntity = otherEntities[k];\r\n                            if ((shape.getAABB().collides(otherEntity.getAABB(otherCollisionType)))) {\r\n                                collisionFound = false;\r\n                                otherShapes = otherEntity.getShapes(otherCollisionType);\r\n                                m = otherShapes.length;\r\n                                while (m--) {\r\n                                    if (shape.collides(otherShapes[m])) {\r\n                                        //TML - We're only reporting the first shape we hit even though there may be multiple that we could be hitting.\r\n                                        message.entity  = otherEntity;\r\n                                        message.target  = null;\r\n                                        message.type    = otherCollisionType;\r\n                                        message.myType  = '';\r\n                                        message.shape   = otherShapes[m];\r\n                                        message.hitType = 'soft';\r\n                                        \r\n                                        callback(message);\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(otherEntities);\r\n                    }\r\n                }\r\n                againstGrid.recycle();\r\n            },\r\n\r\n            \r\n            checkPointForCollisions: function (x, y, collisions, callback) {\r\n                var gb = this.gridBits,\r\n                    againstGrid = this.againstGrid[getBucketId(x, y, gb)],\r\n                    otherEntity = null,\r\n                    message = triggerMessage,\r\n                    j   = 0,\r\n                    k   = 0,\r\n                    m   = 0,\r\n                    otherEntities  = null,\r\n                    otherCollisionType = null,\r\n                    otherShapes = null;\r\n\r\n                message.x = 0;\r\n                message.y = 0;\r\n\r\n                if (!againstGrid) {\r\n                    return;\r\n                }\r\n                \r\n                j = collisions.length;\r\n                while (j--) {\r\n                    otherCollisionType = collisions[j];\r\n                    otherEntities = againstGrid.get(otherCollisionType);\r\n                    if (otherEntities) {\r\n                        k = otherEntities.length;\r\n                        while (k--) {\r\n                            otherEntity = otherEntities[k];\r\n                            if (otherEntity.getAABB(otherCollisionType).containsPoint(x, y)) {\r\n                                otherShapes = otherEntity.getShapes(otherCollisionType);\r\n                                m = otherShapes.length;\r\n                                while (m--) {\r\n                                    if (otherShapes[m].containsPoint(x, y)) {\r\n                                        //TML - We're only reporting the first shape we hit even though there may be multiple that we could be hitting.\r\n                                        message.entity  = otherEntity;\r\n                                        message.target  = null;\r\n                                        message.type    = otherCollisionType;\r\n                                        message.myType  = '';\r\n                                        message.shape   = otherShapes[m];\r\n                                        message.hitType = 'soft';\r\n                                        \r\n                                        callback(message);\r\n                                        \r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            \r\n            destroy: function () {\r\n                var ag = this.againstGrid,\r\n                    data = null,\r\n                    key = '',\r\n                    keys = null,\r\n                    i = 0;\r\n                \r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.groupsLive);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.nonColliders);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.allEntitiesLive);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.softEntitiesLive);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.solidEntitiesLive);\r\n                this.relocationMessage.position.recycle();\r\n                this.relocationMessage.recycle();\r\n                \r\n                for (key in ag) {\r\n                    if (ag.hasOwnProperty(key)) {\r\n                        data = ag[key];\r\n                        keys = data.keys;\r\n                        i = keys.length;\r\n                        while (i--) {\r\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(data.get(keys[i]));\r\n                        }\r\n                        data.recycle();\r\n                    }\r\n                }\r\n                ag.recycle();\r\n                this.againstGrid = null;\r\n            }\r\n        },\r\n        \r\n        publicMethods: {\r\n            /**\r\n             * This method returns an object containing world entities.\r\n             *\r\n             * @method getWorldEntities\r\n             * @return {Array} A list of all world collision entities.\r\n             */\r\n            getWorldEntities: function () {\r\n                return this.allEntitiesLive;\r\n            },\r\n            \r\n            /**\r\n             * This method returns an entity representing the collision map of the world.\r\n             *\r\n             * @method getWorldTerrain\r\n             * @return {Entity} - An entity describing the collision map of the world. This entity typically includes a `CollisionTiles` component.\r\n             */\r\n            getWorldTerrain: function () {\r\n                return this.terrain;\r\n            },\r\n            \r\n            /**\r\n             * This method returns a list of collision objects describing soft collisions between an entity and a list of other entities.\r\n             *\r\n             * @method getEntityCollisions\r\n             * @param entity {Entity} The entity to test against the world.\r\n             * @return collisions {Array} This is a list of collision objects describing the soft collisions.\r\n             */\r\n            getEntityCollisions: function (entity) {\r\n                var collisions = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                \r\n                this.checkEntityForSoftCollisions(entity, function (collision) {\r\n                    collisions.push(_Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(collision));\r\n                });\r\n                \r\n                return collisions;\r\n            },\r\n            \r\n            /**\r\n             * This method returns a list of collision objects describing collisions between a shape and a list of other entities.\r\n             *\r\n             * @method getShapeCollisions\r\n             * @param shape {CollisionShape} The shape to check for collisions.\r\n             * @param collisionTypes {Array of strings} The collision types to check against.\r\n             * @return collisions {Array} This is a list of collision objects describing the soft collisions.\r\n             * @since 0.11.2\r\n             */\r\n            getShapeCollisions: function (shape, collisionTypes) {\r\n                var collisions = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                \r\n                this.checkShapeForCollisions(shape, collisionTypes, function (collision) {\r\n                    collisions.push(_Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(collision));\r\n                });\r\n                \r\n                return collisions;\r\n            },\r\n\r\n            /**\r\n             * This method returns a list of collision objects describing collisions between a point and a list of other entities.\r\n             *\r\n             * @method getPointCollisions\r\n             * @param x {number} The x-axis value.\r\n             * @param y {number} The y-axis value.\r\n             * @param collisionTypes {Array of strings} The collision types to check against.\r\n             * @return collisions {Array} This is a list of collision objects describing the soft collisions.\r\n             * @since 0.11.0\r\n             */\r\n            getPointCollisions: function (x, y, collisionTypes) {\r\n                var collisions = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                \r\n                this.checkPointForCollisions(x, y, collisionTypes, function (collision) {\r\n                    collisions.push(_Data_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(collision));\r\n                });\r\n                \r\n                return collisions;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/HandlerCollision.js?");

/***/ }),

/***/ "./src/components/HandlerController.js":
/*!*********************************************!*\
  !*** ./src/components/HandlerController.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * This component handles capturing and relaying input information to the entities that care about it. It takes mouse, keyboard, and custom input messages. State messages are sent immediately to the entities when they are received, the 'HandlerController' message is sent to demarcate ticks.\r\n *\r\n * @namespace platypus.components\r\n * @class HandlerController\r\n * @uses platypus.Component\r\n */\r\n/* global platypus, window */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n\r\n    var\r\n        keyMap = { //Note: if this list is changed, be sure to update https://github.com/PBS-KIDS/Platypus/wiki/Handler-controller-key-list\r\n            kc0: 'unknown',\r\n            kc8: 'backspace',\r\n            kc9: 'tab',\r\n            kc12: 'numpad-5-shift',\r\n            kc13: 'enter',\r\n            kc16: 'shift',\r\n            kc17: 'ctrl',\r\n            kc18: 'alt',\r\n            kc19: 'pause',\r\n            kc20: 'caps-lock',\r\n            kc27: 'esc',\r\n            kc32: 'space',\r\n            kc33: 'page-up',\r\n            kc34: 'page-down',\r\n            kc35: 'end',\r\n            kc36: 'home',\r\n            kc37: 'left-arrow',\r\n            kc38: 'up-arrow',\r\n            kc39: 'right-arrow',\r\n            kc40: 'down-arrow',\r\n            kc42: 'numpad-multiply',\r\n            kc43: 'numpad-add',\r\n            kc44: 'print-screen',\r\n            kc45: 'insert',\r\n            kc46: 'delete',\r\n            kc47: 'numpad-division',\r\n            kc48: '0',\r\n            kc49: '1',\r\n            kc50: '2',\r\n            kc51: '3',\r\n            kc52: '4',\r\n            kc53: '5',\r\n            kc54: '6',\r\n            kc55: '7',\r\n            kc56: '8',\r\n            kc57: '9',\r\n            kc59: 'semicolon',\r\n            kc61: 'equals',\r\n            kc65: 'a',\r\n            kc66: 'b',\r\n            kc67: 'c',\r\n            kc68: 'd',\r\n            kc69: 'e',\r\n            kc70: 'f',\r\n            kc71: 'g',\r\n            kc72: 'h',\r\n            kc73: 'i',\r\n            kc74: 'j',\r\n            kc75: 'k',\r\n            kc76: 'l',\r\n            kc77: 'm',\r\n            kc78: 'n',\r\n            kc79: 'o',\r\n            kc80: 'p',\r\n            kc81: 'q',\r\n            kc82: 'r',\r\n            kc83: 's',\r\n            kc84: 't',\r\n            kc85: 'u',\r\n            kc86: 'v',\r\n            kc87: 'w',\r\n            kc88: 'x',\r\n            kc89: 'y',\r\n            kc90: 'z',\r\n            kc91: 'left-windows-start',\r\n            kc92: 'right-windows-start',\r\n            kc93: 'windows-menu',\r\n            kc96: 'back-quote',\r\n            kc106: 'numpad-multiply',\r\n            kc107: 'numpad-add',\r\n            kc109: 'numpad-minus',\r\n            kc110: 'numpad-period',\r\n            kc111: 'numpad-division',\r\n            kc112: 'f1',\r\n            kc113: 'f2',\r\n            kc114: 'f3',\r\n            kc115: 'f4',\r\n            kc116: 'f5',\r\n            kc117: 'f6',\r\n            kc118: 'f7',\r\n            kc119: 'f8',\r\n            kc120: 'f9',\r\n            kc121: 'f10',\r\n            kc122: 'f11',\r\n            kc123: 'f12',\r\n            kc144: 'num-lock',\r\n            kc145: 'scroll-lock',\r\n            kc186: 'semicolon',\r\n            kc187: 'equals',\r\n            kc188: 'comma',\r\n            kc189: 'hyphen',\r\n            kc190: 'period',\r\n            kc191: 'forward-slash',\r\n            kc192: 'back-quote',\r\n            kc219: 'open-bracket',\r\n            kc220: 'back-slash',\r\n            kc221: 'close-bracket',\r\n            kc222: 'quote'\r\n        };\r\n\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'HandlerController',\r\n        \r\n        initialize: function () {\r\n            this.callbackKeyUp   = null;\r\n            this.callbackKeyDown = null;\r\n            \r\n            if (platypus.game.settings.debug) { // If this is a test build, leave in the browser key combinations so debug tools can be opened as expected.\r\n                this.callbackKeyDown = function (event) {\r\n                    this.keyDown(event);\r\n                }.bind(this);\r\n                this.callbackKeyUp = function (event) {\r\n                    this.keyUp(event);\r\n                }.bind(this);\r\n            } else { // Otherwise remove default browser behavior for key inputs so that they do not interfere with game-play.\r\n                this.callbackKeyDown = function (event) {\r\n                    this.keyDown(event);\r\n                    event.preventDefault(); // this may be too aggressive - if problems arise, we may need to limit this to certain key combos that get in the way of game-play. Example: (event.metaKey && event.keyCode == 37) causes an accidental cmd key press to send the browser back a page while playing and hitting the left arrow button.\r\n                }.bind(this);\r\n                this.callbackKeyUp = function (event) {\r\n                    this.keyUp(event);\r\n                    event.preventDefault(); // this may be too aggressive - if problems arise, we may need to limit this to certain key combos that get in the way of game-play. Example: (event.metaKey && event.keyCode == 37) causes an accidental cmd key press to send the browser back a page while playing and hitting the left arrow button.\r\n                }.bind(this);\r\n            }\r\n            \r\n            window.addEventListener('keydown', this.callbackKeyDown, true);\r\n            window.addEventListener('keyup',   this.callbackKeyUp,   true);\r\n        },\r\n        events: {\r\n            /**\r\n             * Sends a 'handle-controller' message to all the entities the component is handling. If an entity does not handle the message, it's removed it from the entity list.\r\n             *\r\n             * @method 'tick'\r\n             * @param tick {Object} An object containing tick data.\r\n             */\r\n            \"tick\": function (tick) {\r\n\r\n                /**\r\n                 * Sent to entities on each tick to handle whatever they need to regarding controls.\r\n                 *\r\n                 * @event 'handle-controller'\r\n                 * @param tick {Object} An object containing tick data.\r\n                 */\r\n                if (this.owner.triggerEventOnChildren) {\r\n                    this.owner.triggerEventOnChildren('handle-controller', tick);\r\n                }\r\n            }\r\n        },\r\n        methods: {\r\n            keyDown: function (event) {\r\n\r\n                /**\r\n                 *  Message sent to an entity when a key goes from up to down.\r\n                 *\r\n                 * @event 'key:[keyId]:down'\r\n                 * @param event {DOMEvent} The DOM event that triggered the keydown event.\r\n                 */\r\n                if (this.owner.triggerEventOnChildren) {\r\n                    this.owner.triggerEventOnChildren('key:' + (keyMap['kc' + event.keyCode] || ('key-code-' + event.keyCode)) + ':down', event);\r\n                }\r\n            },\r\n            keyUp: function (event) {\r\n\r\n                /**\r\n                 * Message sent to child entities when a key goes from down to up.\r\n                 *\r\n                 * @event 'key:[keyId]:up'\r\n                 * @param event {DOMEvent} The DOM event that triggered the keyup event.\r\n                 */\r\n                if (this.owner.triggerEventOnChildren) {\r\n                    this.owner.triggerEventOnChildren('key:' + (keyMap['kc' + event.keyCode] || ('key-code-' + event.keyCode)) + ':up', event);\r\n                }\r\n            },\r\n            destroy: function () {\r\n                window.removeEventListener('keydown', this.callbackKeyDown);\r\n                window.removeEventListener('keyup',   this.callbackKeyUp);\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/HandlerController.js?");

/***/ }),

/***/ "./src/components/HandlerLogic.js":
/*!****************************************!*\
  !*** ./src/components/HandlerLogic.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/**\r\n * A component that handles updating logic components. Each tick it calls all the entities that accept 'handle-logic' messages. This component is usually used on an \"action-layer\".\r\n *\r\n * @namespace platypus.components\r\n * @class HandlerLogic\r\n * @uses platypus.Component\r\n **/\r\n/* global platypus */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var addAll = function (all, active) {\r\n            var j = all.length;\r\n            \r\n            active.length = 0;\r\n            while (j--) {\r\n                active.push(all[j]);\r\n            }\r\n        },\r\n        withinBounds = function (child, camera) {\r\n            return child.alwaysOn || (child.aabb && camera.collides(child.getAABB())) || (typeof child.x === 'undefined') || camera.containsPoint(child.x, child.y);\r\n        },\r\n        checkCamera = function (all, active, camera) {\r\n            var j = all.length,\r\n                child = null;\r\n            \r\n            active.length = 0;\r\n            while (j--) {\r\n                child = all[j];\r\n                if (withinBounds(child, camera)) {\r\n                    active.push(child);\r\n                }\r\n            }\r\n        },\r\n        hasLogic = function (item/*, index, arr*/) {\r\n            return (item === 'handle-logic' || item === 'handle-post-collision-logic' || item === 'prepare-logic' || item === 'state-changed' || item === 'handle-movement');\r\n        };\r\n\r\n    return platypus.createComponentClass({\r\n        id: \"HandlerLogic\",\r\n        properties: {\r\n            /**\r\n             * Whether logic should always run on all entities or only run on entities within the visible camera area (plus the buffer amount specified by the `buffer` property).\r\n             *\r\n             * @property alwaysOn\r\n             * @type Boolean\r\n             * @default false\r\n             * @since 0.7.1\r\n             */\r\n            alwaysOn: false\r\n        },\r\n        publicProperties: {\r\n            /**\r\n             * The buffer area around the camera in which entity logic is active. This property is available on the Entity as `entity.buffer`.\r\n             *\r\n             * @property buffer\r\n             * @type number\r\n             * @default camera width / 10\r\n             */\r\n            buffer: -1,\r\n            \r\n            /**\r\n             * The length in milliseconds of a single logic step. If the framerate drops too low, logic is run for each step of this many milliseconds. This property is available on the Entity as `entity.stepLength`.\r\n             *\r\n             * @property stepLength\r\n             * @type number\r\n             * @default 5\r\n             */\r\n            stepLength: 5,\r\n            \r\n            /**\r\n             * The maximum number of steps to take for a given tick, to prevent lag overflow.\r\n             *\r\n             * @property maxStepsPerTick\r\n             * @type number\r\n             * @default 100\r\n             */\r\n            maxStepsPerTick: 100,\r\n            \r\n            /**\r\n             * Whether logic should occur at an alternate speed. This is useful for simulations where the game should speed up or slow down.\r\n             *\r\n             * @property timeMultiplier\r\n             * @type number\r\n             * @default 1\r\n             * @since 0.7.1\r\n             */\r\n            timeMultiplier: 1\r\n        },\r\n        initialize: function () {\r\n            this.entities = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.activeEntities = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.removals = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            \r\n            this.inLogicLoop = false;\r\n\r\n            if (this.alwaysOn) {\r\n                this.updateList = addAll;\r\n                this.camera = null;\r\n            } else {\r\n                this.updateList = checkCamera;\r\n                this.camera = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\r\n            }\r\n            \r\n            this.paused = 0;\r\n            this.leftoverTime = 0;\r\n            this.message = {\r\n                delta: this.stepLength,\r\n                tick: null,\r\n                camera: this.camera,\r\n                entities: this.activeEntities\r\n            };\r\n        },\r\n        \r\n        events: {\r\n            /**\r\n             * Called when an entity has been updated and should be considered for adding to or removing from the handler.\r\n             *\r\n             * @method 'child-entity-updated'\r\n             * @param entity {platypus.Entity} The entity that is being considered.\r\n             * @since v0.12.0\r\n             */\r\n            \"child-entity-updated\": function (entity) {\r\n                var j = this.entities.indexOf(entity),\r\n                    logical = entity.getMessageIds().some(hasLogic);\r\n\r\n                if (logical && (j < 0)) {\r\n                    this.entities.push(entity);\r\n                    \r\n                    // Add to the active entities list so that the collision loop is aware of and can handle the addition.\r\n                    if (this.inLogicLoop && (!this.camera || withinBounds(entity, this.camera))) {\r\n                        this.activeEntities.push(entity);\r\n                    }\r\n                } else if (!logical && (j >= 0)) {\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.entities, j);\r\n                    if (this.inLogicLoop) {\r\n                        this.removals.push(entity);\r\n                    }\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Called when a new entity has been added and should be considered for addition to the handler. If the entity has a 'handle-logic' message id it's added to the list of entities.\r\n             *\r\n             * @method 'child-entity-added'\r\n             * @param entity {platypus.Entity} The entity that is being considered for addition to the handler.\r\n             */\r\n            \"child-entity-added\": function (entity) {\r\n                if (entity.getMessageIds().some(hasLogic)) {\r\n                    this.entities.push(entity);\r\n                    \r\n                    // Add to the active entities list so that the collision loop is aware of and can handle the addition.\r\n                    if (this.inLogicLoop && (!this.camera || withinBounds(entity, this.camera))) {\r\n                        this.activeEntities.push(entity);\r\n                    }\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Called when an entity should be removed from the list of logically updated entities.\r\n             *\r\n             * @method 'child-entity-removed'\r\n             * @param entity {platypus.Entity} The entity to be removed from the handler.\r\n             */\r\n            \"child-entity-removed\": function (entity) {\r\n                var j = this.entities.indexOf(entity);\r\n                \r\n                if (j >= 0) {\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.entities, j);\r\n                    if (this.inLogicLoop) {\r\n                        this.removals.push(entity);\r\n                    }\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * When this event is triggered, `handle-logic` messages cease to be triggered on each tick.\r\n             *\r\n             * @method 'pause-logic'\r\n             * @param [options] {Object}\r\n             * @param [options.time] {number} If set, this will pause the logic for this number of milliseconds. If not set, logic is paused until an `unpause-logic` message is triggered.\r\n             */\r\n            \"pause-logic\": function (resp) {\r\n                if (resp && resp.time) {\r\n                    this.paused = resp.time;\r\n                } else {\r\n                    this.paused = -1;\r\n                }\r\n                if (this.owner.triggerEventOnChildren) {\r\n                    /**\r\n                     * Notifies children entities that logic has been paused.\r\n                     *\r\n                     * @event 'logic-paused'\r\n                     * @since 0.8.4\r\n                     */\r\n                    this.owner.triggerEventOnChildren('logic-paused');\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * When this event is triggered, `handle-logic` messages begin firing each tick.\r\n             *\r\n             * @method 'unpause-logic'\r\n             */\r\n            \"unpause-logic\": function () {\r\n                this.paused = 0;\r\n                if (this.owner.triggerEventOnChildren) {\r\n                    /**\r\n                     * Notifies children entities that logic has been unpaused.\r\n                     *\r\n                     * @event 'logic-unpaused'\r\n                     * @since 0.8.4\r\n                     */\r\n                    this.owner.triggerEventOnChildren('logic-unpaused');\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * Changes the active logic area when the camera location changes.\r\n             *\r\n             * @method 'camera-update'\r\n             * @param camera {Object}\r\n             * @param camera.viewport {platypus.AABB} The AABB describing the camera viewport in world units.\r\n             */\r\n            \"camera-update\": function (camera) {\r\n                var buffer = this.buffer,\r\n                    cam = this.camera,\r\n                    vp = null;\r\n                \r\n                if (cam) {\r\n                    if (buffer === -1) {\r\n                        buffer = camera.viewport.width / 10; // sets a default buffer based on the size of the world units if the buffer was not explicitly set.\r\n                    }\r\n                    \r\n                    vp = camera.viewport;\r\n                    cam.setBounds(vp.left - buffer, vp.top - buffer, vp.right + buffer, vp.bottom + buffer);\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * Sends a 'handle-logic' message to all the entities the component is handling. If an entity does not handle the message, it's removed it from the entity list.\r\n             *\r\n             * @method 'tick'\r\n             * @param tick {Object} Tick information that is passed on to children entities via \"handle-logic\" events.\r\n             * @param tick.delta {number} The time passed since the last tick.\r\n             */\r\n            \"tick\": function (resp) {\r\n                var i = 0,\r\n                    j = 0,\r\n                    cycles = 0,\r\n                    entity = null,\r\n                    msg = this.message,\r\n                    actives = this.activeEntities,\r\n                    removals = this.removals,\r\n                    stepLength = this.stepLength;\r\n                \r\n                this.leftoverTime += (resp.delta * this.timeMultiplier);\r\n                cycles = Math.floor(this.leftoverTime / stepLength) || 1;\r\n        \r\n                // This makes the frames smoother, but adds variance into the calculations\r\n        //        msg.delta = this.leftoverTime / cycles;\r\n        //        this.leftoverTime = 0;\r\n                \r\n                // This makes the frames more exact, but varying step numbers between ticks can cause movement to be jerky\r\n        //        msg.delta = Math.min(this.leftoverTime, this.stepLength);\r\n        //        this.leftoverTime = Math.max(this.leftoverTime - (cycles * this.stepLength), 0);\r\n        \r\n                // This makes the frames exact, but varying step numbers between ticks can cause movement to be jerky\r\n                msg.delta = stepLength;\r\n                this.leftoverTime = Math.max(this.leftoverTime - (cycles * stepLength), 0);\r\n        \r\n                msg.tick = resp;\r\n                \r\n                this.updateList(this.entities, actives, this.camera);\r\n                \r\n                //Prevents game lockdown when processing takes longer than time alotted.\r\n                cycles = Math.min(cycles, this.maxStepsPerTick);\r\n                \r\n                while (cycles--) {\r\n                    \r\n                    if (this.paused > 0) {\r\n                        this.paused -= stepLength;\r\n                        if (this.paused < 0) {\r\n                            this.paused = 0;\r\n                        }\r\n                    }\r\n                    \r\n                    if (!this.paused) {\r\n                        this.inLogicLoop = true;\r\n                        \r\n                        /**\r\n                         * This event is triggered on the top-level layer to signify a \"handle-logic\" event is about to be triggered on children. This is unique from the layer's \"tick\" event in that it occurs the same number of times as the \"handle-logic\" event and will not occur if HandlerLogic is paused.\r\n                         *\r\n                         * @event 'handle-logic'\r\n                         * @param tick.delta {Number} The time that has passed since the last tick.\r\n                         * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.\r\n                         * @param tick.entities {Array} This is a list of all the logically active entities.\r\n                         * @since 0.8.1\r\n                         */\r\n                        this.owner.triggerEvent('handle-logic', msg);\r\n                    \r\n                        if (this.owner.triggerEventOnChildren) {\r\n                            this.owner.triggerEventOnChildren('handle-ai', msg);\r\n                        }\r\n\r\n                        i = actives.length;\r\n                        while (i--) {\r\n                            entity = actives[i];\r\n                            \r\n                            /**\r\n                             * This event is triggered on children entities to run anything that should occur before \"handle-logic\". For example, removing or adding components should happen here and not in \"handle-logic\".\r\n                             *\r\n                             * @event 'prepare-logic'\r\n                             * @param tick {Object}\r\n                             * @param tick.delta {Number} The time that has passed since the last tick.\r\n                             * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.\r\n                             * @param tick.entities {Array} This is a list of all the logically active entities.\r\n                             * @since 0.6.8\r\n                             */\r\n                            entity.triggerEvent('prepare-logic', msg);\r\n\r\n                            /**\r\n                             * This event is triggered on children entities to run their logic.\r\n                             *\r\n                             * @event 'handle-logic'\r\n                             * @param tick {Object}\r\n                             * @param tick.delta {Number} The time that has passed since the last tick.\r\n                             * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.\r\n                             * @param tick.entities {Array} This is a list of all the logically active entities.\r\n                             */\r\n                            entity.triggerEvent('handle-logic', msg);\r\n\r\n                            /**\r\n                             * This event is triggered on children entities to move. This happens immediately after logic so entity logic can determine movement.\r\n                             *\r\n                             * @event 'handle-movement'\r\n                             * @param tick {Object}\r\n                             * @param tick.delta {Number} The time that has passed since the last tick.\r\n                             * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.\r\n                             * @param tick.entities {Array} This is a list of all the logically active entities.\r\n                             * @since 0.6.8\r\n                             */\r\n                            entity.triggerEvent('handle-movement', msg);\r\n                        }\r\n                        this.inLogicLoop = false;\r\n                        \r\n                        // This handles removing active entities from the list before collision checking, state-changing, etc.\r\n                        if (removals.length) {\r\n                            i = removals.length;\r\n                            while (i--) {\r\n                                j = actives.indexOf(removals[i]);\r\n                                if (j >= 0) {\r\n                                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(actives, j);\r\n                                }\r\n                            }\r\n                            removals.length = 0;\r\n                        }\r\n                        \r\n                        i = actives.length;\r\n                        /**\r\n                         * This event is triggered on the entity (layer) to test collisions once logic has been completed.\r\n                         *\r\n                         * @event 'check-collision-group'\r\n                         * @param tick {Object}\r\n                         * @param tick.delta {Number} The time that has passed since the last tick.\r\n                         * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.\r\n                         * @param tick.entities {Array} This is a list of all the logically active entities.\r\n                         */\r\n                        if (this.owner.triggerEvent('check-collision-group', msg)) { // If a collision group is attached, make sure collision is processed on each logic tick.\r\n                            /**\r\n                             * This event is triggered on entities to run logic that may depend upon collision responses.\r\n                             *\r\n                             * @event 'handle-post-collision-logic'\r\n                             * @param tick {Object}\r\n                             * @param tick.delta {Number} The time that has passed since the last tick.\r\n                             * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.\r\n                             * @param tick.entities {Array} This is a list of all the logically active entities.\r\n                             */\r\n                                \r\n                            /**\r\n                             * Triggered on entities when the entity's state has been changed.\r\n                             *\r\n                             * @event 'state-changed'\r\n                             * @param state {Object} A list of key/value pairs representing the owner's state (this value equals `entity.state`).\r\n                             */\r\n                            while (i--) {\r\n                                entity = actives[i];\r\n                                entity.triggerEvent('handle-post-collision-logic', msg);\r\n                                if (entity.lastState.update(entity.state)) {\r\n                                    entity.triggerEvent('state-changed', entity.state);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            while (i--) {\r\n                                entity = actives[i];\r\n                                if (entity.lastState.update(entity.state)) {\r\n                                    entity.triggerEvent('state-changed', entity.state);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.entities);\r\n                this.entities = null;\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.activeEntities);\r\n                this.activeEntities = null;\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.removals);\r\n                this.removals = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/HandlerLogic.js?");

/***/ }),

/***/ "./src/components/HandlerRender.js":
/*!*****************************************!*\
  !*** ./src/components/HandlerRender.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _Interactive_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Interactive.js */ \"./src/components/Interactive.js\");\n/**\r\n * A component that handles updating the render components on entities that are rendering via PIXI. Calls 'handle-render on children entities every tick. Also initializes handlers for mouse events on the layer level.\r\n *\r\n * @namespace platypus.components\r\n * @class HandlerRender\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n\r\n        id: \"HandlerRender\",\r\n\r\n        properties: {\r\n            /**\r\n             * Defines whether the entity will respond to touch and click events. Setting this value will create an Interactive component on this entity with these properties. For example:\r\n             *\r\n             *  \"interactive\": {\r\n             *      \"hover\": false,\r\n             *      \"hitArea\": {\r\n             *          \"x\": 10,\r\n             *          \"y\": 10,\r\n             *          \"width\": 40,\r\n             *          \"height\": 40\r\n             *      }\r\n             *  }\r\n             *\r\n             * @property interactive\r\n             * @type Boolean|Object\r\n             * @default false\r\n             * @since 0.9.1\r\n             */\r\n            interactive: false\r\n        },\r\n\r\n        publicProperties: {\r\n            /**\r\n             * This is the container holding all children's disply objects for this layer. It's an available property on the layer entity.\r\n             *\r\n             * @property worldContainer\r\n             * @type PIXI.Container\r\n             * @default null\r\n             * @since 0.11.0\r\n             */\r\n            worldContainer: null,\r\n        },\r\n\r\n        initialize: function () {\r\n            let x = 0,\r\n                definition = null;\r\n            \r\n            this.worldContainer = this.worldContainer || new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"]();\r\n            this.worldContainer.name = '';\r\n\r\n            if (this.interactive) {\r\n                definition = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\r\n                    'container', this.worldContainer,\r\n                    'hitArea', this.interactive.hitArea,\r\n                    'hover', this.interactive.hover,\r\n                    'relativeToSelf', true\r\n                );\r\n                this.owner.addComponent(new _Interactive_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.owner, definition));\r\n                definition.recycle();\r\n            }\r\n\r\n            this.renderMessage = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\r\n                'delta', 0,\r\n                'container', this.worldContainer\r\n            );\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * Once the entity is loaded, this component triggers \"render-world\" to notify other components about the entities' display container.\r\n             *\r\n             * @method 'load'\r\n             */\r\n            \"load\": function () {\r\n                /**\r\n                 * Once the entity is loaded, this component triggers \"render-world\" to notify other components about the entities' display container.\r\n                 *\r\n                 * @event 'render-world'\r\n                 * @param data {Object}\r\n                 * @param data.world {PIXI.Container} Contains entities to be rendered.\r\n                 */\r\n                this.owner.triggerEvent('render-world', {\r\n                    world: this.worldContainer\r\n                });\r\n\r\n                /**\r\n                 * This event is triggered once HandlerRender is ready to handle interactivity.\r\n                 *\r\n                 * @event 'input-on'\r\n                 */\r\n                this.owner.triggerEvent('input-on');\r\n            },\r\n\r\n            /**\r\n             * Called when a new entity has been added to the parent and should be considered for addition to the handler. Entities are sent a reference the Container that we're rendering to, so they can add their display objects to it and the delta from the lastest tick.\r\n             *\r\n             * @method 'child-entity-added'\r\n             * @param entity {platypus.Entity} The entity added to the parent.\r\n             */\r\n            \"child-entity-added\": function (entity) {\r\n                if (entity.container) {\r\n                    this.setParentRenderContainer(entity, entity.renderParent);\r\n                }\r\n                \r\n                /**\r\n                 * Triggered on an entity added to the parent.\r\n                 *\r\n                 * @event 'handle-render-load'\r\n                 * @param data {Object}\r\n                 * @param data.delta {Number} The delta time for this tick.\r\n                 * @param data.container {PIXI.Container} The display Container the entities display objects should be added to.\r\n                 */\r\n                entity.triggerEvent('handle-render-load', this.renderMessage);\r\n            },\r\n\r\n            /**\r\n             * Pauses the children of this render Container. If a pause time is not provided. It remains paused until 'unpause-render' is called.\r\n             *\r\n             * @method 'pause-render'\r\n             * @param [data] {Object}\r\n             * @param data.time {Number} How long to pause.\r\n             */\r\n            \"pause-render\": function (timeData) {\r\n                if (timeData && timeData.time) {\r\n                    this.paused = timeData.time;\r\n                } else {\r\n                    this.paused = -1;\r\n                }\r\n                if (this.owner.triggerEventOnChildren) {\r\n                    /**\r\n                     * Notifies children entities that rendering updates have been paused.\r\n                     *\r\n                     * @event 'render-paused'\r\n                     * @since 0.8.4\r\n                     */\r\n                    this.owner.triggerEventOnChildren('render-paused');\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Unpauses the children of this render Container.\r\n             *\r\n             * @method 'unpause-render'\r\n             */\r\n            \"unpause-render\": function () {\r\n                this.paused = 0;\r\n                if (this.owner.triggerEventOnChildren) {\r\n                    /**\r\n                     * Notifies children entities that rendering updates have been unpaused.\r\n                     *\r\n                     * @event 'render-unpaused'\r\n                     * @since 0.8.4\r\n                     */\r\n                    this.owner.triggerEventOnChildren('render-unpaused');\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Sends a 'handle-render' message to all the children in the Container. The children in the Container are also paused/unpaused if needed and sorted according to their z value.\r\n             *\r\n             * @method 'tick'\r\n             * @param tick {Object} An object containing tick data.\r\n             */\r\n            \"tick\": function (tick) {\r\n                const message = this.renderMessage,\r\n                    worldContainer = this.worldContainer;\r\n\r\n                message.delta = tick.delta;\r\n\r\n                if (this.paused > 0) {\r\n                    this.paused -= tick.delta;\r\n                    if (this.paused <= 0) {\r\n                        this.paused = 0;\r\n                    }\r\n                }\r\n\r\n                if (!this.paused && this.owner.triggerEventOnChildren) {\r\n                    /**\r\n                     * Triggered every tick on the children entities.\r\n                     *\r\n                     * @event 'handle-render'\r\n                     * @param data {Object}\r\n                     * @param data.delta {Number} The delta time for this tick.\r\n                     * @param data.container {PIXI.Container} The display Container the entities display objects should be added to.\r\n                     */\r\n                    this.owner.triggerEventOnChildren('handle-render', message);\r\n                }\r\n\r\n                if (worldContainer.reorder) {\r\n                    worldContainer.reorder = false;\r\n                    worldContainer.children.sort((a, b) => a.z - b.z);\r\n                }\r\n            },\r\n            /**\r\n             * Sets the parent render container of an entity to that of the given entity or entity with the given id.\r\n             *\r\n             * @method 'set-parent-render-container'\r\n             * @param entity {Object} The entity to relocate.\r\n             * @param entityOrId {Object|String} The entity or id of the entity that will act as the parent container.\r\n             */\r\n            \"set-parent-render-container\": function (entity, entityOrId) {\r\n                this.setParentRenderContainer(entity, entityOrId);\r\n            }\r\n\r\n        },\r\n        methods: {\r\n            setParentRenderContainer: function (entity, entityOrId) {\r\n                let container = null;\r\n\r\n                entity.removeFromParentContainer();\r\n\r\n                if (!entityOrId) {\r\n                    container = this.worldContainer;\r\n\r\n                } else if (typeof entityOrId === \"string\") {\r\n\r\n                    const otherEntity = this.owner.getEntityById(entityOrId);\r\n                    if (otherEntity) {\r\n                        container = otherEntity.container;\r\n                    } else {\r\n                        //Didn't find group.\r\n                        console.warn(\"Trying to add to non-existent entity, added to World container instead.\");\r\n                        container = this.worldContainer;\r\n                    }\r\n\r\n                } else {\r\n                    container = entityOrId.container;\r\n                }\r\n\r\n                entity.addToParentContainer(container);\r\n\r\n            },\r\n            destroy: function () {\r\n                this.worldContainer = null;\r\n                this.renderMessage.recycle();\r\n                this.renderMessage = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/HandlerRender.js?");

/***/ }),

/***/ "./src/components/Interactive.js":
/*!***************************************!*\
  !*** ./src/components/Interactive.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/**\r\n * This component accepts touches and clicks on the entity. It is typically automatically added by a render component that requires interactive functionality.\r\n *\r\n * @class Interactive\r\n * @uses platypus.Component\r\n * @since 0.9.0\r\n */\r\n/*global platypus */\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var pointerInstances = {};\r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'Interactive',\r\n\r\n        properties: {\r\n            /**\r\n             * Sets the container that represents the interactive area.\r\n             *\r\n             * @property container\r\n             * @type PIXI.Container\r\n             * @default null\r\n             */\r\n            \"container\": null,\r\n\r\n            /**\r\n             * Sets the hit area for interactive responses by describing the dimensions of a clickable rectangle:\r\n             *\r\n             *     \"hitArea\": {\r\n             *         \"x\": 10,\r\n             *         \"y\": 10,\r\n             *         \"width\": 40,\r\n             *         \"height\": 40\r\n             *     }\r\n             *\r\n             * Or a circle:\r\n             *\r\n             *     \"hitArea\": {\r\n             *         \"x\": 10,\r\n             *         \"y\": 10,\r\n             *         \"radius\": 40\r\n             *     }\r\n             *\r\n             * Or use an array of numbers to define a polygon: [x1, y1, x2, y2, ...]\r\n             *\r\n             *     \"hitArea\": [-10, -10, 30, -10, 30, 30, -5, 30]\r\n             *\r\n             * Defaults to the container if not specified.\r\n             *\r\n             * @property hitArea\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            \"hitArea\": null,\r\n\r\n            /**\r\n             * Sets whether the entity should respond to mouse hovering.\r\n             *\r\n             * @property hover\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            \"hover\": false,\r\n\r\n            /**\r\n             * Used when returning world coordinates. Typically coordinates are relative to the parent, but when this component is added to the layer level, coordinates must be relative to self.\r\n             *\r\n             * @property relativeToSelf\r\n             * @type String\r\n             * @default false\r\n             * @since 0.9.3\r\n             */\r\n            \"relativeToSelf\": false\r\n        },\r\n        \r\n        publicProperties: {\r\n            /**\r\n             * Determines whether hovering over the sprite should alter the cursor.\r\n             *\r\n             * @property buttonMode\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            buttonMode: false\r\n        },\r\n        \r\n        initialize: function () {\r\n            this.pressed = false;\r\n            this.camera = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\r\n            if (this.hitArea) {\r\n                this.container.hitArea = this.setHitArea(this.hitArea);\r\n            }\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * Listens for this event to determine whether this sprite is visible.\r\n             *\r\n             * @method 'camera-update'\r\n             * @param camera.viewport {platypus.AABB} Camera position and size.\r\n             */\r\n            \"camera-update\": function (camera) {\r\n                this.camera.set(camera.viewport);\r\n            },\r\n\r\n            /**\r\n             * Listens to this event to update whether the interactive element should be in button mode.\r\n             *\r\n             * @method 'handle-render'\r\n             */\r\n            \"handle-render\": function () {\r\n                if (this.buttonMode !== this.container.buttonMode) {\r\n                    this.container.buttonMode = this.buttonMode;\r\n                }\r\n            },\r\n\r\n            /**\r\n             * This event dispatches a PIXI.Event on this component's PIXI.Sprite. Useful for rerouting mouse/keyboard events.\r\n             *\r\n             * @method 'dispatch-event'\r\n             * @param event {Object | PIXI.Event} The event to dispatch.\r\n             */\r\n            \"dispatch-event\": function (event) {\r\n                this.sprite.dispatchEvent(this.sprite, event.event, event.data);\r\n            },\r\n            \r\n            /**\r\n             * Adds input event listeners to the sprite, enabling input.\r\n             *\r\n             * @method 'input-on'\r\n             */\r\n            \"input-on\": function () {\r\n                if (!this.removeInputListeners) {\r\n                    this.addInputs();\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * Removes the input event listeners on the sprite, disabling input.\r\n             *\r\n             * @method 'input-off'\r\n             */\r\n            \"input-off\": function () {\r\n                if (this.removeInputListeners) {\r\n                    this.removeInputListeners();\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            addInputs: (function () {\r\n                var\r\n                    getId = function (event) {\r\n                        var data = event.data,\r\n                            originalEvent = data.originalEvent;\r\n\r\n                        if (typeof originalEvent.pointerId !== 'undefined') {\r\n                            return 'point' + originalEvent.pointerId; // Handles pointer events\r\n                        } else {\r\n                            return originalEvent.type.substr(0, 5) + (data.identifier || 0); // Handles mouse / touch events\r\n                        }\r\n                    },\r\n                    trigger = function (eventName, event) {\r\n                        var camera = this.camera,\r\n                            container = this.container,\r\n                            msg = null,\r\n                            matrix = null;\r\n                        \r\n                        if (\r\n                            !container || //TML - This is in case we do a scene change using an event and the container is destroyed.\r\n                            !event.data.originalEvent // This is a workaround for a bug in Pixi 3 where phantom hover events are triggered. - DDD 7/20/16\r\n                            ) {\r\n                            return;\r\n                        }\r\n\r\n                        matrix = this.relativeToSelf ? container.transform.worldTransform : container.parent.transform.worldTransform;\r\n                        msg = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                            \"event\", event.data.originalEvent,\r\n                            \"pixiEvent\", event,\r\n                            \"x\", event.data.global.x / matrix.a + camera.left,\r\n                            \"y\", event.data.global.y / matrix.d + camera.top,\r\n                            \"entity\", this.owner\r\n                        );\r\n\r\n                        this.owner.trigger(eventName, msg);\r\n                        msg.recycle();\r\n                    },\r\n                    triggerPointerDown = function (event) {\r\n                        pointerInstances[getId(event)] = this;\r\n\r\n                        /**\r\n                         * This event is triggered on pointer down.\r\n                         *\r\n                         * @event 'pointerdown'\r\n                         * @param event {DOMEvent} The original DOM pointer event.\r\n                         * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\r\n                         * @param x {Number} The x coordinate in world units.\r\n                         * @param y {Number} The y coordinate in world units.\r\n                         * @param entity {platypus.Entity} The entity receiving this event.\r\n                         * @since v0.10.6\r\n                         */\r\n                        trigger.call(this, 'pointerdown', event);\r\n\r\n                        event.currentTarget.mouseTarget = true;\r\n                        this.pressed = true;\r\n                    },\r\n                    triggerPointerMove = function (event) {\r\n                        var id = getId(event);\r\n\r\n                        if (pointerInstances[id] === this) {\r\n                            /**\r\n                             * This event is triggered on pointer move.\r\n                             *\r\n                             * @event 'pointermove'\r\n                             * @param event {DOMEvent} The original DOM pointer event.\r\n                             * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\r\n                             * @param x {Number} The x coordinate in world units.\r\n                             * @param y {Number} The y coordinate in world units.\r\n                             * @param entity {platypus.Entity} The entity receiving this event.\r\n                             * @since v0.10.6\r\n                             */\r\n                            trigger.call(this, 'pointermove', event);\r\n                            if (this.pressed) {\r\n                                /**\r\n                                 * This event is triggered on press move (drag).\r\n                                 *\r\n                                 * @event 'pressmove'\r\n                                 * @param event {DOMEvent} The original DOM pointer event.\r\n                                 * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\r\n                                 * @param x {Number} The x coordinate in world units.\r\n                                 * @param y {Number} The y coordinate in world units.\r\n                                 * @param entity {platypus.Entity} The entity receiving this event.\r\n                                 */\r\n                                trigger.call(this, 'pressmove', event);\r\n                                event.currentTarget.mouseTarget = true;\r\n                            }\r\n                        }\r\n                    },\r\n                    triggerPointerTap = function (event) {\r\n                        /**\r\n                         * This event is triggered on pointer tap.\r\n                         *\r\n                         * @event 'pointertap'\r\n                         * @param event {DOMEvent} The original DOM pointer event.\r\n                         * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\r\n                         * @param x {Number} The x coordinate in world units.\r\n                         * @param y {Number} The y coordinate in world units.\r\n                         * @param entity {platypus.Entity} The entity receiving this event.\r\n                         * @since v0.10.6\r\n                         */\r\n                        trigger.call(this, 'pointertap', event);\r\n                    },\r\n                    triggerPointerOut = function (event) {\r\n\r\n                        /**\r\n                         * This event is triggered on pointer out.\r\n                         *\r\n                         * @event 'pointerout'\r\n                         * @param event {DOMEvent} The original DOM pointer event.\r\n                         * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\r\n                         * @param x {Number} The x coordinate in world units.\r\n                         * @param y {Number} The y coordinate in world units.\r\n                         * @param entity {platypus.Entity} The entity receiving this event.\r\n                         * @since v0.10.6\r\n                         */\r\n                        trigger.call(this, 'pointerout', event);\r\n                    },\r\n                    triggerPointerOver = function (event) {\r\n                        /**\r\n                         * This event is triggered on pointer over.\r\n                         *\r\n                         * @event 'pointerover'\r\n                         * @param event {DOMEvent} The original DOM pointer event.\r\n                         * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\r\n                         * @param x {Number} The x coordinate in world units.\r\n                         * @param y {Number} The y coordinate in world units.\r\n                         * @param entity {platypus.Entity} The entity receiving this event.\r\n                         * @since v0.10.6\r\n                         */\r\n                        trigger.call(this, 'pointerover', event);\r\n                    },\r\n                    triggerPointerUp = function (event) {\r\n                        var id = getId(event);\r\n\r\n                        if (pointerInstances[id] === this) {\r\n                            pointerInstances[id] = null;\r\n                            if (this.pressed) {\r\n                                /**\r\n                                 * This event is triggered on press up.\r\n                                 *\r\n                                 * @event 'pressup'\r\n                                 * @param event {DOMEvent} The original DOM pointer event.\r\n                                 * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\r\n                                 * @param x {Number} The x coordinate in world units.\r\n                                 * @param y {Number} The y coordinate in world units.\r\n                                 * @param entity {platypus.Entity} The entity receiving this event.\r\n                                 */\r\n                                trigger.call(this, 'pressup', event);\r\n                                this.pressed = false;\r\n                            }\r\n                            /**\r\n                             * This event is triggered on pointer up.\r\n                             *\r\n                             * @event 'pointerup'\r\n                             * @param event {DOMEvent} The original DOM pointer event.\r\n                             * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\r\n                             * @param x {Number} The x coordinate in world units.\r\n                             * @param y {Number} The y coordinate in world units.\r\n                             * @param entity {platypus.Entity} The entity receiving this event.\r\n                             * @since v0.10.6\r\n                             */\r\n                            trigger.call(this, 'pointerup', event);\r\n                            event.currentTarget.mouseTarget = false;\r\n                            \r\n                            if (event.currentTarget.removeDisplayObject) {\r\n                                event.currentTarget.removeDisplayObject();\r\n                            }\r\n                        }\r\n                    },\r\n                    triggerPointerUpOutside = function (event) {\r\n                        var id = getId(event);\r\n\r\n                        if (pointerInstances[id] === this) {\r\n                            pointerInstances[id] = null;\r\n                            if (this.pressed) {\r\n                                trigger.call(this, 'pressup', event);\r\n                                this.pressed = false;\r\n                            }\r\n                            /**\r\n                             * This event is triggered on pointer up outside.\r\n                             *\r\n                             * @event 'pointerupoutside'\r\n                             * @param event {DOMEvent} The original DOM pointer event.\r\n                             * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\r\n                             * @param x {Number} The x coordinate in world units.\r\n                             * @param y {Number} The y coordinate in world units.\r\n                             * @param entity {platypus.Entity} The entity receiving this event.\r\n                             * @since v0.10.6\r\n                             */\r\n                            trigger.call(this, 'pointerupoutside', event);\r\n                            event.currentTarget.mouseTarget = false;\r\n                            \r\n                            if (event.currentTarget.removeDisplayObject) {\r\n                                event.currentTarget.removeDisplayObject();\r\n                            }\r\n                        }\r\n                    },\r\n                    triggerPointerCancel = function (event) {\r\n                        var id = getId(event);\r\n\r\n                        if (pointerInstances[id] === this) {\r\n                            pointerInstances[id] = null;\r\n                            if (this.pressed) {\r\n                                trigger.call(this, 'pressup', event);\r\n                                this.pressed = false;\r\n                            }\r\n                            /**\r\n                             * This event is triggered on pointer cancel.\r\n                             *\r\n                             * @event 'pointercancel'\r\n                             * @param event {DOMEvent} The original DOM pointer event.\r\n                             * @param pixiEvent {PIXI.interaction.InteractionEvent} The Pixi pointer event.\r\n                             * @param x {Number} The x coordinate in world units.\r\n                             * @param y {Number} The y coordinate in world units.\r\n                             * @param entity {platypus.Entity} The entity receiving this event.\r\n                             * @since v0.11.10\r\n                             */\r\n                            trigger.call(this, 'pointercancel', event);\r\n                            event.currentTarget.mouseTarget = false;\r\n                            \r\n                            if (event.currentTarget.removeDisplayObject) {\r\n                                event.currentTarget.removeDisplayObject();\r\n                            }\r\n                        }\r\n                    },\r\n                    removeInputListeners = function (sprite, pointerdown, pointerup, pointerupoutside, pointercancel, pointermove, pointertap, pointerover, pointerout) {\r\n                        var key = '';\r\n\r\n                        for (key in pointerInstances) {\r\n                            if (pointerInstances.hasOwnProperty(key) && (pointerInstances[key] === this)) {\r\n                                pointerInstances[key] = null;\r\n                            }\r\n                        }\r\n\r\n                        sprite.removeListener('pointerdown', pointerdown);\r\n                        sprite.removeListener('pointerup', pointerup);\r\n                        sprite.removeListener('pointerupoutside', pointerupoutside);\r\n                        sprite.removeListener('pointercancel', pointercancel);\r\n                        sprite.removeListener('pointermove', pointermove);\r\n                        sprite.removeListener('pointertap', pointertap);\r\n\r\n                        if (this.hover) {\r\n                            sprite.removeListener('pointerover', pointerover);\r\n                            sprite.removeListener('pointerout',  pointerout);\r\n                        }\r\n                        sprite.interactive = false;\r\n                        this.removeInputListeners = null;\r\n                    };\r\n\r\n                return function () {\r\n                    var sprite    = this.container,\r\n                        pointerdown = null,\r\n                        pointerover = null,\r\n                        pointerout  = null,\r\n                        pointermove = null,\r\n                        pointerup = null,\r\n                        pointerupoutside = null,\r\n                        pointercancel = null,\r\n                        pointertap = null;\r\n                    \r\n                    // The following appends necessary information to displayed objects to allow them to receive touches and clicks\r\n                    sprite.interactive = true;\r\n                    \r\n                    pointerdown = triggerPointerDown.bind(this);\r\n                    pointermove = triggerPointerMove.bind(this);\r\n                    pointerup = triggerPointerUp.bind(this);\r\n                    pointerupoutside = triggerPointerUpOutside.bind(this);\r\n                    pointercancel = triggerPointerCancel.bind(this);\r\n                    pointertap = triggerPointerTap.bind(this);\r\n                    \r\n                    sprite.addListener('pointerdown', pointerdown);\r\n                    sprite.addListener('pointerup', pointerup);\r\n                    sprite.addListener('pointerupoutside', pointerupoutside);\r\n                    sprite.addListener('pointercancel', pointercancel);\r\n                    sprite.addListener('pointermove', pointermove);\r\n                    sprite.addListener('pointertap', pointertap);\r\n\r\n                    if (this.hover) {\r\n                        pointerover = triggerPointerOver.bind(this);\r\n                        pointerout  = triggerPointerOut.bind(this);\r\n\r\n                        sprite.addListener('pointerover', pointerover);\r\n                        sprite.addListener('pointerout', pointerout);\r\n                    }\r\n\r\n                    this.removeInputListeners = removeInputListeners.bind(this, sprite, pointerdown, pointerup, pointerupoutside, pointercancel, pointermove, pointertap, pointerover, pointerout);\r\n                };\r\n            }()),\r\n\r\n            setHitArea: (function () {\r\n                var savedHitAreas = {}; //So generated hitAreas are reused across identical entities.\r\n                \r\n                return function (shape) {\r\n                    var ha  = null,\r\n                        sav = '';\r\n                    \r\n                    sav = JSON.stringify(shape);\r\n                    \r\n                    ha = savedHitAreas[sav];\r\n\r\n                    if (!ha) {\r\n                        if (Array.isArray(shape)) {\r\n                            ha = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Polygon\"](shape);\r\n                        } else if (shape.radius) {\r\n                            ha = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Circle\"](shape.x || 0, shape.y || 0, shape.radius);\r\n                        } else {\r\n                            ha = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Rectangle\"](shape.x || 0, shape.y || 0, shape.width || this.owner.width || 0, shape.height || this.owner.height || 0);\r\n                        }\r\n                        \r\n                        savedHitAreas[sav] = ha;\r\n                    }\r\n                    \r\n                    return ha;\r\n                };\r\n            }()),\r\n\r\n            toJSON: function () { // This component is added by another component, so it shouldn't be returned for reconstruction.\r\n                return null;\r\n            },\r\n\r\n            destroy: (function () {\r\n                var\r\n                    removeAfterMouseUp = function () {\r\n                        this.container.parent.removeChild(this.container);\r\n                        this.container = null;\r\n                    };\r\n\r\n                return function () {\r\n                    if (this.removeInputListeners) {\r\n                        this.removeInputListeners();\r\n                    }\r\n\r\n                    this.camera.recycle();\r\n                    \r\n                    // This handles removal after the mouseup event to prevent weird input behaviors. If it's not currently a mouse target, we let the render component handle its removal from the parent container.\r\n                    if (this.container.mouseTarget && this.container.parent) {\r\n                        this.container.visible = false;\r\n                        this.container.removeDisplayObject = removeAfterMouseUp.bind(this);\r\n                    }\r\n                };\r\n            }())\r\n        },\r\n        \r\n        publicMethods: {\r\n            \r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/Interactive.js?");

/***/ }),

/***/ "./src/components/LevelBuilder.js":
/*!****************************************!*\
  !*** ./src/components/LevelBuilder.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n * This component works in tandem with 'TiledLoader by taking several Tiled maps and combining them before `TiledLoader` processes them. Tiled maps must use the same tilesets for this to function correctly.\r\n *\r\n * Note: Set \"manuallyLoad\" to `true` in the `TiledLoader` component JSON definition so that it will wait for this component's \"load-level\" call.\r\n *\r\n * @namespace platypus.components\r\n * @class LevelBuilder\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var\r\n        mergeData = function (levelData, levelMergeAxisLength, segmentData, segmentMergeAxisLength, nonMergeAxisLength, mergeAxis) {\r\n            var x        = 0,\r\n                y        = 0,\r\n                z        = 0,\r\n                combined = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(levelData);\r\n\r\n            if (mergeAxis === 'horizontal') {\r\n                for (y = nonMergeAxisLength - 1; y >= 0; y--) {\r\n                    for (x = y * segmentMergeAxisLength, z = 0; x < (y + 1) * segmentMergeAxisLength; x++, z++) {\r\n                        combined.splice(((y + 1) * levelMergeAxisLength) + z, 0, segmentData[x]);\r\n                    }\r\n                }\r\n                return combined;\r\n            } else if (mergeAxis === 'vertical') {\r\n                return levelData.concat(segmentData);\r\n            }\r\n            \r\n            return null;\r\n        },\r\n        mergeObjects  = function (obj1s, obj2s, mergeAxisLength, mergeAxis) {\r\n            var i    = 0,\r\n                j    = '',\r\n                list = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(obj1s),\r\n                obj  = null;\r\n\r\n            for (i = 0; i < obj2s.length; i++) {\r\n                obj = {};\r\n                for (j in obj2s[i]) {\r\n                    if (obj2s[i].hasOwnProperty(j)) {\r\n                        obj[j] = obj2s[i][j];\r\n                    }\r\n                }\r\n                if (mergeAxis === 'horizontal') {\r\n                    obj.x += mergeAxisLength;\r\n                } else if (mergeAxis === 'vertical') {\r\n                    obj.y += mergeAxisLength;\r\n                }\r\n                list.push(obj);\r\n            }\r\n            return list;\r\n        },\r\n        mergeSegment  = function (level, segment, mergeAxis, decoder) {\r\n            var i = 0,\r\n                j = '';\r\n\r\n            if (!level.tilewidth && !level.tileheight) {\r\n                //set level tile size data if it's not already set.\r\n                level.tilewidth  = segment.tilewidth;\r\n                level.tileheight = segment.tileheight;\r\n            } else if (level.tilewidth !== segment.tilewidth || level.tileheight !== segment.tileheight) {\r\n                platypus.debug.warn('Tiled-Loader: Your map has segments with different tile sizes. All tile sizes must match. Segment: ' + segment);\r\n            }\r\n\r\n            if (mergeAxis === 'horizontal') {\r\n                if (level.height === 0) {\r\n                    level.height = segment.height;\r\n                } else if (level.height !== segment.height) {\r\n                    platypus.debug.warn('Tiled-Loader: You are trying to merge segments with different heights. All segments need to have the same height. Level: ' + level + ' Segment: ' + segment);\r\n                }\r\n            } else if (mergeAxis === 'vertical') {\r\n                if (level.width === 0) {\r\n                    level.width = segment.width;\r\n                } else if (level.width !== segment.width) {\r\n                    platypus.debug.warn('Tiled-Loader: You are trying to merge segments with different widths. All segments need to have the same width. Level: ' + level + ' Segment: ' + segment);\r\n                }\r\n            }\r\n\r\n            for (i = 0; i < segment.layers.length; i++) {\r\n                if (!level.layers[i]) {\r\n                    //if the level doesn't have a layer yet, we're creating it and then copying it from the segment.\r\n                    decoder(segment.layers[i]);\r\n                    level.layers[i] = {};\r\n                    for (j in segment.layers[i]) {\r\n                        if (segment.layers[i].hasOwnProperty(j)) {\r\n                            level.layers[i][j] = segment.layers[i][j];\r\n                        }\r\n                    }\r\n                } else if (level.layers[i].type === segment.layers[i].type) {\r\n                    //if the level does have a layer, we're appending the new data to it.\r\n                    if (level.layers[i].data && segment.layers[i].data) {\r\n                        // Make sure we're not trying to merge compressed levels.\r\n                        decoder(segment.layers[i]);\r\n                        \r\n                        if (mergeAxis === 'horizontal') {\r\n                            level.layers[i].data = mergeData(level.layers[i].data, level.width, segment.layers[i].data, segment.width, level.height, mergeAxis);\r\n                            level.layers[i].width += segment.width;\r\n                        } else if (mergeAxis === 'vertical') {\r\n                            level.layers[i].data = mergeData(level.layers[i].data, level.height, segment.layers[i].data, segment.height, level.width, mergeAxis);\r\n                            level.layers[i].height += segment.height;\r\n                        }\r\n                    } else if (level.layers[i].objects && segment.layers[i].objects) {\r\n                        if (mergeAxis === 'horizontal') {\r\n                            level.layers[i].objects = mergeObjects(level.layers[i].objects, segment.layers[i].objects, level.width * level.tilewidth, mergeAxis);\r\n                        } else if (mergeAxis === 'vertical') {\r\n                            level.layers[i].objects = mergeObjects(level.layers[i].objects, segment.layers[i].objects, level.height * level.tileheight, mergeAxis);\r\n                        }\r\n                    }\r\n                } else {\r\n                    platypus.debug.warn('Tiled-Loader: The layers in your level segments do not match. Level: ' + level + ' Segment: ' + segment);\r\n                }\r\n            }\r\n\r\n            if (mergeAxis === 'horizontal') {\r\n                level.width += segment.width;\r\n            } else if (mergeAxis === 'vertical') {\r\n                level.height += segment.height;\r\n            }\r\n\r\n            //Go through all the STUFF in segment and copy it to the level if it's not already there.\r\n            for (j in segment) {\r\n                if (segment.hasOwnProperty(j) && !level[j]) {\r\n                    level[j] = segment[j];\r\n                }\r\n            }\r\n        },\r\n        mergeLevels = function (levelSegments, decoder) {\r\n            var i = 0,\r\n                j = 0,\r\n                levelDefinitions = platypus.game.settings.levels,\r\n                row = {\r\n                    height: 0,\r\n                    width: 0,\r\n                    layers: []\r\n                },\r\n                level = {\r\n                    height: 0,\r\n                    width: 0,\r\n                    layers: []\r\n                },\r\n                segmentsWide = levelSegments[i].length;\r\n\r\n            for (i = 0; i < levelSegments.length; i++) {\r\n                if (segmentsWide !== levelSegments[i].length) {\r\n                    platypus.debug.warn('Tiled-Loader: Your map is not square. Maps must have an equal number of segments in every row.');\r\n                }\r\n                row = {\r\n                    height: 0,\r\n                    width: 0,\r\n                    layers: []\r\n                };\r\n                for (j = 0; j < levelSegments[i].length; j++) {\r\n                    //Merge horizontally\r\n                    if (typeof levelSegments[i][j] === 'string') {\r\n                        mergeSegment(row, levelDefinitions[levelSegments[i][j]], 'horizontal', decoder);\r\n                    } else {\r\n                        mergeSegment(row, levelSegments[i][j], 'horizontal', decoder);\r\n                    }\r\n                }\r\n                //Then merge vertically\r\n                mergeSegment(level, row, 'vertical', decoder);\r\n            }\r\n            return level;\r\n        };\r\n\r\n    return platypus.createComponentClass({\r\n        id: 'LevelBuilder',\r\n        \r\n        properties: {\r\n            /**\r\n             * If true, no single map piece is used twice in the creation of the combined map.\r\n             *\r\n             * @property useUniques\r\n             * @type Boolean\r\n             * @default true\r\n             */\r\n            useUniques: true,\r\n            /**\r\n             * A 1D or 2D array of level piece ids. The template defines how the pieces will be arranged and which pieces can be used where. The template must be rectangular in dimensions.\r\n             *\r\n             *      \"levelTemplate\": [ [\"start\", \"forest\"], [\"forest\", \"end\"] ]\r\n             *\r\n             * @property levelTemplate\r\n             * @type Array\r\n             * @default null\r\n             */\r\n            levelTemplate: null,\r\n            /**\r\n             * This is an object of key/value pairs listing the pieces that map to an id in the level template. The value can be specified as a string or array. A piece will be randomly chosen from an array when that idea is used. If levelPieces is not defined, ids in the template map directly to level names.\r\n             *\r\n             *      \"levelPieces\": {\r\n             *          \"start\"  : \"start-map\",\r\n             *          \"end\"      : \"end-map\",\r\n             *          \"forest\" : [\"forest-1\", \"forest-2\", \"forest-3\"]\r\n             *      }\r\n             *\r\n             * @property levelPieces\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            levelPieces: null\r\n        },\r\n\r\n        publicProperties: {\r\n        },\r\n        \r\n        initialize: function () {\r\n            this.levelMessage = {level: null, persistentData: null};\r\n        },\r\n\r\n        events: {// These are messages that this component listens for\r\n\r\n            /**\r\n             * When the scene has loaded, LevelBuilder compiles the level based on the template and pieces and sends it to the TiledLoader.\r\n             *\r\n             * @method 'scene-loaded'\r\n             * @param persistentData {Object} The persistent data from the previous scene.\r\n             */\r\n            \"scene-loaded\": function (persistentData) {\r\n                var templateRow  = null,\r\n                    piecesToCopy = null,\r\n                    x            = '',\r\n                    y            = 0,\r\n                    i            = 0,\r\n                    j            = 0;\r\n                \r\n                this.levelMessage.persistentData = persistentData;\r\n\r\n                this.levelTemplate = persistentData.levelTemplate || this.levelTemplate;\r\n                this.useUniques = persistentData.useUniques || this.useUniques;\r\n                piecesToCopy = persistentData.levelPieces || this.levelPieces;\r\n                this.levelPieces = {};\r\n                if (piecesToCopy) {\r\n                    for (x in piecesToCopy) {\r\n                        if (piecesToCopy.hasOwnProperty(x)) {\r\n                            if (typeof piecesToCopy[x] === \"string\") {\r\n                                this.levelPieces[x] = piecesToCopy[x];\r\n                            } else if (piecesToCopy[x].length) {\r\n                                this.levelPieces[x] = [];\r\n                                for (y = 0; y < piecesToCopy[x].length; y++) {\r\n                                    this.levelPieces[x].push(piecesToCopy[x][y]);\r\n                                }\r\n                            } else {\r\n                                throw ('Level Builder: Level pieces of incorrect type: ' + piecesToCopy[x]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this.levelTemplate) {\r\n                    if (this.levelTemplate) {\r\n                        this.levelMessage.level = [];\r\n                        for (i = 0; i < this.levelTemplate.length; i++) {\r\n                            templateRow = this.levelTemplate[i];\r\n                            if (typeof templateRow === \"string\") {\r\n                                this.levelMessage.level[i] = this.getLevelPiece(templateRow);\r\n                            } else if (templateRow.length) {\r\n                                this.levelMessage.level[i] = [];\r\n                                for (j = 0; j < templateRow.length; j++) {\r\n                                    this.levelMessage.level[i][j] = this.getLevelPiece(templateRow[j]);\r\n                                }\r\n                            } else {\r\n                                throw ('Level Builder: Template row is neither a string or array. What is it?');\r\n                            }\r\n                        }\r\n                    } else {\r\n                        throw ('Level Builder: Template is not defined');\r\n                    }\r\n                } else {\r\n                    throw ('Level Builder: There is no level template.');\r\n                }\r\n                \r\n                if (this.levelMessage.level) {\r\n                    this.levelMessage.level = mergeLevels(this.levelMessage.level, this.owner.decodeLayer);\r\n                    /**\r\n                     * Dispatched when the scene has loaded and the level has been composited so TileLoader can begin loading the level.\r\n                     *\r\n                     * @event 'load-level'\r\n                     * @param data {Object}\r\n                     * @param data.level {Object} An object describing the level dimensions, tiles, and entities.\r\n                     * @param data.persistentData {Object} The persistent data passed from the last scene. We add levelBuilder data to it to pass on.\r\n                     * @param data.persistentData.levelTemplate {Object} A 1D or 2D array of level piece ids. The template defines how the pieces will be arranged and which pieces can be used where. The template must be rectangular in dimensions.\r\n                     * @param data.persistentData.levelPieces {Object} An object of key/value pairs listing the pieces that map to an id in the level template.\r\n                     * @param data.persistentData.useUniques {Boolean} If true, no single map piece is used twice in the creation of the combined map.\r\n                     */\r\n                    this.owner.triggerEvent('load-level', this.levelMessage);\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {// These are methods that are called by this component.\r\n            getLevelPiece: function (type) {\r\n                var pieces = this.levelPieces[type] || type,\r\n                    temp   = null,\r\n                    random = 0;\r\n                \r\n                if (pieces) {\r\n                    if (typeof pieces === \"string\") {\r\n                        if (this.useUniques) {\r\n                            temp = pieces;\r\n                            this.levelPieces[type] = null;\r\n                            return temp;\r\n                        } else {\r\n                            return pieces;\r\n                        }\r\n                    } else if (pieces.length) {\r\n                        random = Math.floor(Math.random() * pieces.length);\r\n                        if (this.useUniques) {\r\n                            return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.levelPieces[type], random);\r\n                        } else {\r\n                            return pieces[random];\r\n                        }\r\n                    } else {\r\n                        throw ('Level Builder: There are no MORE level pieces of type: ' + type);\r\n                    }\r\n                } else {\r\n                    throw ('Level Builder: There are no level pieces of type: ' + type);\r\n                }\r\n            },\r\n            destroy: function () {\r\n                this.levelMessage.level = null;\r\n                this.levelMessage.persistentData = null;\r\n                this.levelMessage = null;\r\n            }\r\n        },\r\n        \r\n        publicMethods: {\r\n            mergeLevels: function (levels) {\r\n                return mergeLevels(levels, this.owner.decodeLayer);\r\n            }\r\n        },\r\n        \r\n        getAssetList: function (def, props, defaultProps) {\r\n            var i = 0,\r\n                arr = null,\r\n                assets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                key = '',\r\n                levels = null;\r\n            \r\n            if (def && def.levelPieces) {\r\n                levels = def.levelPieces;\r\n            } else if (props && props.levelPieces) {\r\n                levels = props.levelPieces;\r\n            } else if (defaultProps && defaultProps.levelPieces) {\r\n                levels = defaultProps.levelPieces;\r\n            }\r\n            \r\n            if (levels) {\r\n                for (key in levels) {\r\n                    if (levels.hasOwnProperty(key)) {\r\n                        // Offload to TiledLoader since it has level-parsing handling\r\n                        if (Array.isArray(levels[key])) {\r\n                            for (i = 0; i < levels[key].length; i++) {\r\n                                arr = platypus.components.TiledLoader.getAssetList({\r\n                                    level: levels[key][i]\r\n                                }, props, defaultProps);\r\n                                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\r\n                                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\r\n                            }\r\n                        } else {\r\n                            arr = platypus.components.TiledLoader.getAssetList({\r\n                                level: levels[key]\r\n                            }, props, defaultProps);\r\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\r\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            return assets;\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LevelBuilder.js?");

/***/ }),

/***/ "./src/components/LogicAngularMovement.js":
/*!************************************************!*\
  !*** ./src/components/LogicAngularMovement.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n * This component moves the entity in the direction of an internally stored angle value. When moving, the entity constantly accelerates the entity in a direction up to a max velocity.\r\n *\r\n * @namespace platypus.components\r\n * @class LogicAngularMovement\r\n * @uses platypus.Component\r\n */\r\n\r\n/*global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'LogicAngularMovement',\r\n        \r\n        properties: {\r\n            /**\r\n             * The max velocity.\r\n             *\r\n             * @property maxVelocity\r\n             * @type Number\r\n             * @default 3\r\n             */\r\n            maxVelocity: 3,\r\n\r\n            /**\r\n             * The rate of acceleration.\r\n             *\r\n             * @property acceleration\r\n             * @type Number\r\n             * @default 0.01\r\n             */\r\n            acceleration: 0.01,\r\n\r\n            /**\r\n             * The offset between the rotation value of the entity and the rotation of the art.\r\n             *\r\n             * @property visualOffset\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            visualOffset: 0,\r\n\r\n            /**\r\n             * The starting heading at which the entity will accelerate. In radians.\r\n             *\r\n             * @property startAngle\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            startAngle: 0\r\n        },\r\n\r\n        publicProperties: {\r\n\r\n        },\r\n\r\n        initialize: function () {\r\n            this.angle     = this.startAngle;\r\n            this.v         = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 0);\r\n            this.moving    = false;\r\n            this.piOverTwo = Math.PI / 2;\r\n            this.owner.rotation = this.owner.rotation || this.visualOffset;\r\n        },\r\n\r\n        events: {\r\n\r\n            /**\r\n             * Updates the position, velocity, and rotation of the entity\r\n             *\r\n             * @method 'handle-logic'\r\n             * @param tick {Object} The tick data.\r\n             */\r\n            \"handle-logic\": function (tick) {\r\n                var PI  = Math.PI,\r\n                    sin = Math.sin,\r\n                    cos = Math.cos,\r\n                    min = Math.min,\r\n                    max = Math.max,\r\n                    delta        = tick.delta,\r\n                    currentAngle = 0;\r\n                \r\n                if (this.moving) {\r\n                    this.v[0] += this.acceleration * cos(this.angle) * delta;\r\n                    this.v[1] += this.acceleration * sin(this.angle) * delta;\r\n                    if (this.v[0] === 0) {\r\n                        if (this.v[1] > 0) {\r\n                            currentAngle = this.piOverTwo;\r\n                        } else if (this.v[1] < 0) {\r\n                            currentAngle = -this.piOverTwo;\r\n                        } else {\r\n                            currentAngle = this.angle;\r\n                        }\r\n                    } else {\r\n                        currentAngle = Math.atan(this.v[1] / this.v[0]);\r\n                        if (this.v[0] < 0) {\r\n                            currentAngle = PI + currentAngle;\r\n                        }\r\n                    }\r\n                    if (this.v[0] >= 0) {\r\n                        this.v[0] = min(this.v[0], this.maxVelocity * cos(currentAngle));\r\n                    } else {\r\n                        this.v[0] = max(this.v[0], this.maxVelocity * cos(currentAngle));\r\n                    }\r\n                    if (this.v[1] >= 0) {\r\n                        this.v[1] = min(this.v[1], this.maxVelocity * sin(currentAngle));\r\n                    } else {\r\n                        this.v[1] = max(this.v[1], this.maxVelocity * sin(currentAngle));\r\n                    }\r\n                    \r\n                    this.owner.x += this.v[0];\r\n                    this.owner.y += this.v[1];\r\n\r\n                    this.owner.rotation = (currentAngle * (180 / PI)) + this.visualOffset;\r\n                }\r\n            },\r\n            /**\r\n             * Sets the internal heading angle in the component.\r\n             *\r\n             * @method 'set-angle'\r\n             * @param angle {Number} The value you want to set the angle to.\r\n             */\r\n            \"set-angle\": function (angle) {\r\n                this.angle = angle;\r\n            },\r\n            /**\r\n             * Start the entity accelerating toward the heading angle.\r\n             *\r\n             * @method 'move'\r\n             */\r\n            \"move\": function () {\r\n                this.moving = true;\r\n            },\r\n            /**\r\n             * Stops the movement toward the heading angle.\r\n             *\r\n             * @method 'stop'\r\n             */\r\n            \"stop\": function () {\r\n                this.moving = false;\r\n                this.v[0] = 0;\r\n                this.v[1] = 0;\r\n            },\r\n            /**\r\n             * Set the max velocity.\r\n             *\r\n             * @method 'set-max-velocity'\r\n             * @param newMaxV {Number} The max velocity value.\r\n             */\r\n            \"set-max-velocity\": function (newMaxV) {\r\n                this.maxVelocity = newMaxV;\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                this.v.recycle();\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicAngularMovement.js?");

/***/ }),

/***/ "./src/components/LogicAttachment.js":
/*!*******************************************!*\
  !*** ./src/components/LogicAttachment.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n * Creates an entity and connects it with the owner entity. This is useful for entities that have a one-to-one relationship with a given entity and must move as if connected to the host entity.\r\n *\r\n * @namespace platypus.components\r\n * @class LogicAttachment\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var\r\n        trigger = function () {\r\n            var attachment = this.attachment;\r\n            \r\n            if (attachment) {\r\n                attachment.trigger.apply(attachment, arguments);\r\n            }\r\n        };\r\n\r\n    return platypus.createComponentClass({\r\n\r\n        id: 'LogicAttachment',\r\n\r\n        properties: {\r\n            /**\r\n             * An owner state, set to true when the attachment is attached. Meant to be read by other components or used in rendering.\r\n             *\r\n             * @property attachState\r\n             * @type String\r\n             * @default 'attached'\r\n             */\r\n            attachState: 'attached',\r\n\r\n            /**\r\n             * The type of the entity to be attached.\r\n             *\r\n             * @property attachment\r\n             * @type String\r\n             * @default ''\r\n             */\r\n            attachment: '',\r\n\r\n            /**\r\n             * This is an object of key/value pairs. The keys are events this component is listening for locally, the value is the new event to be broadcast on the attached entity. The value can also be an array of events to be fired.\r\n             *\r\n             *      \"events\": {\r\n             *          \"sleeping\": \"good-night\",\r\n             *          \"awake\": [\"alarm\", \"get-up\"]\r\n             *      }\r\n             *\r\n             * @property events\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            events: null,\r\n\r\n            /**\r\n             * Whether the attachment starts out attached.\r\n             *\r\n             * @property startAttached\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            startAttached: false,\r\n\r\n            /**\r\n             * The offset of the attached entity in x from the attachee.\r\n             *\r\n             * @property offsetX\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            offsetX: 0,\r\n\r\n            /**\r\n             * The offset of the attached entity in y from the attachee.\r\n             *\r\n             * @property offsetY\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            offsetY: 0,\r\n\r\n            /**\r\n             * The offset of the attached entity in z from the attachee.\r\n             *\r\n             * @property offsetZ\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            offsetZ: 0.01\r\n        },\r\n\r\n        initialize: function () {\r\n            var event = '',\r\n                events = this.events;\r\n            \r\n            this.state = this.owner.state;\r\n\r\n            this.state.set(this.attachState, this.startAttached);\r\n            this.attachmentPosition = {\r\n                x: 0,\r\n                y: 0,\r\n                z: 0,\r\n                dx: 0,\r\n                dy: 0\r\n            };\r\n            this.attachmentProperties = {\r\n                type: this.attachment,\r\n                properties: this.attachmentPosition\r\n            };\r\n\r\n            this.attachment = null;\r\n            this.isAttached = this.startAttached;\r\n\r\n            // Messages that this component listens for and then triggers on the attached entity.\r\n            if (events) {\r\n                for (event in events) {\r\n                    if (events.hasOwnProperty(event)) {\r\n                        this.addEventListener(event, trigger.bind(this, events[event]));\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        events: {// These are messages that this component listens for\r\n\r\n            /**\r\n             * On receiving this message, updates the attached entity's position.\r\n             *\r\n             * @method 'handle-logic'\r\n             */\r\n            \"handle-logic\": function () {\r\n                var offset = 0,\r\n                    state  = this.state;\r\n\r\n                if (this.isAttached) {\r\n                    if (!this.attachment) {\r\n                        this.attachmentPosition.x = this.owner.x;\r\n                        this.attachmentPosition.y = this.owner.y;\r\n                        this.attachmentPosition.z = this.owner.z;\r\n                        this.attachment = this.owner.parent.addEntity(this.attachmentProperties);\r\n                    }\r\n                    \r\n                    if (this.attachment.destroyed) {\r\n                        this.owner.parent.removeEntity(this.attachment);\r\n                        this.attachment = null;\r\n                        this.isAttached = false;\r\n                    } else {\r\n                        this.attachment.x = this.owner.x;\r\n                        offset = this.offsetX;\r\n                        if (state.get('left')) { //TODO: Base this on object orientation. - DDD 3/2/2016\r\n                            offset *= -1;\r\n                            this.attachment.rotation = 180;\r\n                        } else if (state.get('right')) {\r\n                            this.attachment.rotation = 0;\r\n                        }\r\n                        this.attachment.x += offset;\r\n\r\n                        this.attachment.y = this.owner.y;\r\n                        offset = this.offsetY;\r\n                        if (state.get('top')) {\r\n                            offset *= -1;\r\n                            this.attachment.rotation = 90;\r\n                        } else if (state.get('bottom')) {\r\n                            this.attachment.rotation = -90;\r\n                        }\r\n                        this.attachment.y += offset;\r\n\r\n                        this.attachment.z = this.owner.z;\r\n                        this.attachment.z += this.offsetZ;\r\n                    }\r\n                } else if (this.attachment) {\r\n                    this.owner.parent.removeEntity(this.attachment);\r\n                    this.attachment = null;\r\n                }\r\n                \r\n                state.set(this.attachState, this.isAttached);\r\n            },\r\n\r\n            /**\r\n             * Creates and attaches the entity. The input value makes it possible to attach the entity on user input.\r\n             *\r\n             * @method 'attach'\r\n             * @param input {Object} An input object.\r\n             * @param input.pressed {Boolean} If set to true, the entity is created and attached.\r\n             */\r\n            \"attach\": function (input) {\r\n                this.isAttached = !input || (input.pressed !== false);\r\n            },\r\n            /**\r\n             * Detaches and removes the entity.\r\n             *\r\n             * @method 'detach'\r\n             */\r\n            \"detach\": function () {\r\n                this.isAttached = false;\r\n            },\r\n            /**\r\n             * Changes the x, y, and z offset of the attachment.\r\n             *\r\n             * @method 'change-attachment-offset'\r\n             * @param offset {Object} An object containing the offset values.\r\n             * @param input.x {Number} The new X offset.\r\n             * @param input.y {Number} The new Y offset.\r\n             * @param input.y {Number} The new Z offset.\r\n             */\r\n            \"change-attachment-offset\": function (offset) {\r\n                if (typeof offset.x !== 'undefined') {\r\n                    this.offsetX = offset.x;\r\n                } else if (typeof offset.y !== 'undefined') {\r\n                    this.offsetY = offset.y;\r\n                } else if (typeof offset.z !== 'undefined') {\r\n                    this.offsetZ = offset.z;\r\n                }\r\n            }\r\n        },\r\n\r\n        methods: {\r\n            destroy: function () {\r\n                this.state.set(this.attachState, false);\r\n                if (this.attachment) {\r\n                    this.owner.parent.removeEntity(this.attachment);\r\n                    this.attachment = null;\r\n                }\r\n                this.isAttached = false;\r\n                this.state = null;\r\n            }\r\n        },\r\n        \r\n        getAssetList: function (def, props, defaultProps) {\r\n            var attachment = def.attachment || props.attachment || defaultProps.attachment;\r\n            \r\n            if (attachment) {\r\n                return _Entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getAssetList({\r\n                    type: attachment\r\n                });\r\n            }\r\n            \r\n            return _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicAttachment.js?");

/***/ }),

/***/ "./src/components/LogicButton.js":
/*!***************************************!*\
  !*** ./src/components/LogicButton.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/**\r\n * Provides button functionality for a RenderSprite component.\r\n *\r\n * @namespace platypus.components\r\n * @class LogicButton\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n\r\n        id: 'LogicButton',\r\n\r\n        properties: {\r\n            /**\r\n             * The event to trigger when pressed.\r\n             *\r\n             * @property onPress\r\n             * @type String\r\n             * @default \"\"\r\n             */\r\n            \"onPress\": \"\",\r\n\r\n            /**\r\n             * The event to trigger when released.\r\n             *\r\n             * @property onRelease\r\n             * @type String\r\n             * @default \"\"\r\n             */\r\n            \"onRelease\": \"\",\r\n\r\n            /**\r\n             * The event to trigger when cancelled.\r\n             *\r\n             * @property onCancel\r\n             * @type String\r\n             * @default \"\"\r\n             */\r\n            \"onCancel\": \"\",\r\n\r\n            /**\r\n             * The event to trigger when the user mouses over the button\r\n             *\r\n             * @property hoverAudio\r\n             * @type String or an Array of Strings and Message Objects\r\n             * @default \"\"\r\n             * @since 0.9.0\r\n             */\r\n            \"onHover\": \"\",\r\n\r\n            /**\r\n             * Whether this button's actions should be limited to the initial press/release.\r\n             *\r\n             * @property useOnce\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            \"useOnce\": false,\r\n\r\n            /**\r\n             * Whether this button should start disabled.\r\n             *\r\n             * @property disabled\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            \"disabled\": false,\r\n\r\n            /**\r\n             * Determines whether this button should behave as a toggle.\r\n             *\r\n             * @property toggle\r\n             * @type Boolean\r\n             * @default false\r\n             * @since 0.9.1\r\n             */\r\n            \"toggle\": false,\r\n\r\n            /**\r\n             * Specifies whether the button starts off 'pressed'; typically only useful for toggle buttons.\r\n             *\r\n             * @property pressed\r\n             * @type Boolean\r\n             * @default false\r\n             * @since 0.9.1\r\n             */\r\n            \"pressed\": false\r\n        },\r\n\r\n        publicProperties: {\r\n            /**\r\n             * This sets the distance in world units from the bottom of the camera's world viewport. If set, it will override the entity's y coordinate. This property is accessible on the entity as `entity.bottom`.\r\n             *\r\n             * @property bottom\r\n             * @type Number\r\n             * @default null\r\n             * @since 0.9.0\r\n             */\r\n            \"bottom\": null,\r\n\r\n            /**\r\n             * This sets the distance in world units from the left of the camera's world viewport. If set, it will override the entity's x coordinate. This property is accessible on the entity as `entity.left`.\r\n             *\r\n             * @property left\r\n             * @type Number\r\n             * @default null\r\n             * @since 0.9.0\r\n             */\r\n            \"left\": null,\r\n\r\n            /**\r\n             * This sets the distance in world units from the right of the camera's world viewport. If set, it will override the entity's x coordinate. This property is accessible on the entity as `entity.right`.\r\n             *\r\n             * @property right\r\n             * @type Number\r\n             * @default null\r\n             * @since 0.9.0\r\n             */\r\n            \"right\": null,\r\n\r\n            /**\r\n             * This sets the distance in world units from the top of the camera's world viewport. If set, it will override the entity's y coordinate. This property is accessible on the entity as `entity.top`.\r\n             *\r\n             * @property top\r\n             * @type Number\r\n             * @default null\r\n             * @since 0.9.0\r\n             */\r\n            \"top\": null\r\n        },\r\n\r\n        initialize: function () {\r\n            var state = this.owner.state;\r\n            \r\n            this.aabb = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\r\n            this.lastBottom = null;\r\n            this.lastLeft = null;\r\n            this.lastRight = null;\r\n            this.lastTop = null;\r\n\r\n            this.state = state;\r\n            state.set('disabled', this.disabled);\r\n            state.set('released', !this.pressed);\r\n            state.set('pressed', this.pressed);\r\n            state.set('highlighted', false);\r\n            this.owner.buttonMode = !this.disabled;\r\n            this.cancelled = false;\r\n\r\n            this.readyToToggle = false;\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * This component uses location updates to reposition the entity if its bottom, left, right, or top properties have been set.\r\n             *\r\n             * @method 'handle-logic'\r\n             * @since 0.11.5\r\n             */\r\n            \"handle-logic\": function () {\r\n                var bottom = this.bottom,\r\n                    left = this.left,\r\n                    right = this.right,\r\n                    top = this.top;\r\n\r\n                if ((this.lastBottom !== bottom) || (this.lastLeft !== left) || (this.lastRight !== right) || (this.lastTop !== top)) {\r\n                    this.updatePosition(this.aabb);\r\n                    this.lastBottom = bottom;\r\n                    this.lastLeft = left;\r\n                    this.lastRight = right;\r\n                    this.lastTop = top;\r\n                }\r\n            },\r\n\r\n            /**\r\n             * This component listens for camera updates to reposition the entity if its bottom, left, right, or top properties have been set.\r\n             *\r\n             * @method 'camera-update'\r\n             * @param camera {platypus.Data} Camera update information\r\n             * @param camera.viewport {platypus.AABB} The bounding box describing the camera viewport location in the world.\r\n             * @since 0.9.0\r\n             */\r\n            \"camera-update\": function (camera) {\r\n                this.aabb.set(camera.viewport);\r\n                this.updatePosition(this.aabb);\r\n            },\r\n\r\n            /**\r\n             * Triggers events per the component's definition when a press is made.\r\n             *\r\n             * @method 'pointerdown'\r\n             */\r\n            \"pointerdown\": function (eventData) {\r\n                if (!this.state.get('disabled')) {\r\n                    if (this.toggle) {\r\n                        this.readyToToggle = true;\r\n                    } else {\r\n                        if (this.onPress) {\r\n                            this.owner.trigger(this.onPress);\r\n                        }\r\n\r\n                        /**\r\n                         * This event is triggered when the button is pressed to mimic keypress events. If the button is a toggle button, this only occurs on up-to-down.\r\n                         *\r\n                         * @event 'pressed'\r\n                         * @param buttonState {platypus.Data} The state of the button\r\n                         * @param buttonState.pressed {Boolean} This is `true` for the 'pressed' event.\r\n                         * @param buttonState.released {Boolean} This is `false` for the 'pressed' event.\r\n                         * @param buttonState.triggered {Boolean} This is `true` for the 'pressed' event.\r\n                         * @param buttonState.entity {platypus.Entity} The entity for which the original event occurred.\r\n                         * @since 0.9.1\r\n                         */\r\n                        this.updateStateAndTrigger('pressed');\r\n                        if (eventData && eventData.pixiEvent && eventData.pixiEvent.stopPropagation) { // ensure a properly formed event has been sent\r\n                            eventData.pixiEvent.stopPropagation();\r\n                        }\r\n\r\n                        // Doing this prevents the call from reccurring.\r\n                        if (this.useOnce && this.removeEventListener) {\r\n                            this.removeEventListener('pointerdown');\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Triggers events per the component's definition when a press is released.\r\n             *\r\n             * @method 'pressup'\r\n             */\r\n            \"pressup\": function (eventData) {\r\n                var state = this.state;\r\n\r\n                if (!state.get('disabled')) {\r\n                    if (this.cancelled) {\r\n                        if (this.onCancel) {\r\n                            this.owner.trigger(this.onCancel);\r\n                        }\r\n\r\n                        /**\r\n                         * This event is triggered when the button is pressed and the mouse/touch is dragged off-target before release.\r\n                         *\r\n                         * @event 'cancelled'\r\n                         * @param buttonState {platypus.Data} The state of the button\r\n                         * @param buttonState.pressed {Boolean} This is `false` for the 'cancelled' event.\r\n                         * @param buttonState.released {Boolean} This is `true` for the 'cancelled' event.\r\n                         * @param buttonState.triggered {Boolean} This is `false` for the 'cancelled' event.\r\n                         * @param buttonState.entity {platypus.Entity} The entity for which the original event occurred.\r\n                         * @since 0.9.1\r\n                         */\r\n                        this.updateStateAndTrigger('cancelled');\r\n                    } else if (this.toggle) {\r\n                        if (this.readyToToggle) {\r\n                            if (state.get('pressed')) {\r\n                                this.updateStateAndTrigger('released');\r\n                            } else {\r\n                                this.updateStateAndTrigger('pressed');\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (this.onRelease) {\r\n                            this.owner.trigger(this.onRelease);\r\n                        }\r\n\r\n                        /**\r\n                         * This event is triggered when the button is released, or on the down-to-up change for toggle buttons.\r\n                         *\r\n                         * @event 'released'\r\n                         * @param buttonState {platypus.Data} The state of the button\r\n                         * @param buttonState.pressed {Boolean} This is `false` for the 'released' event.\r\n                         * @param buttonState.released {Boolean} This is `true` for the 'released' event.\r\n                         * @param buttonState.triggered {Boolean} This is `false` for the 'released' event.\r\n                         * @param buttonState.entity {platypus.Entity} The entity for which the original event occurred.\r\n                         * @since 0.9.1\r\n                         */\r\n                        this.updateStateAndTrigger('released');\r\n                    }\r\n                    if (eventData && eventData.pixiEvent && eventData.pixiEvent.stopPropagation) { // ensure a properly formed event has been sent\r\n                        eventData.pixiEvent.stopPropagation();\r\n                    }\r\n\r\n                    // Doing this prevents the call from reccurring.\r\n                    if (this.useOnce && this.removeEventListener) { //Second check is to ensure method exists which won't be the case if a result of the press is the button being destroyed.\r\n                        this.removeEventListener('pressup');\r\n                        this.state.set('disabled', true);\r\n                        this.owner.buttonMode = false;\r\n                    }\r\n                }\r\n\r\n                this.cancelled = false;\r\n                this.readyToToggle = false;\r\n            },\r\n\r\n            /**\r\n             * If a press moves over the button, it's not cancelled.\r\n             *\r\n             * @method 'pointerover'\r\n             */\r\n            \"pointerover\": function () {\r\n                if (this.onHover) {\r\n                    this.owner.trigger(this.onHover);\r\n                }\r\n                if (this.state.get('pressed')) {\r\n                    this.cancelled = false;\r\n                }\r\n            },\r\n\r\n            /**\r\n             * If a press moves off of the button, it's cancelled.\r\n             *\r\n             * @method 'pointerout'\r\n             */\r\n            \"pointerout\": function () {\r\n                if (this.state.get('pressed')) {\r\n                    this.cancelled = true;\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * Disables the entity.\r\n             *\r\n             * @method 'disable'\r\n             */\r\n            \"disable\": function () {\r\n                this.state.set('disabled', true);\r\n                this.owner.buttonMode = false;\r\n            },\r\n            \r\n            /**\r\n             * Enables the entity.\r\n             *\r\n             * @method 'enable'\r\n             */\r\n            \"enable\": function () {\r\n                this.state.set('disabled', false);\r\n                this.owner.buttonMode = true;\r\n            },\r\n\r\n            /**\r\n             * Toggles whether the entity is disabled.\r\n             *\r\n             * @method 'toggle-disabled'\r\n             */\r\n            \"toggle-disabled\": function () {\r\n                var value = this.state.get('disabled');\r\n                \r\n                this.owner.buttonMode = value;\r\n                this.state.set('disabled', !value);\r\n            },\r\n            \r\n            /**\r\n             * Sets the entity's highlighted state to `true`.\r\n             *\r\n             * @method 'highlight'\r\n             * @since 0.8.6\r\n             */\r\n            \"highlight\": function () {\r\n                this.state.set('highlighted', true);\r\n            },\r\n            \r\n            /**\r\n             * Sets the entity's highlighted state to `false`.\r\n             *\r\n             * @method 'unhighlight'\r\n             * @since 0.8.6\r\n             */\r\n            \"unhighlight\": function () {\r\n                this.state.set('highlighted', false);\r\n            },\r\n            \r\n            /**\r\n             * Toggles the entity's highlighted state.\r\n             *\r\n             * @method 'toggle-highlight'\r\n             * @since 0.8.6\r\n             */\r\n            \"toggle-highlight\": function () {\r\n                var state = this.state;\r\n\r\n                state.set('highlighted', !state.get('highlighted'));\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            updatePosition: function (vp) {\r\n                var bottom = this.bottom,\r\n                    left = this.left,\r\n                    owner = this.owner,\r\n                    right = this.right,\r\n                    top = this.top;\r\n\r\n                if (typeof left === 'number') {\r\n                    owner.x = vp.left + left;\r\n                } else if (typeof right === 'number') {\r\n                    owner.x = vp.right - right;\r\n                }\r\n\r\n                if (typeof top === 'number') {\r\n                    owner.y = vp.top + top;\r\n                } else if (typeof bottom === 'number') {\r\n                    owner.y = vp.bottom - bottom;\r\n                }\r\n            },\r\n\r\n            updateStateAndTrigger: function (event) {\r\n                var message = null,\r\n                    owner = this.owner,\r\n                    state = this.state,\r\n                    pressed = state.get('pressed'),\r\n                    released = state.get('released'),\r\n                    toggled = false;\r\n                \r\n                if (released && (event === 'pressed')) {\r\n                    state.set('pressed', true);\r\n                    state.set('released', false);\r\n                    toggled = true;\r\n                } else if (pressed && ((event === 'released') || (event === 'cancelled'))) {\r\n                    state.set('pressed', false);\r\n                    state.set('released', true);\r\n                    toggled = true;\r\n                }\r\n\r\n                if (toggled) {\r\n                    message = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\r\n                        'released', pressed,\r\n                        'pressed', released,\r\n                        'triggered', released,\r\n                        'entity', owner\r\n                    );\r\n                    owner.triggerEvent(event, message);\r\n                    message.recycle();\r\n                }\r\n            },\r\n\r\n            destroy: function () {\r\n                this.aabb.recycle();\r\n                this.aabb = null;\r\n                this.owner.buttonMode = false;\r\n                this.state = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicButton.js?");

/***/ }),

/***/ "./src/components/LogicCarrier.js":
/*!****************************************!*\
  !*** ./src/components/LogicCarrier.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * This component allows this entity carry other entities with which it collides. Entities that this component should carry need to have a [[Logic-Portable]] component attached to notify this entity that they are portable.\r\n *\r\n * @namespace platypus.components\r\n * @class LogicCarrier\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n\r\n    return platypus.createComponentClass({\r\n        id: 'LogicCarrier',\r\n        initialize: function () {},\r\n        events: {\r\n            /**\r\n             * On receiving this message, the component ensures that it has a peer collision group component, and adds one if not.\r\n             *\r\n             * @method 'load'\r\n             */\r\n            \"load\": function () {\r\n                /**\r\n                 * On receiving a `carry-me` message, this component triggers this message to add the portable peer to the collision group.\r\n                 *\r\n                 * @event 'add-collision-entity'\r\n                 * @param entity {platypus.Entity} The entity being added to the collision group.\r\n                 */\r\n                if (!this.owner.triggerEvent('add-collision-entity', this.owner)) {\r\n                    // This message wasn't handled, so add a CollisionGroup component and try again!\r\n                    this.owner.addComponent(new platypus.components.CollisionGroup(this.owner, {}));\r\n                    this.owner.triggerEvent('add-collision-entity', this.owner);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * On receiving this message, the component triggers `add-collision-entity` on the entity to add the peer entity to its collision group.\r\n             *\r\n             * @method 'carry-me'\r\n             * @param message.entity {platypus.Entity} The peer entity requesting to be carried.\r\n             */\r\n            \"carry-me\": function (resp) {\r\n                this.owner.triggerEvent('add-collision-entity', resp.entity);\r\n            },\r\n\r\n            /**\r\n             * On receiving this message, the component triggers `remove-collision-entity` on the entity to remove the peer entity from its collision group.\r\n             *\r\n             * @method 'carry-me'\r\n             * @param message.entity {platypus.Entity} The peer entity requesting to be released.\r\n             */\r\n            \"release-me\": function (resp) {\r\n                /**\r\n                 * On receiving a `release-me` message, this component triggers this message to remove the portable peer to the collision group.\r\n                 *\r\n                 * @event 'remove-collision-entity'\r\n                 * @param entity {platypus.Entity} The entity being removed from the collision group.\r\n                 */\r\n                this.owner.triggerEvent('remove-collision-entity', resp.entity);\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicCarrier.js?");

/***/ }),

/***/ "./src/components/LogicDestroyMe.js":
/*!******************************************!*\
  !*** ./src/components/LogicDestroyMe.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * This component allows an entity to be removed from the stage when \"destroy-me\" is triggered.\r\n *\r\n * @namespace platypus.components\r\n * @class LogicDestroyMe\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'LogicDestroyMe',\r\n        \r\n        properties: {\r\n            /**\r\n             * Time in milliseconds after the \"destroy-me\" message is heard before entity should be removed.\r\n             *\r\n             * @property delay\r\n             * @type number\r\n             * @default 0\r\n             */\r\n            delay: 0,\r\n\r\n            /**\r\n             * Whether this entity has been destroyed. Typically `false` until a \"destroy-me\" event has been triggered.\r\n             *\r\n             * @property destroyed\r\n             * @type boolean\r\n             * @default false\r\n             */\r\n            destroyed: false\r\n        },\r\n        \r\n        events: {// These are messages that this component listens for\r\n\r\n            /**\r\n             * On a `tick` logic message, the component checks whether it should be removed or not.\r\n             *\r\n             * @method 'prepare-logic'\r\n             * @param message.delta {number} To measure the delay before removal, the component keeps a running count of step lengths.\r\n             */\r\n            \"prepare-logic\": function (tick) {\r\n                var dT = tick.delta;\r\n                \r\n                if (this.destroyed && !this.owner.state.get('paused')) {\r\n                    this.delay -= dT;\r\n                    if (this.delay <= 0) {\r\n                        this.owner.parent.removeEntity(this.owner);\r\n                    }\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * This component will set the entity up for removal on receiving this message.\r\n             *\r\n             * @method 'destroy-me'\r\n             */\r\n            \"destroy-me\": function () {\r\n                this.destroyed = true;\r\n            }\r\n                   \r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicDestroyMe.js?");

/***/ }),

/***/ "./src/components/LogicDirectionalMovement.js":
/*!****************************************************!*\
  !*** ./src/components/LogicDirectionalMovement.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/**\r\n * This component changes the [Motion](platypus.components.Motion.html) of an entity according to its current speed and heading. It accepts directional messages that can stand alone, or come from a mapped controller, in which case it checks the `pressed` value of the message before changing its course.\r\n *\r\n * @namespace platypus.components\r\n * @class LogicDirectionalMovement\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var processDirection = function (direction) {\r\n            return function (state) {\r\n                this[direction] = !state || (state.pressed !== false);\r\n            };\r\n        },\r\n        doNothing = function () {},\r\n        rotate = {\r\n            x: function (heading, lastHeading) {\r\n                if (heading !== lastHeading) {\r\n                    if (((heading > 180) && (lastHeading <= 180)) || ((heading <= 180) && (lastHeading > 180))) {\r\n                        this.owner.triggerEvent('transform', 'vertical');\r\n                    }\r\n                }\r\n            },\r\n            y: function (heading, lastHeading) {\r\n                if (heading !== lastHeading) {\r\n                    if (((heading > 90 && heading <= 270) && (lastHeading <= 90 || lastHeading > 270)) || ((heading <= 90 || heading > 270) && (lastHeading > 90 && lastHeading <= 270))) {\r\n                        this.owner.triggerEvent('transform', 'horizontal');\r\n                    }\r\n                }\r\n            },\r\n            z: function (heading, lastHeading) {\r\n                if (heading !== lastHeading) {\r\n                    this.owner.triggerEvent('replace-transform', 'rotate-' + heading);\r\n                }\r\n            }\r\n        };\r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'LogicDirectionalMovement',\r\n        \r\n        properties: {\r\n            /**\r\n             * Defines the axis around which the entity should be transformed. Defaults to \"y\" for platforming behavior. Use \"z\" for top-down behavior.\r\n             *\r\n             * @property axis\r\n             * @type String\r\n             * @default \"y\"\r\n             */\r\n            axis: 'y',\r\n\r\n            /**\r\n             * Defines the distance in world units that the entity should be moved per millisecond.\r\n             *\r\n             * @property speed\r\n             * @type Number\r\n             * @default 0.3\r\n             */\r\n            speed: 0.3\r\n        },\r\n        \r\n        initialize: function () {\r\n            var state = this.state = this.owner.state;\r\n            \r\n            if (typeof this.speed === 'number') {\r\n                this.speed = [this.speed, 0, 0];\r\n            }\r\n            this.initialVector = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.speed);\r\n            this.reorient = rotate[this.axis];\r\n            if (!this.reorient) {\r\n                this.reorient = doNothing;\r\n            }\r\n            \r\n            this.moving = state.set('moving', false);\r\n            this.left   = state.set('left', false);\r\n            this.right  = state.set('right', false);\r\n            this.up     = state.set('up', false);\r\n            this.down   = state.set('down', false);\r\n\r\n            this.upLeft = false;\r\n            this.upRight = false;\r\n            this.downLeft = false;\r\n            this.downRight = false;\r\n            \r\n            this.heading = 0;\r\n            this.owner.heading = this.owner.heading || 0;\r\n        },\r\n        events: {\r\n            /**\r\n             * This method checks to make sure there is a `Mover` component attached and sets up initial heading.\r\n             *\r\n             * @method 'component-added'\r\n             */\r\n            \"component-added\": function (component) {\r\n                if (component === this) {\r\n                    if (!this.owner.addMover) {\r\n                        platypus.debug.warn('The \"LogicDirectionalMovement\" component requires a \"Mover\" component to function correctly.');\r\n                        return;\r\n                    }\r\n\r\n                    this.direction = this.owner.addMover({\r\n                        velocity: this.speed,\r\n                        drag: 0,\r\n                        friction: 0,\r\n                        stopOnCollision: false,\r\n                        orient: false,\r\n                        aliases: {\r\n                            \"moving\": \"control-velocity\"\r\n                        }\r\n                    }).velocity;\r\n                    \r\n                    if (this.owner.heading !== this.heading) {\r\n                        this.direction.setVector(this.initialVector).rotate((this.owner.heading / 180) * Math.PI);\r\n                        this.heading = this.owner.heading;\r\n                    }\r\n                    \r\n                    this.owner.triggerEvent('moving', this.moving);\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the component updates its direction of motion according to its current state.\r\n             *\r\n             * @method 'handle-logic'\r\n             */\r\n            \"handle-logic\": function () {\r\n                var state = this.state,\r\n                    up        = this.up        || this.upLeft || this.upRight,\r\n                    upLeft    = this.upLeft    || (this.up   && this.left),\r\n                    left      = this.left      || this.upLeft || this.downLeft,\r\n                    downLeft  = this.downLeft  || (this.down && this.left),\r\n                    down      = this.down      || this.downLeft || this.downRight,\r\n                    downRight = this.downRight || (this.down && this.right),\r\n                    right     = this.right     || this.upRight || this.downRight,\r\n                    upRight   = this.upRight   || (this.up   && this.right);\r\n                \r\n                if ((left && right) || (up && down)) {\r\n                    this.moving = false;\r\n                } else if (upLeft) {\r\n                    this.moving = true;\r\n                    this.heading = 225;\r\n                } else if (upRight) {\r\n                    this.moving = true;\r\n                    this.heading = 315;\r\n                } else if (downLeft) {\r\n                    this.moving = true;\r\n                    this.heading = 135;\r\n                } else if (downRight) {\r\n                    this.moving = true;\r\n                    this.heading = 45;\r\n                } else if (left) {\r\n                    this.moving = true;\r\n                    this.heading = 180;\r\n                } else if (right) {\r\n                    this.moving = true;\r\n                    this.heading = 0;\r\n                } else if (up) {\r\n                    this.moving = true;\r\n                    this.heading = 270;\r\n                } else if (down) {\r\n                    this.moving = true;\r\n                    this.heading = 90;\r\n                } else {\r\n                    this.moving = false;\r\n                    \r\n                    // This is to retain the entity's direction even if there is no movement. There's probably a better way to do this since this is a bit of a retrofit. - DDD\r\n                    switch (this.heading) {\r\n                    case 270:\r\n                        up = true;\r\n                        break;\r\n                    case 90:\r\n                        down = true;\r\n                        break;\r\n                    case 180:\r\n                        left = true;\r\n                        break;\r\n                    case 225:\r\n                        up = true;\r\n                        left = true;\r\n                        break;\r\n                    case 315:\r\n                        up = true;\r\n                        right = true;\r\n                        break;\r\n                    case 135:\r\n                        down = true;\r\n                        left = true;\r\n                        break;\r\n                    case 45:\r\n                        down = true;\r\n                        right = true;\r\n                        break;\r\n                    case 0:\r\n                    default:\r\n                        right = true;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                if (this.owner.heading !== this.heading) {\r\n                    this.direction.setVector(this.initialVector).rotate((this.heading / 180) * Math.PI);\r\n                    this.reorient(this.heading, this.owner.heading);\r\n                    this.owner.heading = this.heading;\r\n                }\r\n                \r\n                //TODO: possibly remove the separation of this.state.direction and this.direction to just use state?\r\n                if (state.get('moving') !== this.moving) {\r\n                    this.owner.triggerEvent('moving', this.moving);\r\n                    state.set('moving', this.moving);\r\n                }\r\n\r\n                state.set('up', up);\r\n                state.set('right', right);\r\n                state.set('down', down);\r\n                state.set('left', left);\r\n            },\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-down'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-down\": processDirection('down'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-south'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-south\": processDirection('down'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-down-left'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-down-left\": processDirection('downLeft'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-southwest'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-southwest\": processDirection('downLeft'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-left'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-left\": processDirection('left'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-west'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-west\": processDirection('left'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-up-left'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-up-left\": processDirection('upLeft'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-northwest'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-northwest\": processDirection('upLeft'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-up'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-up\": processDirection('up'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-north'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-north\": processDirection('up'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-up-right'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-up-right\": processDirection('upRight'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-northeast'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-northeast\": processDirection('upRight'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-right'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-right\": processDirection('right'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-east'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-east\": processDirection('right'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-down-right'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-down-right\": processDirection('downRight'),\r\n\r\n            /**\r\n             * On receiving this message, this component updates its heading accordingly.\r\n             *\r\n             * @method 'go-southeast'\r\n             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.\r\n             */\r\n            \"go-southeast\": processDirection('downRight'),\r\n            \r\n            /**\r\n             * Stops motion in all directions until movement messages are again received.\r\n             *\r\n             * @method 'stop'\r\n             * @param message.pressed (boolean) - Optional. If `message` is included, the component checks the value of `pressed`: a value of false will not stop the entity.\r\n             */\r\n            \"stop\": function (state) {\r\n                if (!state || (state.pressed !== false)) {\r\n                    this.left = false;\r\n                    this.right = false;\r\n                    this.up = false;\r\n                    this.down = false;\r\n                    this.upLeft = false;\r\n                    this.upRight = false;\r\n                    this.downLeft = false;\r\n                    this.downRight = false;\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * Set the direction the entity should face while stopped.\r\n             *\r\n             * @method 'face'\r\n             * @param direction {String} A value such as \"north\" or \"left\" to point the entity in a particular direction.\r\n             */\r\n            \"face\": (function () {\r\n                var headings = {\r\n                    up: 270,\r\n                    north: 270,\r\n                    down: 90,\r\n                    south: 90,\r\n                    left: 180,\r\n                    west: 180,\r\n                    right: 0,\r\n                    east: 0,\r\n                    \"up-left\": 225,\r\n                    northwest: 225,\r\n                    \"up-right\": 315,\r\n                    northeast: 315,\r\n                    \"down-left\": 135,\r\n                    southwest: 135,\r\n                    \"down-right\": 45,\r\n                    southeast: 45\r\n                };\r\n                \r\n                return function (direction) {\r\n                    this.heading = headings[direction] || 0;\r\n                };\r\n            }()),\r\n            \r\n            /**\r\n             * Changes the velocity of the Entity when in motion.\r\n             *\r\n             * @method 'accelerate'\r\n             * @param velocity {Number|platypus.Vector} The magnitude or Vector to multiply the current velocity by.\r\n             */\r\n            \"accelerate\": function (velocity) {\r\n                this.initialVector.normalize().multiply(velocity);\r\n                this.direction.normalize().multiply(velocity);\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                this.initialVector.recycle();\r\n                this.state = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicDirectionalMovement.js?");

/***/ }),

/***/ "./src/components/LogicDragDrop.js":
/*!*****************************************!*\
  !*** ./src/components/LogicDragDrop.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * A component that allows an object to be dragged and dropped. Can use collision to prevent dropping the objects in certain locations.\r\n *\r\n * @namespace platypus.components\r\n * @class LogicDragDrop\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n\r\n    return platypus.createComponentClass({\r\n        id: 'LogicDragDrop',\r\n        \r\n        properties: {\r\n            /**\r\n             * Sets the renderParent while being dragged.\r\n             *\r\n             * @property dragRenderParent\r\n             * @type string\r\n             * @default ''\r\n             */\r\n            dragRenderParent: '',\r\n            \r\n            /**\r\n             * Sets whether a click-move should start the dragging behavior in addition to click-drag. This value is ignored for mobile devices.\r\n             *\r\n             * @property stickyClick\r\n             * @type Boolean\r\n             * @default false\r\n             * @since 0.8.3\r\n             */\r\n            stickyClick: false\r\n        },\r\n        \r\n        initialize: function () {\r\n            this.nextX = this.owner.x;\r\n            this.nextY = this.owner.y;\r\n            this.lastZ = this.owner.z;\r\n            this.grabOffsetX = 0;\r\n            this.grabOffsetY = 0;\r\n            this.state = this.owner.state;\r\n            this.state.set('dragging', false);\r\n            this.state.set('noDrop', false);\r\n            this.tryDrop = false;\r\n            this.hitSomething = false;\r\n            this.hasCollision = false;\r\n            \r\n            if (platypus.supports.mobile) {\r\n                this.stickyClick = false;\r\n            }\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * This component listens for added components to determine whether it should check for collision.\r\n             *\r\n             * @method 'component-added'\r\n             * @param component {platypus.Component} Component added to entity.\r\n             * @param component.type {String} Type of component to detect whether it's a collision component.\r\n             */\r\n            \"component-added\": function (component) {\r\n                if (component.type === 'CollisionBasic') {\r\n                    this.hasCollision = true;\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * Updates the object's location on the handle-logic tick.\r\n             *\r\n             * @method 'handle-logic'\r\n             */\r\n            \"handle-logic\": function () {\r\n                if (this.state.get('dragging')) {\r\n                    this.owner.x = this.nextX;\r\n                    this.owner.y = this.nextY;\r\n                    this.owner.triggerEvent('hovering');\r\n                }\r\n                \r\n                this.state.set('noDrop', false);\r\n            },\r\n\r\n            /**\r\n             * Resolves whether the object state after we check if there are any collisions. If the object was dropped and can be dropped, it is.\r\n             *\r\n             * @method 'handle-post-collision-logic'\r\n             */\r\n            \"handle-post-collision-logic\": function () {\r\n                if (this.tryDrop) {\r\n                    this.tryDrop = false;\r\n                    if (this.hitSomething) {\r\n                        this.dropFailed = false;\r\n                        this.state.set('noDrop', true);\r\n                        this.state.set('dragging', true);\r\n                        this.owner.dragMode = true;\r\n                    } else {\r\n                        this.state.set('noDrop', false);\r\n                        this.state.set('dragging', false);\r\n                        this.owner.dragMode = false;\r\n                    }\r\n                } else if (this.hitSomething) {\r\n                    this.state.set('noDrop', true);\r\n                }\r\n                this.hitSomething = false;\r\n            },\r\n\r\n            /**\r\n             * The pointerdown event fires when we're grabbing the object. Starts the drag.\r\n             *\r\n             * @method 'pointerdown'\r\n             * @param eventData {platypus.Data} The event data.\r\n             */\r\n            \"pointerdown\": function (eventData) {\r\n                if (this.sticking) {\r\n                    this.sticking = false;\r\n                    this.release();\r\n                } else {\r\n                    this.nextX = this.owner.x;\r\n                    this.nextY = this.owner.y;\r\n                    this.lastZ = this.owner.z;\r\n                    this.grabOffsetX = eventData.x - this.owner.x;\r\n                    this.grabOffsetY = eventData.y - this.owner.y;\r\n                    this.state.set('dragging', true);\r\n                    if (this.dragRenderParent !== this.owner.renderParent) {\r\n                        this.originalRenderParent = this.owner.renderParent;\r\n                        this.owner.parent.triggerEvent(\"set-parent-render-container\", this.owner, this.dragRenderParent);\r\n                    }\r\n                    this.owner.dragMode = true;\r\n                    this.sticking = this.stickyClick;\r\n                }\r\n                \r\n                eventData.pixiEvent.stopPropagation();\r\n            },\r\n\r\n            /**\r\n             * The pressup event fires when we're trying to drop the object.\r\n             *\r\n             * @method 'pressup'\r\n             * @param eventData {platypus.Data} The event data.\r\n             */\r\n            \"pressup\": function (eventData) {\r\n                if (!this.sticking) {\r\n                    this.release();\r\n                }\r\n                \r\n                eventData.pixiEvent.stopPropagation();\r\n            },\r\n\r\n            /**\r\n             * The pointermove event tells us when we're dragging a \"stickyClick\" object.\r\n             *\r\n             * @method 'pointermove'\r\n             * @param eventData {platypus.Data} The event data.\r\n             */\r\n            \"pointermove\": function (eventData) {\r\n                if (this.sticking) {\r\n                    this.nextX = eventData.x - this.grabOffsetX;\r\n                    this.nextY = eventData.y - this.grabOffsetY;\r\n                    \r\n                    eventData.event.preventDefault();\r\n                    eventData.pixiEvent.stopPropagation();\r\n                }\r\n            },\r\n\r\n            /**\r\n             * The pressmove event tells us when we're dragging the object.\r\n             *\r\n             * @method 'pressmove'\r\n             * @param eventData {platypus.Data} The event data.\r\n             */\r\n            \"pressmove\": function (eventData) {\r\n                this.nextX = eventData.x - this.grabOffsetX;\r\n                this.nextY = eventData.y - this.grabOffsetY;\r\n                if (this.nextX !== this.owner.x || this.nextY !== this.owner.y) {\r\n                    this.sticking = false;\r\n                }\r\n                \r\n                eventData.event.preventDefault();\r\n                eventData.pixiEvent.stopPropagation();\r\n            },\r\n\r\n            /**\r\n             * This message comes from the collision system letting us know the object is currently in a location that it cannot be dropped.\r\n             *\r\n             * @method 'no-drop'\r\n             */\r\n            \"no-drop\": function () {\r\n                this.hitSomething = true;\r\n            }\r\n        },\r\n        \r\n        methods: {// These are methods that are called by this component.\r\n            release: function () {\r\n                if (this.hasCollision) {\r\n                    this.tryDrop = true;\r\n                } else {\r\n                    this.state.set('noDrop', false);\r\n                    this.state.set('dragging', false);\r\n                    if (this.originalRenderParent) {\r\n                        this.owner.parent.triggerEvent(\"set-parent-render-container\", this.owner, this.originalRenderParent);\r\n                    }\r\n                    this.owner.dragMode = false;\r\n                    this.owner.z = this.lastZ;\r\n                }\r\n            },\r\n            \r\n            destroy: function () {\r\n                this.state.set('dragging', false);\r\n                this.owner.dragMode = false;\r\n                this.state.set('noDrop', false);\r\n                this.state = null;\r\n                this.owner.z = this.lastZ;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicDragDrop.js?");

/***/ }),

/***/ "./src/components/LogicImpactLaunch.js":
/*!*********************************************!*\
  !*** ./src/components/LogicImpactLaunch.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/**\r\n# COMPONENT **LogicImpactLaunch**\r\nThis component will cause the entity to move in a certain direction on colliding with another entity.\r\n\r\n## Dependencies:\r\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.\r\n\r\n## Messages\r\n\r\n### Listens for:\r\n- **handle-logic** - On a `tick` logic message, the component updates its location according to its current state.\r\n- **impact-launch** - On receiving this message, the component causes the entity's position to change according to the preset behavior.\r\n  - @param collisionInfo.x (number) - Either 1,0, or -1. 1 if we're colliding with an object on our right. -1 if on our left. 0 if not at all.\r\n  - @param collisionInfo.y (number) - Either 1,0, or -1. 1 if we're colliding with an object on our bottom. -1 if on our top. 0 if not at all.\r\n- **hit-solid** - On receiving this message, the component discontinues its impact-launch behavior.\r\n  - @param collisionInfo.y (number) - Either 1,0, or -1. If colliding below, impact-launch behavior ceases.\r\n\r\n## JSON Definition:\r\n    {\r\n      \"type\": \"LogicImpactLaunch\",\r\n      \r\n      \"state\": \"launching\",\r\n      // Optional: This sets the state of the entity while it's being launched. Defaults to \"stunned\".\r\n      \r\n      \"accelerationX\": 5,\r\n      \"accelerationY\": 5,\r\n      // Optional: acceleration entity should have in world units while being launched. Defaults to -0.2 for x and -0.6 for y.\r\n      \r\n      \"flipX\": true,\r\n      \"flipY\": true\r\n      // Optional: whether the directions of acceleration should flip according to the direction of the collision. Defaults to false for y and true for x.\r\n    }\r\n\r\n*/\r\n/* global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        id: 'LogicImpactLaunch',\r\n        \r\n        properties: {\r\n            accelerationX: -0.3,\r\n            accelerationY: -0.8,\r\n            flipX: true,\r\n            flipY: false\r\n        },\r\n        \r\n        initialize: function (definition) {\r\n            this.stunState = definition.state || \"stunned\";\r\n            \r\n            this.flipX = this.flipX ? -1 : 1;\r\n            this.flipY = this.flipY ? -1 : 1;\r\n\r\n            this.justJumped = false;\r\n            this.stunned = false;\r\n            \r\n            this.state = this.owner.state;\r\n            this.state.set('impact', false);\r\n            this.state.set(this.stunState, false);\r\n        },\r\n        \r\n        events: {\r\n            \"component-added\": function (component) {\r\n                if (component === this) {\r\n                    if (!this.owner.addMover) {\r\n                        platypus.debug.warn('The \"LogicDirectionalMovement\" component requires a \"Mover\" component to function correctly.');\r\n                        return;\r\n                    }\r\n\r\n                    this.direction = this.owner.addMover({\r\n                        velocity: [0, 0, 0],\r\n                        orient: false\r\n                    }).velocity;\r\n                    this.vector = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\r\n                }\r\n            },\r\n\r\n            \"handle-logic\": function () {\r\n                this.state.set('impact', this.justJumped);\r\n                this.state.set(this.stunState, this.stunned);\r\n\r\n                if (this.justJumped) {\r\n                    this.direction.setVector(this.vector);\r\n                    this.justJumped = false;\r\n                    this.stunned = true;\r\n                }\r\n            },\r\n            \r\n            \"impact-launch\": function (collisionInfo) {\r\n                var dx = collisionInfo.x,\r\n                    dy = collisionInfo.y;\r\n                \r\n                if (collisionInfo.entity) {\r\n                    dx = collisionInfo.entity.x - this.owner.x;\r\n                    dy = collisionInfo.entity.y - this.owner.y;\r\n                }\r\n\r\n                if (!this.stunned) {\r\n                    this.justJumped = true;\r\n                    if (dx >= 0) {\r\n                        this.vector.x = this.accelerationX;\r\n                    } else if (dx < 0) {\r\n                        this.vector.x = this.accelerationX * this.flipX;\r\n                    }\r\n                    if (dy >= 0) {\r\n                        this.vector.y = this.accelerationY;\r\n                    } else if (dy < 0) {\r\n                        this.vector.y = this.accelerationY * this.flipY;\r\n                    }\r\n                }\r\n            },\r\n            \r\n            \"hit-solid\": function (collisionInfo) {\r\n                if (this.stunned && (collisionInfo.y > 0)) {\r\n                    this.direction.x = 0;\r\n                    this.direction.y = 0;\r\n                    this.stunned = false;\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                this.vector.recycle();\r\n                this.state = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicImpactLaunch.js?");

/***/ }),

/***/ "./src/components/LogicPacingPlatform.js":
/*!***********************************************!*\
  !*** ./src/components/LogicPacingPlatform.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n# COMPONENT **LogicPacingPlatform**\r\nThis component changes the (x, y) position of an object according to its speed and heading and alternates back and forth. This is useful for in-place moving platforms.\r\n\r\n## Dependencies:\r\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.\r\n\r\n## Messages\r\n\r\n### Listens for:\r\n- **handle-logic** - On a `tick` logic message, the component updates its location according to its current state.\r\n  - @param message.delta - To determine how far to move the entity, the component checks the length of the tick.\r\n\r\n## JSON Definition:\r\n    {\r\n      \"type\": \"LogicDirectionalMovement\",\r\n      \r\n      \"angle\": 3.14,\r\n      // Optional. Defines the angle of movement in radians. Defaults to 0 (horizontal, starts moving right).\r\n      \r\n      \"distance\": 440,\r\n      // Optional. Declares distance in world units that the entity should move back and forth across. Defaults to 128.\r\n      \r\n      \"period\": 6000,\r\n      // Optional. Sets the time in milliseconds that the entity should take to make a complete movement cycle. Defaults to 4 seconds (4000).\r\n      \r\n      \"startPos\": 0\r\n      // Optional. Position in the cycle that the movement should begin. Defaults in the middle at 0; PI/2 and -PI/2 will put you at the extremes.\r\n    }\r\n*/\r\n/*global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'LogicPacingPlatform',\r\n        \r\n        initialize: function (definition) {\r\n            this.ang      = this.owner.angle      || definition.angle     || 0; //PI/2 makes it go down first\r\n            this.dist     = this.owner.distance || definition.distance || 128; //Distance in pixels\r\n            this.dX       = this.dist * Math.cos(this.ang);\r\n            this.dY       = this.dist * Math.sin(this.ang);\r\n            this.period   = this.owner.period    || definition.period     || 4000;\r\n            this.time     = 0;\r\n            this.startPos = this.owner.startPos || definition.startPos || 0; //PI/2 and -PI/2 will put you at the extremes\r\n            this.offset   = 0;\r\n            this.originX  = this.owner.x;\r\n            this.originY  = this.owner.y;\r\n        },\r\n\r\n        events: {// These are messages that this component listens for\r\n            \"handle-logic\": function (update) {\r\n                var period = this.period,\r\n                    delta = update.delta;\r\n                \r\n                this.time += delta;\r\n                if (this.time > period) {\r\n                    this.time = this.time % period;\r\n                }\r\n                this.offset = (this.time / period) * (2 * Math.PI);\r\n                \r\n                this.owner.x = this.originX + Math.sin(this.offset + this.startPos) * this.dX;\r\n                this.owner.y = this.originY + Math.sin(this.offset + this.startPos) * this.dY;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicPacingPlatform.js?");

/***/ }),

/***/ "./src/components/LogicPortable.js":
/*!*****************************************!*\
  !*** ./src/components/LogicPortable.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * This component allows this entity to be carried by other entities with which it collides. Entities that should carry this entity need to have a [[Logic-Carrier]] component attached.\r\n *\r\n * @namespace platypus.components\r\n * @class LogicPortable\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'LogicPortable',\r\n        properties: {\r\n            /**\r\n             * This is an object specifying the directions that this portable entity can be carried on. Default is {down:true}, but \"up\", \"down\", \"left\", and/or \"right\" can be specified as object properties set to `true`.\r\n             *\r\n             * @property portableDirections\r\n             * @type Object\r\n             * @default {\"down\": true}\r\n             */\r\n            portableDirections: {\r\n                down: true //default is false, 'true' means as soon as carrier is connected downward\r\n            }\r\n        },\r\n        initialize: function (definition) {\r\n            this.carrier = this.lastCarrier = null;\r\n            this.message = {\r\n                entity: this.owner\r\n            };\r\n        },\r\n        events: {\r\n            /**\r\n             * On receiving this message, this component triggers 'carry-me' or 'release-me' if its connection to a carrying entity has changed.\r\n             *\r\n             * @method 'handle-logic'\r\n             */\r\n            \"handle-logic\": function () {\r\n                var msg = this.message;\r\n                \r\n                if (this.carrierConnected) {\r\n                    if (this.carrier !== this.lastCarrier) {\r\n                        if (this.lastCarrier) {\r\n                            this.lastCarrier.triggerEvent('release-me', msg);\r\n                        }\r\n\r\n                        /**\r\n                         * This message is triggered on a potential carrying peer, notifying the peer that this entity is portable.\r\n                         *\r\n                         * @event 'carry-me'\r\n                         * @param message.entity {platypus.Entity} This entity, requesting to be carried.\r\n                         */\r\n                        this.carrier.triggerEvent('carry-me', msg);\r\n                    }\r\n                    \r\n                    this.carrierConnected = false;\r\n                } else if (this.carrier) {\r\n\r\n                    /**\r\n                     * This message is triggered on the current carrier, notifying them to release this entity.\r\n                     *\r\n                     * @event 'release-me'\r\n                     * @param message.entity {platypus.Entity} This entity, requesting to be released.\r\n                     */\r\n                    this.carrier.triggerEvent('release-me', msg);\r\n                    this.carrier = null;\r\n                }\r\n                this.lastCarrier = this.carrier;\r\n            },\r\n\r\n            /**\r\n             * On receiving this message, this component determines whether it is hitting its carrier or another entity. If it is hitting a new carrier, it will broadcast 'carry-me' on the next game step.\r\n             *\r\n             * @method 'hit-solid'\r\n             * @param collisionInfo.entity {platypus.Entity} The entity with which the collision occurred.\r\n             * @param collisionInfo.x {Number} -1, 0, or 1 indicating on which side of this entity the collision occurred: left, neither, or right respectively.\r\n             * @param collisionInfo.y {Number} -1, 0, or 1 indicating on which side of this entity the collision occurred: top, neither, or bottom respectively.\r\n             */\r\n            \"hit-solid\": function (collisionInfo) {\r\n                if (collisionInfo.y > 0) {\r\n                    this.updateCarrier(collisionInfo.entity, 'down');\r\n                } else if (collisionInfo.y < 0) {\r\n                    this.updateCarrier(collisionInfo.entity, 'up');\r\n                } else if (collisionInfo.x < 0) {\r\n                    this.updateCarrier(collisionInfo.entity, 'left');\r\n                } else if (collisionInfo.x > 0) {\r\n                    this.updateCarrier(collisionInfo.entity, 'right');\r\n                }\r\n            },\r\n\r\n            /**\r\n             * On receiving this message, this component immediately triggers 'release-me' on its owner's carrier.\r\n             *\r\n             * @method 'force-release'\r\n             * @since 0.11.2\r\n             */\r\n            \"force-release\": function () {\r\n                if (this.carrier) {\r\n                    this.carrier.triggerEvent('release-me', this.message);\r\n                }\r\n                this.carrier = null;\r\n                this.lastCarrier = this.carrier;\r\n                this.carrierConnected = false;\r\n            }\r\n        },\r\n        methods: {\r\n            updateCarrier: function (entity, direction) {\r\n                if (this.portableDirections[direction]) {\r\n                    if (entity) {\r\n                        if (entity !== this.carrier) {\r\n                            this.carrier = entity;\r\n                        }\r\n                        this.carrierConnected = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicPortable.js?");

/***/ }),

/***/ "./src/components/LogicPortal.js":
/*!***************************************!*\
  !*** ./src/components/LogicPortal.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DataMap.js */ \"./src/DataMap.js\");\n/**\r\n# COMPONENT **LogicPortal**\r\nA component which changes the scene when activated. When the portal receives an occupied message it sends the entity in that message notifying it. This message is meant to give the entity a chance to activate the portal in the manner it wants. The portal can also be activated by simply telling it to activate.\r\n\r\n## Dependencies\r\n- [[HandlerLogic]] (on entity's parent) - This component listens for a \"handle-logic\" message it then checks to see if it should change the scene if the portal is activated.\r\n- [[SceneChanger]] (on entity) - This component listens for the \"new-scene\" message that the LogicPortal sends and actually handles the scene changing.\r\n- [[CollisionBasic]] (on entity) - Not required, but if we want the 'occupied-portal' call to fire on collision you'll need to have a CollisionBasic component on the portal.\r\n\r\n## Messages\r\n\r\n### Listens for:\r\n- **handle-logic** - Checks to see if we should change scene if the portal is activated.\r\n- **occupied-portal** - This message takes an entity and then sends the entity a 'portal-waiting' message. The idea behind this was that you could use it with collision. When an entity gets in front of the portal the collision sends this message, we then tell the entity that collided to do whatever it needs and then it calls back to activate the portal.\r\n  - @param message.entity (entity Object) - The entity that will receive the 'portal-waiting' message.\r\n- **activate-portal** - This message turns the portal on. The next 'handle-logic' call will cause a change of scene.\r\n\r\n### Local Broadcasts:\r\n- **new-scene** - Calls the 'SceneChanger' component to tell it to change scenes.\r\n  - @param object.destination (string) - The id of the scene that we want to go to.\r\n\r\n### Peer Broadcasts:\r\n- **portal-waiting** - Informs another object that the portal is waiting on it to send the activate message.\r\n  - @param entity - This is the portal entity. To be used so that the object can communicate with it directly.\r\n\r\n## JSON Definition\r\n    {\r\n      \"type\": \"name-of-component\",\r\n      \"destination\" : \"level-2\"\r\n      //Required - The destination scene to which the portal will take us. In most cases this will come into the portal from Tiled where you'll set a property on the portal you place.\r\n    }\r\n*/\r\n/* global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        id: 'LogicPortal',\r\n        initialize: function (definition) {\r\n            var i = 0,\r\n                entrants = definition.entrants || definition.entrant || 'no one',\r\n                state = this.owner.state;\r\n             \r\n            this.destination = this.owner.destination || definition.destination;\r\n            this.used = false;\r\n            this.ready = false;\r\n            this.wasReady = false;\r\n\r\n            this.entrants = _DataMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\r\n            if (Array.isArray(entrants)) {\r\n                for (i = 0; i < entrants.length; i++) {\r\n                    this.entrants.set(entrants[i], false);\r\n                }\r\n            } else {\r\n                this.entrants.set(entrants, false);\r\n            }\r\n            \r\n            this.state = state;\r\n\r\n            state.set('occupied', false);\r\n            state.set('ready', true);\r\n        },\r\n        events: {\r\n            \"handle-logic\": function () {\r\n                var entrants = this.entrants,\r\n                    keys = entrants.keys,\r\n                    i = keys.length,\r\n                    occupied = false,\r\n                    ready = true,\r\n                    state = this.state;\r\n                \r\n                if (!this.used && this.activated) {\r\n                    this.owner.triggerEvent(\"port-\" + this.destination);\r\n                    this.used = true;\r\n                } else if (this.ready && !this.wasReady) {\r\n                    this.owner.triggerEvent('portal-waiting');\r\n                    this.wasReady = true;\r\n                } else if (this.wasReady && !this.ready) {\r\n                    this.owner.triggerEvent('portal-not-waiting');\r\n                    this.wasReady = false;\r\n                }\r\n                \r\n                \r\n                //Reset portal for next collision run.\r\n                while (i--) {\r\n                    if (entrants[keys[i]]) {\r\n                        occupied = true;\r\n                        entrants.set(keys[i], false);\r\n                    } else {\r\n                        ready = false;\r\n                    }\r\n                }\r\n                state.set('occupied', occupied);\r\n                state.set('ready', ready);\r\n                this.ready = false;\r\n            },\r\n            \"occupied-portal\": function (collision) {\r\n                var entrants = this.entrants,\r\n                    keys = entrants.keys,\r\n                    i = keys.length;\r\n                \r\n                entrants.set(collision.entity.type, true);\r\n                \r\n                while (i--) {\r\n                    if (!entrants.get(keys[i])) {\r\n                        return;\r\n                    }\r\n                }\r\n                \r\n                this.ready = true;\r\n            },\r\n            \"activate-portal\": function () {\r\n                this.activated = true;\r\n            }\r\n        },\r\n        methods: {\r\n            destroy: function () {\r\n                this.state = null;\r\n                this.entrants.recycle();\r\n                this.entrants = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicPortal.js?");

/***/ }),

/***/ "./src/components/LogicPushable.js":
/*!*****************************************!*\
  !*** ./src/components/LogicPushable.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n# COMPONENT **LogicPushable**\r\nA component that enables an entity to be pushed.\r\n\r\n## Dependencies\r\n- [[HandlerLogic]] (on entity's parent) - This component listens for a \"handle-logic\" message. It then moves the entity if it's being pushed.\r\n- [[CollisionBasic]] (on entity) - This component listens for messages from the CollisionBasic component. In particular 'hit-solid' and 'push-entity' are coming from collision.\r\n\r\n## Messages\r\n\r\n### Listens for:\r\n- **handle-logic** - Checks to see if we're being pushed. If so, we get pushed. Then resets values.\r\n  - @param resp.delta (number) - The time since the last tick.\r\n- **push-entity** - Received when we collide with an object that can push us. We resolve which side we're colliding on and set up the currentPushX and currentPushY values so we'll move on the handle-logic call.\r\n  - @param collisionInfo.x (number) - Either 1,0, or -1. 1 if we're colliding with an object on our right. -1 if on our left. 0 if not at all.\r\n  - @param collisionInfo.y (number) - Either 1,0, or -1. 1 if we're colliding with an object on our bottom. -1 if on our top. 0 if not at all.\r\n- **hit-solid** - Called when the entity collides with a solid object. Stops the object from being pushed further in that direction.\r\n  - @param collisionInfo.x (number) - Either 1,0, or -1. 1 if we're colliding with an object on our right. -1 if on our left. 0 if not at all.\r\n  - @param collisionInfo.y (number) - Either 1,0, or -1. 1 if we're colliding with an object on our bottom. -1 if on our top. 0 if not at all.\r\n\r\n## JSON Definition\r\n    {\r\n      \"type\": \"LogicPushable\",\r\n       \"xPush\" : .01,\r\n      //Optional - The distance per millisecond this object can be pushed in x. Defaults to .01.\r\n      \"yPush\" : .01,\r\n      //Optional - The distance per millisecond this object can be pushed in y. Defaults to .01.\r\n      \"push\" : .01\r\n      //Optional - The distance per millisecond this object can be pushed in x and y. Overwritten by the more specific values xPush and yPush. Defaults to .01.\r\n    }\r\n*/\r\n\r\n/* global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var setMagnitude = function (direction, magnitude) {\r\n        return (direction / Math.abs(direction)) * magnitude;\r\n    };\r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'LogicPushable',\r\n        initialize: function (definition) {\r\n            this.yPush = definition.push || definition.yPush || 0;\r\n            this.xPush = definition.push || definition.xPush || 0.1;\r\n            if (definition.roll) {\r\n                this.radius = definition.radius || this.owner.radius || ((this.owner.width || this.owner.height || 2) / 2);\r\n                this.owner.orientation = this.owner.orientation || 0;\r\n            } else {\r\n                this.radius = 0;\r\n            }\r\n            this.currentPushX = 0;\r\n            this.currentPushY = 0;\r\n            this.lastX = this.owner.x;\r\n            this.lastY = this.owner.y;\r\n            this.pushers = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n        },\r\n        events: {\r\n            \"handle-logic\": function (resp) {\r\n                var i = 0,\r\n                    delta = resp.delta;\r\n                \r\n                if (this.currentPushY) {\r\n                    this.owner.y += setMagnitude(this.currentPushY, this.yPush * delta);\r\n                    this.currentPushY = 0;\r\n                }\r\n                if (this.currentPushX) {\r\n                    this.owner.x += setMagnitude(this.currentPushX, this.xPush * delta);\r\n                    this.currentPushX = 0;\r\n                }\r\n                if ((this.lastX !== this.owner.x) || (this.lastY !== this.owner.y)) {\r\n                    if (this.radius) {\r\n                        this.owner.orientation += (this.owner.x + this.owner.y - this.lastX - this.lastY) / this.radius;\r\n                    }\r\n                    this.lastX = this.owner.x;\r\n                    this.lastY = this.owner.y;\r\n                }\r\n                for (i = 0; i < this.pushers.length; i++) {\r\n                    this.pushers[i].triggerEvent('pushed', this.owner);\r\n                }\r\n                this.pushers.length = 0;\r\n            },\r\n            \"push-entity\": function (collisionInfo) {\r\n                var x = (collisionInfo.x || 0),\r\n                    y = (collisionInfo.y || 0);\r\n                \r\n                this.currentPushX -= x;\r\n                this.currentPushY -= y;\r\n                if ((this.yPush && y) || (this.xPush && x)) {\r\n                    this.pushers.push(collisionInfo.entity);\r\n                }\r\n            },\r\n            \"hit-solid\": function (collisionInfo) {\r\n                if (((collisionInfo.y > 0) && (this.vY > 0)) || ((collisionInfo.y < 0) && (this.vY < 0))) {\r\n                    this.vY = 0;\r\n                } else if (((collisionInfo.x < 0) && (this.vX < 0)) || ((collisionInfo.x > 0) && (this.vX > 0))) {\r\n                    this.vX = 0;\r\n                }\r\n                return true;\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.pushers);\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicPushable.js?");

/***/ }),

/***/ "./src/components/LogicRebounder.js":
/*!******************************************!*\
  !*** ./src/components/LogicRebounder.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n# COMPONENT **LogicRebounder**\r\nThis component works with `CollisionBasic` to cause entities to bounce away on solid collisions.\r\n\r\n## Dependencies\r\n- [[CollisionBasic]] - Relies on collision messages to perform rebounding movement.\r\n\r\n## Messages\r\n\r\n### Listens for:\r\n- **handle-logic** - On receiving this message, `LogicRebounder` clears its stored collision information.\r\n- **hit-static** - On receiving this message, `LogicRebounder` rebounds.\r\n  - @param message.direction (2d vector) - This is the direction in which the collision occurred, tangental to the impact interface.\r\n- **hit-non-static** - On receiving this message, `LogicRebounder` rebounds.\r\n  - @param message.direction (2d vector) - This is the direction in which the collision occurred, tangental to the impact interface.\r\n  - @param message.entity ([[entity]]) - This is the entity with which this entity is colliding.\r\n- **share-velocity** - On receiving this message, `LogicRebounder` stores collision information.\r\n  - @param entity ([[entity]]) - This is the entity with which this entity is colliding.\r\n\r\n### Peer Broadcasts:\r\n- **share-velocity** - This component triggers this message to prevent double collision calls.\r\n  - @param entity ([[entity]]) - This entity.\r\n\r\n## JSON Definition\r\n    {\r\n      \"type\": \"LogicRebounder\",\r\n      \r\n      \"mass\": 12,\r\n      // Optional. Relative size of the entity. Defaults to 1.\r\n      \r\n      \"elasticity\": 0.4\r\n      // Optional. Bounciness of the entity. Defaults to 0.8.\r\n    }\r\n*/\r\n/* global platypus */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        id: 'LogicRebounder',\r\n        \r\n        initialize: function (definition) {\r\n            _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].assign(this.owner, 'velocity', 'dx', 'dy', 'dz');\r\n\r\n            this.owner.mass = this.owner.mass || definition.mass || 1;\r\n            this.elasticity = definition.elasticity || 0.8;\r\n            \r\n            this.v = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(0, 0, 0);\r\n            this.incidentVector = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(0, 0, 0);\r\n            \r\n            this.staticCollisionOccurred = false;\r\n            this.nonStaticCollisionOccurred = false;\r\n            \r\n            this.hitThisTick = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n            this.otherV = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(0, 0, 0);\r\n            this.otherVelocityData = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n        },\r\n\r\n        events: {// These are messages that this component listens for\r\n            \"handle-logic\": function () {\r\n                var i = 0;\r\n                \r\n                this.hitThisTick.length = 0;\r\n                for (i = 0; i < this.otherVelocityData.length; i++) {\r\n                    this.otherVelocityData[i].velocity.recycle();\r\n                }\r\n                this.otherVelocityData.length = 0;\r\n            },\r\n            \"hit-static\": function (collData) {\r\n                var magnitude = 0,\r\n                    other = collData.entity,\r\n                    x = 0;\r\n\r\n                for (x = 0; x < this.hitThisTick.length; x++) {\r\n                    if (other === this.hitThisTick[x]) {\r\n                        return;\r\n                    }\r\n                }\r\n                this.hitThisTick.push(other);\r\n                \r\n                this.v.setVector(this.owner.velocity);\r\n                this.incidentVector.setVector(collData.direction);\r\n                \r\n                magnitude = this.v.scalarProjection(this.incidentVector);\r\n                if (!isNaN(magnitude)) {\r\n                    this.incidentVector.scale(magnitude * (1 + this.elasticity));\r\n                    this.v.subtractVector(this.incidentVector);\r\n                }\r\n                \r\n                this.owner.velocity.setVector(this.v);\r\n            },\r\n            \"hit-non-static\": function (collData) {\r\n                var x = 0,\r\n                    other          = collData.entity,\r\n                    otherVSet      = false,\r\n                    relevantV      = 0,\r\n                    otherRelevantV = 0,\r\n                    reboundV       = 0;\r\n                \r\n                x = this.hitThisTick.indexOf(other);\r\n                if (x >= 0) {\r\n                    return;\r\n                }\r\n                this.hitThisTick.push(other);\r\n                \r\n                for (x = 0; x < this.otherVelocityData.length; x++) {\r\n                    if (other === this.otherVelocityData[x].entity) {\r\n                        this.otherV.setVector(this.otherVelocityData[x].velocity);\r\n                        otherVSet = true;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                if (!otherVSet) {\r\n                    this.otherV.setVector(other.velocity);\r\n                    other.triggerEvent('share-velocity', this.owner);\r\n                }\r\n                \r\n                this.v.setVector(this.owner.velocity);\r\n                this.incidentVector.setVector(collData.direction);\r\n                \r\n                \r\n                relevantV = this.v.scalarProjection(this.incidentVector);\r\n                relevantV = (isNaN(relevantV)) ? 0 : relevantV;\r\n                otherRelevantV = this.otherV.scalarProjection(this.incidentVector);\r\n                otherRelevantV = (isNaN(otherRelevantV)) ? 0 : otherRelevantV;\r\n                \r\n                reboundV = (relevantV * (this.owner.mass - other.mass) + 2 * other.mass * otherRelevantV) / (this.owner.mass + other.mass);\r\n                \r\n                this.incidentVector.scale(reboundV - relevantV);\r\n                \r\n                this.owner.velocity.setVector(this.incidentVector);\r\n                \r\n            },\r\n            \"share-velocity\": function (other) {\r\n                this.otherVelocityData.push({\r\n                    entity: other,\r\n                    velocity: _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(other.velocity)\r\n                });\r\n            }\r\n        },\r\n        \r\n        methods: {// These are methods that are called by this component.\r\n            destroy: function () {\r\n                this.v.recycle();\r\n                this.incidentVector.recycle();\r\n                this.otherV.recycle();\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.hitThisTick);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.otherVelocityData);\r\n            }\r\n        },\r\n        \r\n        publicMethods: {// These are methods that are available on the entity.\r\n\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicRebounder.js?");

/***/ }),

/***/ "./src/components/LogicRegionSpawner.js":
/*!**********************************************!*\
  !*** ./src/components/LogicRegionSpawner.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n# COMPONENT **LogicRegionSpawner**\r\nThis component spawns new entities within a given area at set intervals.\r\n\r\n## Dependencies\r\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to determine whether to spawn another entity.\r\n\r\n## Messages\r\n\r\n### Listens for:\r\n- **handle-logic** - On a `tick` logic message, the component determines whether to spawn another entity.\r\n  - @param message.delta - To determine whether to spawn, the component keeps a running count of tick lengths.\r\n\r\n## JSON Definition\r\n    {\r\n      \"type\": \"LogicRegionSpawner\",\r\n      // List all additional parameters and their possible values here.\r\n      \r\n      \"spawn\": \"teddy-bear\",\r\n      // Required. String identifying the type of entity to spawn.\r\n      \r\n      \"interval\": 30000,\r\n      // Optional. Time in milliseconds between spawning an entity. Defaults to 1000.\r\n      \r\n      \"regions\": {\r\n      // If spawning entity covers a large area, the spawned entities can be randomly spawned over a regional grid, so that the whole area gets a somewhat uniform coverage of spawned entities\r\n\r\n        \"width\": 4000,\r\n        \"height\": 5000,\r\n        // Optional. Dimensions of a spawning region in world units. Defaults to entity's dimensions. The entity's dimensions are sliced into chunks of this size for spawn distribution.\r\n      }\r\n    }\r\n*/\r\n/* global platypus */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'LogicRegionSpawner',\r\n        \r\n        initialize: function (definition) {\r\n            var x       = 0,\r\n                y       = 0,\r\n                columns = 1,\r\n                rows    = 1,\r\n                width   = 0,\r\n                height  = 0,\r\n                rw      = 0,\r\n                rh      = 0;\r\n            \r\n            this.spawnPosition = {\r\n                x: 0,\r\n                y: 0\r\n            };\r\n            this.spawnProperties = {\r\n                type: definition.spawn,\r\n                properties: this.spawnPosition\r\n            };\r\n            \r\n            this.regions = null;\r\n            this.usedRegions = null;\r\n            this.regionWidth = 0;\r\n            this.regionHeight = 0;\r\n            if (definition.regions) {\r\n                this.regions = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n                this.usedRegions = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n                this.regionWidth  = width  = definition.regions.width  || this.owner.width;\r\n                this.regionHeight = height = definition.regions.height || this.owner.height;\r\n                columns = Math.round(this.owner.width  / width);\r\n                rows    = Math.round(this.owner.height / height);\r\n                for (x = 0; x < columns; x++) {\r\n                    for (y = 0; y < rows; y++) {\r\n                        rw = Math.min(width,  this.owner.width  - x * width);\r\n                        rh = Math.min(height, this.owner.height - y * height);\r\n                        this.regions.push({\r\n                            x: x * width,\r\n                            y: y * height,\r\n                            width: rw,\r\n                            height: rh\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            \r\n            this.interval = this.owner.interval || definition.interval || 1000;\r\n            this.time = 0;\r\n        },\r\n\r\n        events: {// These are messages that this component listens for\r\n            \"handle-logic\": function (resp) {\r\n                var regions = this.regions,\r\n                    region  = null;\r\n                \r\n                this.time += resp.delta;\r\n                \r\n                if (this.time > this.interval) {\r\n                    this.time -= this.interval;\r\n                    \r\n                    if (regions) {\r\n                        if (!regions.length) {\r\n                            this.regions = this.usedRegions;\r\n                            this.usedRegions = regions;\r\n                            regions = this.regions;\r\n                        }\r\n                        \r\n                        region = regions[Math.floor(regions.length * Math.random())];\r\n                        \r\n                        this.spawnPosition.x = this.owner.x - (this.owner.regX || 0) + (region.x + (Math.random() * region.width));\r\n                        this.spawnPosition.y = this.owner.y - (this.owner.regY || 0) + (region.y + (Math.random() * region.height));\r\n                    } else {\r\n                        this.spawnPosition.x = this.owner.x - (this.owner.regX || 0) + (Math.random() * this.owner.width);\r\n                        this.spawnPosition.y = this.owner.y - (this.owner.regY || 0) + (Math.random() * this.owner.height);\r\n                    }\r\n\r\n                    this.owner.parent.addEntity(this.spawnProperties);\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                if (this.regions) {\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.regions);\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.usedRegions);\r\n                }\r\n            }\r\n        },\r\n        \r\n        getAssetList: function (def, props, defaultProps) {\r\n            var spawn = def.spawn || props.spawn || defaultProps.spawn;\r\n            \r\n            if (spawn) {\r\n                return _Entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getAssetList({\r\n                    type: spawn\r\n                });\r\n            }\r\n            \r\n            return _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicRegionSpawner.js?");

/***/ }),

/***/ "./src/components/LogicRotationalMovement.js":
/*!***************************************************!*\
  !*** ./src/components/LogicRotationalMovement.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * This component changes the (x, y) position of an object according to its current speed and heading. It maintains its own heading information independent of other components allowing it to be used simultaneously with other logic components like [[Logic-Pushable]]. It accepts directional messages that can stand alone, or come from a mapped controller, in which case it checks the `pressed` value of the message before changing its course accordingly.\r\n *\r\n * @namespace platypus.components\r\n * @class LogicRotationalMovement\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n\r\n    var cos = Math.cos,\r\n        sin = Math.sin,\r\n        polarToCartesianX = function (m, a) {\r\n            return m * cos(a);\r\n        },\r\n        polarToCartesianY = function (m, a) {\r\n            return m * sin(a);\r\n        };\r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'LogicRotationalMovement',\r\n\r\n        properties: {\r\n            /**\r\n             * Defines the distance in world units that the entity should be moved per millisecond.\r\n             *\r\n             * @property speed\r\n             * @type Number\r\n             * @default 0.3\r\n             */\r\n            \"speed\": 0.3,\r\n            \r\n            /**\r\n             * Radian orientation that entity should begin in. Defaults to 0 (facing right).\r\n             *\r\n             * @property angle\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            \"angle\": 0,\r\n            \r\n            /**\r\n             * Unit in radians that the angle should change per millisecond.\r\n             *\r\n             * @property degree\r\n             * @type Number\r\n             * @default 1\r\n             */\r\n            \"degree\": 1\r\n        },\r\n\r\n        initialize: function () {\r\n            var state = this.owner.state;\r\n            \r\n            this.magnitude = 0;\r\n            \r\n            this.state = state;\r\n            state.set('moving', false);\r\n            state.set('turningRight', false);\r\n            state.set('turningLeft', false);\r\n    \r\n            this.owner.orientation  = 0;\r\n            \r\n            this.moving = false;\r\n            this.turningRight = false;\r\n            this.turningLeft = false;\r\n        },\r\n        events: {\r\n            /**\r\n             * On receiving this event, the component updates its location according to its current state.\r\n             *\r\n             * @method 'handle-logic'\r\n             * @param tick.delta {Number} To determine how far to move the entity, the component checks the length of the tick.\r\n             */\r\n            \"handle-logic\": function (tick) {\r\n                var state = this.state;\r\n                \r\n                if (this.turningRight) {\r\n                    this.angle += this.degree * tick.delta / 15;\r\n                }\r\n        \r\n                if (this.turningLeft) {\r\n                    this.angle -= this.degree * tick.delta / 15;\r\n                }\r\n                \r\n                if (this.moving) {\r\n                    this.owner.x += (polarToCartesianX(this.magnitude, this.angle) * tick.delta);\r\n                    this.owner.y += (polarToCartesianY(this.magnitude, this.angle) * tick.delta);\r\n                }\r\n                \r\n                state.set('moving', this.moving);\r\n                state.set('turningLeft', this.turningLeft);\r\n                state.set('turningRight', this.turningRight);\r\n                \r\n                if (this.owner.orientation !== this.angle * Math.PI / 180) {\r\n                    this.owner.orientation = this.angle * Math.PI / 180;\r\n                    this.owner.triggerEvent('orientation-updated');\r\n                }\r\n            },\r\n\r\n            /**\r\n             * This rotates the entity by a delta in radians.\r\n             *\r\n             * @method 'rotate'\r\n             * @param angleDelta {Number} The change in angle.\r\n             */\r\n            \"rotate\": function (angleDelta) {\r\n                this.angle += angleDelta;\r\n            },\r\n\r\n            /**\r\n             * On receiving this event, the entity turns right.\r\n             *\r\n             * @method 'turn-right'\r\n             * @param [state.pressed] {boolean} If `state` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new orientation.\r\n             */\r\n            \"turn-right\": function (state) {\r\n                if (state) {\r\n                    this.turningRight = state.pressed;\r\n                } else {\r\n                    this.turningRight = true;\r\n                }\r\n            },\r\n\r\n            /**\r\n             * On receiving this event, the entity turns left.\r\n             *\r\n             * @method 'turn-left'\r\n             * @param [state.pressed] {boolean} If `state` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new orientation.\r\n             */\r\n            \"turn-left\": function (state) {\r\n                if (state) {\r\n                    this.turningLeft = state.pressed;\r\n                } else {\r\n                    this.turningLeft = true;\r\n                }\r\n            },\r\n\r\n            /**\r\n             * On receiving this event, the entity goes forward.\r\n             *\r\n             * @method 'go-forward'\r\n             * @param [state.pressed] {boolean} If `state` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new orientation.\r\n             */\r\n            \"go-forward\": function (state) {\r\n                if (!state || state.pressed) {\r\n                    this.moving = true;\r\n                    this.magnitude = this.speed;\r\n                } else {\r\n                    this.moving = false;\r\n                }\r\n            },\r\n\r\n            /**\r\n             * On receiving this event, the entity goes backward.\r\n             *\r\n             * @method 'go-backward'\r\n             * @param [state.pressed] {boolean} If `state` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new orientation.\r\n             */\r\n            \"go-backward\": function (state) {\r\n                if (!state || state.pressed) {\r\n                    this.moving = true;\r\n                    this.magnitude = -this.speed;\r\n                } else {\r\n                    this.moving = false;\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Stops rotational and linear motion until movement messages are again received.\r\n             *\r\n             * @method 'stop'\r\n             * @param [state.pressed] {Boolean} If `state` is included, the component checks the value of `pressed`: a value of false will not stop the entity.\r\n             */\r\n            \"stop\": function (state) {\r\n                if (!state || state.pressed) {\r\n                    this.moving = false;\r\n                    this.turningLeft = false;\r\n                    this.turningRight = false;\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Stops linear motion until movement messages are again received.\r\n             *\r\n             * @method 'stop-moving'\r\n             * @param [state.pressed] {Boolean} If `state` is included, the component checks the value of `pressed`: a value of false will not stop the entity.\r\n             */\r\n            \"stop-moving\": function (state) {\r\n                if (!state || state.pressed) {\r\n                    this.moving = false;\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Stops rotational motion until movement messages are again received.\r\n             *\r\n             * @method 'stop-turning'\r\n             * @param [state.pressed] {Boolean} If `state` is included, the component checks the value of `pressed`: a value of false will not stop the entity.\r\n             */\r\n            \"stop-turning\": function (state) {\r\n                if (!state || state.pressed) {\r\n                    this.turningLeft = false;\r\n                    this.turningRight = false;\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                this.state = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicRotationalMovement.js?");

/***/ }),

/***/ "./src/components/LogicSpawner.js":
/*!****************************************!*\
  !*** ./src/components/LogicSpawner.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n# COMPONENT **LogicSpawner**\r\nThis component creates an entity and propels it away. This is useful for casting, firing, tossing, and related behaviors.\r\n\r\n## Dependencies:\r\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to determine whether it should be spawning or not.\r\n\r\n## Messages\r\n\r\n### Listens for:\r\n- **handle-logic** - On a `tick` logic message, the component checks its current state to decide whether to spawn entities.\r\n- **spawn** - creates an entity on the following tick message.\r\n  - @param message.pressed (boolean) - Optional. If `message` is included, the component checks the value of `pressed`: false results in no entities being created. Is this primarily for controller input.\r\n\r\n## JSON Definition\r\n    {\r\n      \"type\": \"LogicSpawner\"\r\n      // List all additional parameters and their possible values here.\r\n\r\n      \"spawneeClass\": \"wet-noodle\",\r\n      // Required: string identifying the type of entity to create.\r\n      \r\n      \"state\": \"tossing\",\r\n      // Optional. The entity state that should be true while entities are being created. Defaults to \"firing\".\r\n      \r\n      \"speed\": 4,\r\n      // Optional. The velocity with which the entity should start. Initial direction is determined by this entity's facing states (\"top\", \"right\", etc).\r\n      \r\n      \"offsetX\": 45,\r\n      \"offsetY\": -20,\r\n      // Optional. Location relative to the entity where the should be located once created. Defaults to (0, 0).\r\n    }\r\n*/\r\n/*global platypus */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'LogicSpawner',\r\n        \r\n        initialize: function (definition) {\r\n            var className = this.owner.spawneeClass || definition.spawneeClass,\r\n                prop = '',\r\n                x = 0;\r\n\r\n            this.state = this.owner.state;\r\n            this.stateName = definition.state || 'spawning';\r\n            this.originalZ = (platypus.game.settings.entities[className] && platypus.game.settings.entities[className].properties && platypus.game.settings.entities[className].properties.z) || 0;\r\n            this.speed = definition.speed || this.owner.speed || 0;\r\n\r\n            this.state.set(this.stateName, false);\r\n            \r\n            this.spawneeProperties = {\r\n                x: 0,\r\n                y: 0,\r\n                z: 0,\r\n                dx: 0,\r\n                dy: 0,\r\n                spawner: this.owner\r\n            };\r\n            \r\n            if (definition.passOnProperties) {\r\n                for (x = 0; x < definition.passOnProperties.length; x++) {\r\n                    prop = definition.passOnProperties[x];\r\n                    if (this.owner[prop]) {\r\n                        this.spawneeProperties[prop] = this.owner[prop];\r\n                    }\r\n                }\r\n            }\r\n            \r\n            \r\n            this.propertiesContainer = {\r\n                type: className,\r\n                properties: this.spawneeProperties\r\n            };\r\n            \r\n            this.offsetX = this.owner.offsetX || definition.offsetX || 0;\r\n            this.offsetY = this.owner.offsetY || definition.offsetY || 0;\r\n            \r\n            this.firing = false;\r\n        },\r\n\r\n        events: {// These are messages that this component listens for\r\n            \"handle-logic\": function () {\r\n                var offset = 0,\r\n                    state  = this.state;\r\n                \r\n                if (this.firing) {\r\n                    this.spawneeProperties.x = this.owner.x;\r\n                    this.spawneeProperties.y = this.owner.y;\r\n                    this.spawneeProperties.z = this.owner.z + this.originalZ;\r\n                    \r\n                    offset = this.offsetX;\r\n                    if (state.get('left')) {\r\n                        offset *= -1;\r\n                    }\r\n                    this.spawneeProperties.x += offset;\r\n                    \r\n                    offset = this.offsetY;\r\n                    if (state.get('top')) {\r\n                        offset *= -1;\r\n                    }\r\n                    this.spawneeProperties.y += offset;\r\n                    \r\n                    if (this.speed) {\r\n                        if (state.get('top')) {\r\n                            this.spawneeProperties.dy = -this.speed;\r\n                        } else if (state.get('bottom')) {\r\n                            this.spawneeProperties.dy = this.speed;\r\n                        } else {\r\n                            delete this.spawneeProperties.dy;\r\n                        }\r\n                        if (state.get('left')) {\r\n                            this.spawneeProperties.dx = -this.speed;\r\n                        } else if (state.get('right')) {\r\n                            this.spawneeProperties.dx = this.speed;\r\n                        } else {\r\n                            delete this.spawneeProperties.dx;\r\n                        }\r\n                    } else {\r\n                        delete this.spawneeProperties.dx;\r\n                        delete this.spawneeProperties.dy;\r\n                    }\r\n                    \r\n                    this.parent.addEntity(this.propertiesContainer);\r\n                }\r\n                \r\n                state.set(this.stateName, this.firing);\r\n\r\n                this.firing = false;\r\n            },\r\n            \"spawn\": function (value) {\r\n                this.firing = !value || (value.pressed !== false);\r\n                \r\n                this.parent = this.owner.parent; //proofing against this entity being destroyed prior to spawned entity. For example, when a destroyed entity spawns a drop.\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                this.state = null;\r\n            }\r\n        },\r\n        \r\n        getAssetList: function (def, props, defaultProps) {\r\n            var spawn = def.spawneeClass || props.spawneeClass || defaultProps.spawneeClass;\r\n            \r\n            if (spawn) {\r\n                return _Entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getAssetList({\r\n                    type: spawn\r\n                });\r\n            }\r\n            \r\n            return _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicSpawner.js?");

/***/ }),

/***/ "./src/components/LogicStateMachine.js":
/*!*********************************************!*\
  !*** ./src/components/LogicStateMachine.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../StateMap.js */ \"./src/StateMap.js\");\n/**\r\n# COMPONENT **LogicStateMachine**\r\nThis component is a general purpose state-machine for an entity, taking in various message inputs to determine the entity's state and triggering messages as necessary when a certain state occurs or several state combinations are in place.\r\n\r\n## Dependencies:\r\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.\r\n\r\n## Messages\r\n\r\n### Listens for:\r\n- **handle-logic** - On a `tick` logic message, the component checks sustained inputs for changes in state.\r\n- **update-state** - Updates the entity's state according to this message's state information.\r\n  - @param message (object) - This is an object of key/value pairs where keys are states and the values are booleans to turn on and off states.\r\n- **state-changed** - Updates the entity's state according to this message's state information, and broadcasts any applicable messages.\r\n  - @param message (object) - This is an object of key/value pairs where keys are states and the values are booleans to turn on and off states.\r\n- **[input messages]** - This component listens for messages as determined by the JSON settings.\r\n\r\n### Local Broadcasts:\r\n- **[output messages]** - This component triggers output messages as determined by the JSON settings.\r\n\r\n## JSON Definition\r\n    {\r\n      \"type\": \"LogicStateMachine\",\r\n      \r\n      \"inputs\":{\r\n      // This is a list of messages that this component should listen for to change states.\r\n      \r\n        \"smell-toast\":{\r\n        // If the entity triggers \"smell-toast\", this component will change the state of the entity as follows:\r\n        \r\n          \"smelling-food\": true,\r\n          \"smelling-nothing\": false\r\n        },\r\n        \r\n        \"go-to-store\":{\r\n          \"at-store\": true\r\n        }\r\n      },\r\n      \r\n      \"sustained-inputs\":{\r\n      // These are messages that must be triggered every tick for the state to remain true: if not, they become false.\r\n        \"near-grover\": \"smelling-trash\"\r\n      }\r\n    }\r\n*/\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var changeState = function (changes, state) {\r\n            state.update(changes);\r\n        },\r\n        changeSustainedState = function (change, state) {\r\n            state.set(change, true);\r\n        },\r\n        handleResult = null,\r\n        handleOutput = null,\r\n        setUpOutputs = function (outs) {\r\n            var data = null,\r\n                key = '';\r\n            \r\n            if (!outs || (typeof outs !== 'object') || Array.isArray(outs) || outs.event) {\r\n                return outs;\r\n            } else {\r\n                data = _DataMap_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\r\n                for (key in outs) {\r\n                    if (outs.hasOwnProperty(key)) {\r\n                        data.set(key, setUpOutputs(outs[key]));\r\n                    }\r\n                }\r\n                return data;\r\n            }\r\n        },\r\n        recycleOutputs = function (outs) {\r\n            var keys = outs.keys,\r\n                i = keys.length;\r\n\r\n            if (outs instanceof _DataMap_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\r\n                while (i--) {\r\n                    recycleOutputs(outs[keys[i]]);\r\n                }\r\n                outs.recycle();\r\n            }\r\n        };\r\n    \r\n    handleResult = function (title, state, last, checks, changed, self, queue) {\r\n        var i = 0,\r\n            key = '',\r\n            keys = null,\r\n            message = checks.message || (checks.message === 0) || (checks.message === false),\r\n            value = null;\r\n\r\n        if (changed) {\r\n            if (typeof checks === 'string') {\r\n                self.triggerEvent(checks);\r\n                return;\r\n            } else if (Array.isArray(checks)) {\r\n                for (i = 0; i < checks.length; i++) {\r\n                    handleResult(title, state, last, checks[i], changed, self, queue);\r\n                }\r\n                return;\r\n            } else if (checks.event && (message || checks.delay)) {\r\n                if (checks.delay) {\r\n                    queue.push(checks);\r\n                } else {\r\n                    self.trigger(checks.event, checks.message);\r\n                }\r\n                return;\r\n            } else if (checks.get) {\r\n                value = checks.get('true');\r\n                if (value) {\r\n                    handleResult(title, state, last, value, changed, self, queue);\r\n                }\r\n            }\r\n        }\r\n\r\n        keys = checks.keys;\r\n        if (keys) {\r\n            i = keys.length;\r\n            while (i--) {\r\n                key = keys[i];\r\n                if (key !== 'true') {\r\n                    handleOutput(key, state, last, checks.get(key), changed, self, queue);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    \r\n    handleOutput = function (title, state, last, checks, changed, self, queue) {\r\n        var c     = changed,\r\n            value = false,\r\n            st = \"\",\r\n            stateValue = false;\r\n\r\n        if (title.charAt(0) === '!') {\r\n            st = title.substring(1);\r\n            stateValue = state.get(st);\r\n            value = (stateValue === false);\r\n            if ((title !== 'outputs') && (last.get(st) !== stateValue)) {\r\n                c = true;\r\n            }\r\n        } else {\r\n            stateValue = state.get(title);\r\n            value = (stateValue === true);\r\n            if ((title !== 'outputs') && (last.get(title) !== stateValue)) {\r\n                c = true;\r\n            }\r\n        }\r\n\r\n        if (value || (title === 'outputs')) {\r\n            handleResult(title, state, last, checks, c, self, queue);\r\n        }\r\n    };\r\n\r\n    return platypus.createComponentClass({\r\n        id: 'LogicStateMachine',\r\n        \r\n        properties: {\r\n            /**\r\n             * This is the list of events containing key/value pairs that describe state changes to make for the given event.\r\n             *\r\n             *     {\r\n             *         \"smell-toast\": {\r\n             *             \"smelling-food\": true,\r\n             *             \"smelling-nothing\": false\r\n             *         },\r\n             *         \"go-to-store\": {\r\n             *             \"at-store\": true\r\n             *         }\r\n             *     }\r\n             *\r\n             * @property inputs\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            inputs: null,\r\n            \r\n            /**\r\n             * These are messages that should be triggered when certain conditions are met. The messages are only triggered the instant the condition is met, until the conditions are no longer met and then once again met. Example:\r\n             *\r\n             *     {\r\n             *         \"smelling-food\": { // Keys map to states, and if true, the value of the key is processed. In this case, the value of the \"smelling-food\" key is another object of key/value pairs, giving us another layer of checks.\r\n             *             \"!smelling-trash\": \"time-to-eat\", // This key is an inverse check, meaning that the \"smelling-trash\" state of the entity must be false to continue along this path. This time the value is a string, so the string \"time-to-eat\" is treated as a message to be broadcast if the entity is both \"smelling-food\" and not \"smelling-trash\".\r\n             *             \"true\": \"belly-rumble\" // In some cases, a message should be triggered for a set of states, while still doing deeper state checks like above. \"true\" will always handle the next layer of values if the parent key was true.\r\n             *         },\r\n             *         \"smelling-trash\": \"feeling-sick\" // Multiple states can be handled to multiple depths, like a list of if () statements\r\n             *         \"!smelling-nothing\": {\r\n             *             \"!smelling-trash\":{\r\n             *                 \"!at-store\": \"go-to-store\", // Note that the \"go-to-store\" message will change this entity's state to \"at-store\" according to \"inputs\" above, but LogicStateMachine uses a cache of states when broadcasting output messages, so the next section will not be processed until the next state check.\r\n             *                 \"at-store\":{\r\n             *                     \"have-money\": \"buy-more-food\",\r\n             *                     \"!have-money\": \"buy-less-food\"\r\n             *                 }\r\n             *             }\r\n             *         }\r\n             *     }\r\n             *\r\n             * @property outputs\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            outputs: null\r\n        },\r\n        \r\n        initialize: function (definition) {\r\n            var i = 0,\r\n                inputDefinition = this.inputs,\r\n                key = '',\r\n                keys = null,\r\n                state = null,\r\n                stateObjects = null,\r\n                susDef = definition[\"sustained-inputs\"],\r\n                thisState = this.owner.state;\r\n            \r\n            this.state = thisState;\r\n            \r\n            if (inputDefinition) {\r\n                stateObjects = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                for (key in inputDefinition) {\r\n                    if (inputDefinition.hasOwnProperty(key)) {\r\n                        state = _StateMap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(inputDefinition[key]);\r\n                        stateObjects.push(state);\r\n                        this.addEventListener(key, changeState.bind(this, state, thisState));\r\n                        keys = state.keys;\r\n                        i = keys.length;\r\n                        while (i--) {\r\n                            thisState.set(keys[i], false);\r\n                        }\r\n                    }\r\n                }\r\n                this.stateObjects = stateObjects;\r\n            }\r\n\r\n            this.sustainedState = _StateMap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp();\r\n            if (susDef) {\r\n                for (key in susDef) {\r\n                    if (susDef.hasOwnProperty(key)) {\r\n                        this.addEventListener(key, changeSustainedState.bind(this, susDef[key], this.sustainedState));\r\n                        this.sustainedState.set(susDef[key], false);\r\n                        thisState.set(susDef[key], false);\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.snapshot = _StateMap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp();\r\n            this.last = _StateMap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp();\r\n            this.queueTimes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.queue = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.outputs = setUpOutputs(this.outputs);\r\n        },\r\n\r\n        events: {\r\n            \"handle-logic\": function (resp) {\r\n                var susState = this.sustainedState,\r\n                    key = '',\r\n                    keys = susState.keys,\r\n                    i = keys.length,\r\n                    state = this.state;\r\n                \r\n                while (i--) {\r\n                    key = keys[i];\r\n                    state.set(key, susState.get(key));\r\n                    susState.set(key, false);\r\n                }\r\n                \r\n                i = this.queue.length;\r\n                while (i--) {\r\n                    this.queueTimes[i] -= resp.delta;\r\n                    \r\n                    if (this.queueTimes[i] <= 0) {\r\n                        this.owner.trigger(this.queue[i].event, this.queue[i].message);\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.queueTimes, i);\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.queue, i);\r\n                    }\r\n                }\r\n            },\r\n            \r\n            \"update-state\": function (state) {\r\n                this.state.update(state);\r\n            },\r\n            \r\n            \"state-changed\": function (state) {\r\n                var i = 0,\r\n                    queue = null,\r\n                    ss = this.snapshot;\r\n                \r\n                if (this.outputs) {\r\n                    ss.update(state);\r\n                    \r\n                    queue = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                    handleOutput('outputs', ss, this.last, this.outputs, false, this.owner, queue);\r\n                    i = queue.length;\r\n                    while (i--) {\r\n                        this.queue.push(queue[i]);\r\n                        this.queueTimes.push(queue[i].delay);\r\n                    }\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(queue);\r\n                    \r\n                    this.last.update(ss);\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                var i = 0,\r\n                    so = this.stateObjects;\r\n                \r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.queueTimes);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.queue);\r\n                \r\n                if (so) {\r\n                    i = so.length;\r\n                    while (i--) {\r\n                        so[i].recycle();\r\n                    }\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(so);\r\n                    this.stateObjects = null;\r\n                }\r\n\r\n                this.sustainedState.recycle();\r\n                this.snapshot.recycle();\r\n                this.last.recycle();\r\n                \r\n                this.state = null;\r\n                this.inputs = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicStateMachine.js?");

/***/ }),

/***/ "./src/components/LogicSwitch.js":
/*!***************************************!*\
  !*** ./src/components/LogicSwitch.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n# COMPONENT **LogicSwitch**\r\nThis component serves as a switch in the game world, typically tied to collision events such that this entity changes state when another entity collides or passed over.\r\n\r\n## Dependencies:\r\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its state.\r\n\r\n## Messages\r\n\r\n### Listens for:\r\n- **handle-logic** - On a `tick` logic message, the component determines its state and triggers messages accordingly.\r\n- **switch-pressed** - Causes the switch to be in a pressed state.\r\n\r\n### Local Broadcasts:\r\n- **switch-on** - This message is triggered when the switch has just been pressed.\r\n- **switch-off** - This message is triggered when the switch has just been released.\r\n- **initial-press** - This message is triggered the first time the switch is pressed. This occurs before the \"switch-on\" message is triggered.\r\n\r\n## JSON Definition:\r\n    {\r\n      \"type\": \"LogicSwitch\",\r\n      \r\n      \"sticky\": true\r\n      // Optional. Whether a pressed switch should stay pressed once collision messages cease. Defaults to `false`.\r\n    }\r\n*/\r\n/*global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'LogicSwitch',\r\n        \r\n        initialize: function (definition) {\r\n            this.state = this.owner.state;\r\n            this.pressed = false;\r\n            this.wasPressed = this.pressed;\r\n            this.sticky = definition.sticky || false;\r\n            this.state.set('pressed', false);\r\n            this.initialPress = true;\r\n        },\r\n\r\n        events: {// These are messages that this component listens for\r\n            \"handle-logic\": function () {\r\n                if (this.sticky) {\r\n                    if (this.pressed && !this.wasPressed) {\r\n                        this.state.set('pressed', true);\r\n                        this.wasPressed = true;\r\n                        this.owner.triggerEvent('switch-on');\r\n                    }\r\n                } else {\r\n                    if (this.pressed !== this.wasPressed) {\r\n                        if (this.pressed) {\r\n                            this.state.set('pressed', true);\r\n                            this.owner.triggerEvent('switch-on');\r\n                        } else {\r\n                            this.state.set('pressed', false);\r\n                            this.owner.triggerEvent('switch-off');\r\n                        }\r\n                    }\r\n                    this.wasPressed = this.pressed;\r\n                    this.pressed = false;\r\n                }\r\n            },\r\n            'switch-pressed': function () {\r\n                this.pressed = true;\r\n                if (this.initialPress) {\r\n                    this.owner.triggerEvent('initial-press');\r\n                    this.initialPress = false;\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                this.state = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicSwitch.js?");

/***/ }),

/***/ "./src/components/LogicTeleportee.js":
/*!*******************************************!*\
  !*** ./src/components/LogicTeleportee.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/**\r\n# COMPONENT **LogicTeleportee**\r\nThis component causes an entity to teleport when receiving a teleport message.\r\n\r\n## Dependencies:\r\n- [[CollisionBasic]] (on entity) - This component triggers \"relocate-entity\" to perform teleport, for which \"CollisionBasic\" listens.\r\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.\r\n\r\n## Messages\r\n\r\n### Listens for:\r\n- **handle-logic** - On a `tick` logic message, the component updates its location according to its current state.\r\n- **teleport** - Teleports the entity to its set destination.\r\n- **set-destination** - Sets the destination to teleport to in world coordinates.\r\n  - @param message.x, message.y (number) - The position in world coordinates to set the teleport destination to.\r\n- **hit-telepoint** - Sets the destination to the colliding entity's coordinates: useful for checkpoint behavior.\r\n  - @param message ([[Entity]]) - The entity whose coordinates will be the teleport destination.\r\n\r\n### Local Broadcasts:\r\n- **relocate-entity** - Broadcasts the new location for the entity.\r\n  - @param message.x, message.y (number) - The position in world coordinates to set the teleport destination to.\r\n- **teleport-complete** - Triggered once the entity has been moved to the new location.\r\n\r\n## JSON Definition\r\n    {\r\n      \"type\": \"LogicTeleportee\"\r\n    }\r\n*/\r\n/* global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        id: 'LogicTeleportee',\r\n        \r\n        initialize: function () {\r\n            this.teleportDestination = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\r\n            this.teleportNow = false;\r\n            this.DestinationSet = false;\r\n            this.message = {\r\n                position: this.teleportDestination\r\n            };\r\n        },\r\n\r\n        events: {// These are messages that this component listens for\r\n            \"handle-logic\": function () {\r\n                if (this.teleportNow) {\r\n                    this.owner.triggerEvent('relocate-entity', this.message);\r\n                    this.teleportNow = false;\r\n                    this.owner.triggerEvent('teleport-complete');\r\n                }\r\n            },\r\n            \"teleport\": function () {\r\n                if (this.destinationSet) {\r\n                    this.teleportNow = true;\r\n                }\r\n            },\r\n            \"set-destination\": function (position) {\r\n                this.setDestination(position);\r\n            },\r\n            \"hit-telepoint\": function (collisionInfo) {\r\n                this.setDestination(collisionInfo.entity);\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            setDestination: function (position) {\r\n                this.teleportDestination.setXYZ(position.x, position.y, this.owner.z);\r\n                this.destinationSet = true;\r\n            },\r\n            \r\n            destroy: function () {\r\n                this.teleportDestination.recycle();\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicTeleportee.js?");

/***/ }),

/***/ "./src/components/LogicTeleporter.js":
/*!*******************************************!*\
  !*** ./src/components/LogicTeleporter.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n# COMPONENT **LogicTeleporter**\r\nThis component listens for redirected collision messages and fires a message on the colliding entity to specify where the colliding entity should relocate itself.\r\n\r\n## Dependencies:\r\n- [[Collision-Basic]] (on entity) - This component listens for collision messages on the entity.\r\n- [[Entity-Container]] (on entity's parent) - This component listens for new peer entities being added on its parent to find its teleport destination.\r\n\r\n## Messages\r\n\r\n### Listens for:\r\n- **peer-entity-added** - This teleporter listens as other entities are added so it can recognize the entity it should teleport colliding objects to.\r\n  - @param message (object) - expects an entity as the message object in order to determine whether it is the requested teleportation destination.\r\n- **teleport-entity** - On receiving this message, the component will fire `teleport` on the colliding entity, sending this.destination. The colliding entity must handle the `teleport` message and relocate itself.\r\n  - @param message.x (integer) - uses `x` to determine if collision occurred on the left (-1) or right (1) of this entity.\r\n  - @param message.y (integer) - uses `y` to determine if collision occurred on the top (-1) or bottom (1) of this entity.\r\n  - @param message.entity (object) - triggers a `teleport` message on `entity`.\r\n\r\n### Peer Broadcasts:\r\n- **teleport** - On receiving a `teleport-entity` message, if the colliding entity is colliding on the teleporter's facing side, this message is triggered on the colliding entity.\r\n  - @param message (object) - sends the destination entity as the message object, the x and y coordinates being the most important information for the listening entity.\r\n\r\n## JSON Definition:\r\n    {\r\n      \"type\": \"LogicTeleporter\",\r\n      \r\n      \"facing\": \"up\",\r\n      // Optional: \"up\", \"down\", \"left\", or \"right\". Will only trigger \"teleport\" if colliding entity collides on the facing side of this entity. If nothing is specified, all collisions fire a \"teleport\" message on the colliding entity.\r\n      \r\n      \"teleportId\": \"Destination entity's linkId property\"\r\n      // Required: String that matches the \"linkId\" property of the destination entity. This destination entity is passed on a \"teleport\" message so teleporting entity knows where to relocate.\r\n    }\r\n\r\n*/\r\n/*global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n\r\n    return platypus.createComponentClass({\r\n        id: 'LogicTeleporter',\r\n\r\n        initialize: function (definition) {\r\n            \r\n            this.destination = null;\r\n            this.linkId = this.owner.teleportId || definition.teleportId;\r\n            this.facing = this.owner.facing || definition.facing || false; //TODO: Should probably deprecate this in favor of orientation. - DDD 3/2/2016\r\n        \r\n            if (this.facing) {\r\n                this.owner.state.set('facing-' + this.facing, true);\r\n            }\r\n        },\r\n\r\n        events: {// These are messages that this component listens for\r\n            \"peer-entity-added\": function (entity) {\r\n                if (!this.destination && (entity.linkId === this.linkId)) {\r\n                    this.destination = entity;\r\n                }\r\n            },\r\n    \r\n            \"teleport-entity\": function (collisionInfo) {\r\n                switch (this.facing) {\r\n                case 'up':\r\n                    if (collisionInfo.y < 0) {\r\n                        collisionInfo.entity.triggerEvent('teleport', this.destination);\r\n                    }\r\n                    break;\r\n                case 'right':\r\n                    if (collisionInfo.x > 0) {\r\n                        collisionInfo.entity.triggerEvent('teleport', this.destination);\r\n                    }\r\n                    break;\r\n                case 'down':\r\n                    if (collisionInfo.y > 0) {\r\n                        collisionInfo.entity.triggerEvent('teleport', this.destination);\r\n                    }\r\n                    break;\r\n                case 'left':\r\n                    if (collisionInfo.x < 0) {\r\n                        collisionInfo.entity.triggerEvent('teleport', this.destination);\r\n                    }\r\n                    break;\r\n                default:\r\n                    collisionInfo.entity.triggerEvent('teleport', this.destination);\r\n                    break;\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {// These are methods that are called on the component\r\n            \"destroy\": function () {\r\n                this.destination = null;\r\n            }\r\n        }\r\n        \r\n    });\r\n}());\n\n//# sourceURL=webpack://platypus/./src/components/LogicTeleporter.js?");

/***/ }),

/***/ "./src/components/LogicTimer.js":
/*!**************************************!*\
  !*** ./src/components/LogicTimer.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n# COMPONENT **LogicTimer**\r\nA timer that can used to trigger events. The timer can increment and decrement. It can be an interval timer, going off over and over. Has a max time which it will not exceed by default this is 1 hour.\r\n\r\n## Dependencies\r\n- [[Handler-Logic]] (on entity's parent) - This component listens for a \"handle-logic\" message to update the timer.\r\n\r\n## Messages\r\n\r\n### Listens for:\r\n- **handle-logic** - Handles the update for the timer. Increments or decrements the current time. If it's hit the max it stops the timer at the max. If it hits the alarm it sets it off. Sends an update message indicating the timer's current time for other components to use.\r\n  - @param data.delta (number) - The time passed since the last tick.\r\n- **set** - Set the time.\r\n  - @param data.time (number) - The new value for the time.\r\n- **start** - Start the timer counting.\r\n- **stop** - Stop the timer counting.\r\n\r\n### Local Broadcasts:\r\n- **[alarm message from definition]** - The definition.alarm value from the JSON definition is used as the message id. It's sent when the alarm goes off.\r\n- **[update message from definition]** - The definition.update value from the JSON definition is used as the message id. It's sent every 'handle-logic' tick.\r\n  - @param message.time (number) - The current time value for the timer.\r\n\r\n## JSON Definition\r\n    {\r\n      \"type\": \"LogicTimer\",\r\n      \"time\" : 0,\r\n      //Optional - The starting time for the timer. Defaults to 0.\r\n      \"alarmTime\" : 10000,\r\n      //Optional - The time when the alarm will trigger the alarm message. Defaults to undefined, which never triggers the alarm.\r\n      \"isInterval\" : false,\r\n      //Optional - Whether or not the alarm fires at intervals of the alarmTime. Defaults to false.\r\n      \"alarmMessage\" : \"ding\",\r\n      //Optional - The message sent when the alarm goes off. Defaults to an empty string.\r\n      \"updateMessage\" : \"\",\r\n      //Optional - The message sent when the timer updates. Defaults to an empty string.\r\n      \"on\" : true,\r\n      //Optional - Whether the alarm starts on. Defaults to true.\r\n      \"isIncrementing\" : true,\r\n      //Optional - Whether the timer is incrementing or decrementing. If the value is false it is decrementing. Defaults to true.\r\n      \"maxTime\" : 3600000\r\n      //Optional - The max value, positive or negative, that the timer will count to. At which it stops counting. Default to 3600000 which equals an hour.\r\n    }\r\n*/\r\n/*global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n\r\n    return platypus.createComponentClass({\r\n        id: 'LogicTimer',\r\n        initialize: function (definition) {\r\n            this.time = this.owner.time || definition.time ||  0;\r\n            this.prevTime = this.time;\r\n            this.alarmTime = this.owner.alarmTime || definition.alarmTime || 0;\r\n            this.isInterval = this.owner.isInterval || definition.isInterval || false;\r\n            this.alarmMessage =  this.owner.alarmMessage || definition.alarmMessage || '';\r\n            this.updateMessage = this.owner.updateMessage || definition.updateMessage || '';\r\n            this.isOn = this.owner.on || definition.on || true;\r\n            this.isIncrementing = this.owner.isIncrementing || definition.isIncrementing || true;\r\n            this.maxTime = this.owner.maxTime || definition.maxTime || 3600000; //Max time is 1hr by default.\r\n        },\r\n        events: {\r\n            \"handle-logic\": function (data) {\r\n                if (this.isOn) {\r\n                    this.prevTime = this.time;\r\n                    if (this.isIncrementing) {\r\n                        this.time += data.delta;\r\n                    } else {\r\n                        this.time -= data.delta;\r\n                    }\r\n                    \r\n                    if (Math.abs(this.time) > this.maxTime) {\r\n                        //If the timer hits the max time we turn it off so we don't overflow anything.\r\n                        if (this.time > 0) {\r\n                            this.time = this.maxTime;\r\n                        } else if (this.time < 0) {\r\n                            this.time = -this.maxTime;\r\n                        }\r\n                        this.triggerEvent('stop-timer');\r\n                    }\r\n                    \r\n                    if (this.alarmTime !== 0) {\r\n                        if (this.isInterval) {\r\n                            if (this.isIncrementing) {\r\n                                if (Math.floor(this.time / this.alarmTime) > Math.floor(this.prevTime / this.alarmTime)) {\r\n                                    this.owner.trigger(this.alarmMessage);\r\n                                }\r\n                            } else if (Math.floor(this.time / this.alarmTime) < Math.floor(this.prevTime / this.alarmTime)) {\r\n                                this.owner.trigger(this.alarmMessage);\r\n                            }\r\n                        } else if (this.isIncrementing) {\r\n                            if (this.time > this.alarmTime && this.prevTime < this.alarmTime) {\r\n                                this.owner.trigger(this.alarmMessage);\r\n                            }\r\n                        } else if (this.time < this.alarmTime && this.prevTime > this.alarmTime) {\r\n                            this.owner.trigger(this.alarmMessage);\r\n                        }\r\n                    }\r\n                }\r\n                this.owner.trigger(this.updateMessage, {time: this.time});\r\n            },\r\n            \"set-timer\": function (data) {\r\n                this.time = data.time;\r\n            },\r\n            \"start-timer\": function () {\r\n                this.isOn = true;\r\n            },\r\n            \"stop-timer\": function () {\r\n                this.isOn = false;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicTimer.js?");

/***/ }),

/***/ "./src/components/LogicWindUpRacer.js":
/*!********************************************!*\
  !*** ./src/components/LogicWindUpRacer.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * Replicates logic for a wind-up toy: listens for a wind-up message over a series of ticks to charge, and then begins racing once the charge is complete.\r\n *\r\n * @namespace platypus.components\r\n * @class LogicWindUpRacer\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'LogicWindUpRacer',\r\n        \r\n        properties: {\r\n            /**\r\n             * Velocity at which the entity should travel while racing.\r\n             *\r\n             * @property speed\r\n             * @type Number\r\n             * @default 0.3\r\n             */\r\n            speed: 0.3,\r\n            \r\n            /**\r\n             * Time in milliseconds that entity will race before coming to a stop.\r\n             *\r\n             * @property raceTime\r\n             * @type Number\r\n             * @default 5000\r\n             */\r\n            raceTime: 5000,\r\n            \r\n            /**\r\n             * Time in milliseconds that entity needs to receive wind-up calls before racing can begin.\r\n             *\r\n             * @property windTime\r\n             * @type Number\r\n             * @default 500\r\n             */\r\n            windTime: 500\r\n        },\r\n        \r\n        initialize: function () {\r\n            var thisState = this.owner.state;\r\n            \r\n            this.windProgress = 0;\r\n            \r\n            this.winding = false;\r\n            this.racing = false;\r\n            this.blocked = false;\r\n            this.right = false;\r\n            this.left = false;\r\n            \r\n            this.state = thisState;\r\n            thisState.set('windingUp', false);\r\n            thisState.set('racing', false);\r\n            thisState.set('blocked', false);\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * On a `tick` logic message, the component updates its charging counter if necessary.\r\n             *\r\n             * @method 'handle-logic'\r\n             * @param message.delta {Number} To determine how much to charge, the component checks the length of the tick.\r\n             */\r\n            \"handle-logic\": function (resp) {\r\n                var thisState = this.state;\r\n                \r\n                if (this.racing) {\r\n\r\n                    /**\r\n                     * This event is triggered when winding is finished and the entity begins racing.\r\n                     *\r\n                     * @event 'racing'\r\n                     */\r\n                    if (!this.blocked && this.right && thisState.get('right')) {\r\n                        this.owner.x += this.speed * resp.delta;\r\n                        this.owner.triggerEvent('racing');\r\n                    } else if (!this.blocked && this.left && thisState.get('left')) {\r\n                        this.owner.x -= this.speed * resp.delta;\r\n                        this.owner.triggerEvent('racing');\r\n                    } else {\r\n                        this.racing = false;\r\n\r\n                        /**\r\n                         * This event is triggered when the entity stops racing.\r\n                         *\r\n                         * @event 'stopped-racing'\r\n                         */\r\n                        this.owner.triggerEvent('stopped-racing');\r\n                    }\r\n                } else if (this.winding) {\r\n                    if ((this.right && thisState.get('right')) || (this.left && thisState.get('left'))) {\r\n                        this.windProgress += resp.delta;\r\n                    }\r\n\r\n                    /**\r\n                     * This event is triggered as the entity winds up.\r\n                     *\r\n                     * @event 'winding'\r\n                     * @param fraction {Number} The amount of progress that has been made from 0 to 1.\r\n                     */\r\n                    this.owner.triggerEvent('winding', this.windProgress / this.windTime);\r\n                } else if (this.windProgress) {\r\n                    if (this.windProgress >= this.windTime) {\r\n                        this.racing = true;\r\n                    }\r\n                    this.windProgress = 0;\r\n\r\n                    /**\r\n                     * This event is triggered when the entity stops winding.\r\n                     *\r\n                     * @event 'stopped-winding'\r\n                     */\r\n                    this.owner.triggerEvent('stopped-winding');\r\n                }\r\n                \r\n                thisState.set('windingUp', this.winding);\r\n                thisState.set('racing', this.racing);\r\n                thisState.set('blocked', this.blocked);\r\n                this.blocked = false;\r\n            },\r\n            \r\n            /**\r\n             * Causes the entity to stop racing.\r\n             *\r\n             * @method 'stop-racing'\r\n             */\r\n            \"stop-racing\": function () {\r\n                this.racing = false;\r\n                this.owner.triggerEvent('stopped-racing');\r\n            },\r\n            \r\n            /**\r\n             * Causes the entity to wind up for a race.\r\n             *\r\n             * @method 'wind-up'\r\n             * @param message.pressed {Boolean} If `message` is included, the component checks the value of `pressed`: `false` causes winding to stop.\r\n             */\r\n            \"wind-up\": function (value) {\r\n                this.winding = !value || (value.pressed !== false);\r\n                this.right = this.state.get('right');\r\n                this.left  = this.state.get('left');\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the entity stops racing.\r\n             *\r\n             * @method 'hit-solid'\r\n             * @param collision.x {Number} Either 1,0, or -1. 1 if we're colliding with an object on our right. -1 if on our left. 0 if not at all.\r\n             */\r\n            \"hit-solid\": function (collision) {\r\n                if (collision.x) {\r\n                    if (this.racing && ((this.right && (collision.x > 0)) || (this.left && (collision.x < 0)))) {\r\n                        this.blocked = true;\r\n                        \r\n                        /**\r\n                         * This message is triggered if the entity collides while racing.\r\n                         *\r\n                         * @event 'blocked'\r\n                         * @param collision {platypus.CollisionData} Collision information from the entity or tile that blocked movement.\r\n                         */\r\n                        this.owner.triggerEvent('blocked', collision);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n    \r\n        methods: {\r\n            destroy: function () {\r\n                this.state.set('windingUp', false);\r\n                this.state.set('racing', false);\r\n                this.state.set('blocked', false);\r\n                this.state = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/LogicWindUpRacer.js?");

/***/ }),

/***/ "./src/components/Motion.js":
/*!**********************************!*\
  !*** ./src/components/Motion.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/**\r\n * This component works in tandem with the [Mover](platypus.components.Mover.html) component by adding a vector of motion to the entity. This component is typically created by `Mover` and doesn't need to be added separately.\r\n *\r\n * @namespace platypus.components\r\n * @class Motion\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var isTrue = function () {\r\n            return true;\r\n        },\r\n        getState = function (state, stateName) {\r\n            return state.get(stateName);\r\n        },\r\n        instantUpdate = function (getInstantState, getActiveVelocityState, instantSuccess) {\r\n            var state  = getInstantState(),\r\n                vState = getActiveVelocityState();\r\n            \r\n            if (this.activeVelocity) {\r\n                if (this.enact && !vState) { // Turn off ready if the state doesn't allow it.\r\n                    this.ready = false;\r\n                }\r\n\r\n                if (this.ready && this.enact && state) {\r\n                    this.ready = false; // to insure a single instance until things are reset\r\n                    this.velocity.setVector(this.instant);\r\n                    if (instantSuccess) {\r\n                        this.owner.triggerEvent(instantSuccess);\r\n                    }\r\n                } else if (!this.ready && !(this.enact && state)) {\r\n                    this.ready = true;\r\n                    this.decay();\r\n                } else if (vState) {\r\n                    return null;\r\n                }\r\n                return this.velocity;\r\n            } else {\r\n                return null;\r\n            }\r\n        },\r\n        gradualUpdate = function (getActiveVelocityState, delta) {\r\n            if (this.activeVelocity && getActiveVelocityState()) {\r\n                if (this.activeAcceleration) {\r\n                    this.move(delta);\r\n                }\r\n\r\n                return this.velocity;\r\n            } else {\r\n                return null;\r\n            }\r\n        },\r\n        createController = function (component, definition) {\r\n            var state = component.owner.state,\r\n                getActiveVelocityState = (definition.controlState ? getState.bind(null, state, definition.controlState) : isTrue),\r\n                getInstantState =        (definition.instantState ? getState.bind(null, state, definition.instantState) : isTrue);\r\n\r\n            if (component.instant || definition.instantState) {\r\n                component.instant = true;\r\n                component.update = instantUpdate.bind(component, getInstantState, getActiveVelocityState, definition.instantSuccess);\r\n            } else {\r\n                component.update = gradualUpdate.bind(component, getActiveVelocityState);\r\n            }\r\n        };\r\n    \r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'Motion',\r\n\r\n        properties: {\r\n            /**\r\n             * Whether this motion should automatically re-orient when the entity re-orients.\r\n             *\r\n             * @property orient\r\n             * @type boolean\r\n             * @default true\r\n             */\r\n            orient: true,\r\n            \r\n            /**\r\n             * A vector, Array, or number specifying the acceleration of the motion. Numbers apply magnitude along the x-axis. Arrays map to [x, y, z] on the vector.\r\n             *\r\n             * @property acceleration\r\n             * @type platypus.Vector|Array|number\r\n             * @default Vector(0, 0, 0)\r\n             * @since 0.6.8\r\n             */\r\n            acceleration: 0,\r\n            \r\n            /**\r\n             * Whether this motion should apply acceleration to the entity. Defaults to `true` unless an initial acceleration is left unset.\r\n             *\r\n             * @property activeAcceleration\r\n             * @type boolean\r\n             * @default true\r\n             */\r\n            activeAcceleration: true,\r\n            \r\n            /**\r\n             * Whether this motion should apply acceleration to the entity.\r\n             *\r\n             * @property activeVelocity\r\n             * @type boolean\r\n             * @default true\r\n             */\r\n            activeVelocity: true,\r\n            \r\n            /**\r\n             * This is the highest magnitude allowed for the motion vector.\r\n             *\r\n             * @property maxMagnitude\r\n             * @type number\r\n             * @default Infinity\r\n             */\r\n            maxMagnitude: Infinity,\r\n            \r\n            /**\r\n             * When this state on the entity changes, this motion's active state is changed to match. If an \"event\" property is also set on this component, both the event and the state must be true for the motion to be active.\r\n             *\r\n             * @property controlState\r\n             * @type String\r\n             * @default \"\"\r\n             */\r\n            controlState: \"\",\r\n            \r\n            /**\r\n             * If instant or instantState are set, the motion is only triggered for a single step and must be re-triggered to activate again. When the instantState on the entity becomes `true`, this motion's active state is changed to match. If an \"instantState\" property is also set on this component, both the event and the state must be true for the motion to be active.\r\n             *\r\n             * @property instant\r\n             * @type Boolean\r\n             * @default false\r\n             * @since 0.6.7\r\n             */\r\n            instant: false,\r\n            \r\n            /**\r\n             * If instant or instantState are set, the motion is only triggered for a single step and must be re-triggered to activate again. When the instantState on the entity becomes `true`, this motion's active state is changed to match. If an \"instant\" property is also set on this component, both the event and the state must be true for the motion to be active. If \"event\" or \"controlState\" are also defined, they must also be `true` to trigger an instant motion on the entity.\r\n             *\r\n             * @property instantState\r\n             * @type String\r\n             * @default \"\"\r\n             */\r\n            instantState: \"\",\r\n            \r\n            /**\r\n             * If instantState is set, this event is triggered when the intance of motion occurs on the entity.\r\n             *\r\n             * @property instantSuccess\r\n             * @type String\r\n             * @default \"\"\r\n             */\r\n            instantSuccess: \"\",\r\n            \r\n            /**\r\n             * This determines if setting active to `false` (via the control event or state) should dampen velocity. This is a ratio applied to the vector magnitude between 0 and 1. This is useful for events like jumping where a longer keypress should jump farther than a shorter keypress.\r\n             *\r\n             * @property instantDecay\r\n             * @type number\r\n             * @default null\r\n             */\r\n            instantDecay: null,\r\n            \r\n            /**\r\n             * A vector, Array, or number specifying the direction and magnitude of the motion. Numbers apply magnitude along the x-axis. Arrays map to [x, y, z] on the vector.\r\n             *\r\n             * @property velocity\r\n             * @type platypus.Vector|Array|number\r\n             * @default Vector(0, 0, 0)\r\n             * @since 0.6.8\r\n             */\r\n            velocity: 0,\r\n            \r\n            stopOnCollision: true,\r\n            \r\n            drag: -1,\r\n            friction: -1\r\n        },\r\n        \r\n        initialize: function (definition) {\r\n            if (!this.acceleration) {\r\n                this.activeAcceleration = false;\r\n            }\r\n            this.acceleration = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.acceleration);\r\n            this.velocity     = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.velocity);\r\n\r\n            this.triggered = false;\r\n            this.ready = true;\r\n            \r\n            if (typeof this.instantDecay === \"number\") {\r\n                this.capMagnitude = this.velocity.magnitude() * this.instantDecay;\r\n            } else {\r\n                this.capMagnitude = -1;\r\n            }\r\n            \r\n            createController(this, definition);\r\n            \r\n            if (this.instant) {\r\n                this.enact = false;\r\n                this.instant = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.velocity);\r\n                this.velocity.setXYZ(0, 0, 0);\r\n            }\r\n\r\n            if (this.orient) { // Orient vectors in case the entity is in a transformed position.\r\n                this.owner.triggerEvent('orient-vector', this.velocity);\r\n                this.owner.triggerEvent('orient-vector', this.acceleration);\r\n            }\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * This event controls whether this velocity is active or inactive.\r\n             *\r\n             * @method 'control-velocity'\r\n             * @param control {Object|boolean} If `true`, this motion becomes active. If `false` or `{pressed: false}`, the motion becomes inactive.\r\n             * @since 0.6.8\r\n             */\r\n            \"control-velocity\": function (control) {\r\n                this.activeVelocity = (control && (control.pressed !== false));\r\n            },\r\n            \r\n            /**\r\n             * This event sets the velocity to inactive.\r\n             *\r\n             * @method 'stop-velocity'\r\n             * @since 0.6.8\r\n             */\r\n            \"stop-velocity\": function () {\r\n                this.activeVelocity = false;\r\n            },\r\n            \r\n            /**\r\n             * This event sets the velocity to active.\r\n             *\r\n             * @method 'start-velocity'\r\n             * @since 0.6.8\r\n             */\r\n            \"start-velocity\": function () {\r\n                this.activeVelocity = true;\r\n            },\r\n            \r\n            /**\r\n             * This event controls whether the acceleration is active or inactive.\r\n             *\r\n             * @method 'control-acceleration'\r\n             * @param control {Object|boolean} If `true`, this motion becomes active. If `false` or `{pressed: false}`, the motion becomes inactive.\r\n             * @since 0.6.8\r\n             */\r\n            \"control-acceleration\": function (control) {\r\n                this.activeAcceleration = (control && (control.pressed !== false));\r\n            },\r\n            \r\n            /**\r\n             * This event sets the acceleration to inactive.\r\n             *\r\n             * @method 'stop-acceleration'\r\n             * @since 0.6.8\r\n             */\r\n            \"stop-acceleration\": function () {\r\n                this.activeAcceleration = false;\r\n            },\r\n            \r\n            /**\r\n             * This event sets the acceleration to active.\r\n             *\r\n             * @method 'start-acceleration'\r\n             * @since 0.6.8\r\n             */\r\n            \"start-acceleration\": function () {\r\n                this.activeAcceleration = true;\r\n            },\r\n            \r\n            /**\r\n            * This event triggers an instant motion.\r\n            *\r\n            * @method 'instant-motion'\r\n            * @param control {Object|boolean} If `true`, this motion becomes active. If `false` or `{triggered: false}`, the motion becomes inactive.\r\n            * @since 0.6.7\r\n            */\r\n            \"instant-motion\": function (control) {\r\n                this.enact = (control && (control.triggered !== false));\r\n            },\r\n\r\n            /**\r\n            * This event triggers the beginning of an instant motion.\r\n            *\r\n            * @method 'instant-begin'\r\n            * @since 0.6.7\r\n            */\r\n            \"instant-begin\": function () {\r\n                this.enact = true;\r\n            },\r\n\r\n            /**\r\n            * This event triggers the end of an instant motion.\r\n            *\r\n            * @method 'instant-end'\r\n            * @since 0.6.7\r\n            */\r\n            \"instant-end\": function () {\r\n                this.enact = false;\r\n            },\r\n            \r\n            /**\r\n            * This event modifies the properties of this Motion.\r\n            *\r\n            * @method 'set-motion'\r\n            * @param motion {Object} A list of key/value pairs corresponding to motion values.\r\n            * @param [motion.maxMagnitude] {Number} A value describing the maximum velocity or acceleration the motion vector can exert on the Entity.\r\n            * @since 0.6.8\r\n            */\r\n            \"set-motion\": function (motion) {\r\n                if (motion.acceleration) {\r\n                    this.acceleration.set(motion.acceleration);\r\n                }\r\n                if (motion.velocity) {\r\n                    this.velocity.set(motion.velocity);\r\n                    if (typeof this.instantDecay === \"number\") {\r\n                        this.capMagnitude = this.velocity.magnitude() * this.instantDecay;\r\n                    } else {\r\n                        this.capMagnitude = -1;\r\n                    }\r\n                }\r\n                if (typeof motion.maxMagnitude === \"number\") {\r\n                    this.maxMagnitude = motion.maxMagnitude;\r\n                }\r\n            }\r\n        },\r\n\r\n        methods: {\r\n            move: function (delta) {\r\n                var v = _Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.acceleration).multiply(delta);\r\n                \r\n                this.velocity.add(v);\r\n                v.recycle();\r\n                \r\n                if (this.velocity.magnitude() > this.maxMagnitude) {\r\n                    this.velocity.normalize().multiply(this.maxMagnitude);\r\n                }\r\n                return this.velocity;\r\n            },\r\n            \r\n            // This handles things like variable height jumping by adjusting the jump velocity to the pre-determined cap velocity for jump-button release.\r\n            decay: function () {\r\n                if ((this.capMagnitude >= 0) && (this.velocity.magnitude() > this.capMagnitude)) {\r\n                    this.velocity.normalize().multiply(this.capMagnitude);\r\n                }\r\n            },\r\n            \r\n            destroy: function () {\r\n                if (this.orient) {\r\n                    this.owner.triggerEvent('remove-vector', this.acceleration);\r\n                    this.owner.triggerEvent('remove-vector', this.velocity);\r\n                }\r\n                this.acceleration.recycle();\r\n                this.velocity.recycle();\r\n                if (this.instant) {\r\n                    this.instant.recycle();\r\n                }\r\n            }\r\n        },\r\n        \r\n        publicMethods: {\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/Motion.js?");

/***/ }),

/***/ "./src/components/Mover.js":
/*!*********************************!*\
  !*** ./src/components/Mover.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/**\r\n * This component handles entity motion via velocity and acceleration changes. This is useful for directional movement, gravity, bounce-back collision reactions, jumping, etc.\r\n *\r\n * @namespace platypus.components\r\n * @class Mover\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var tempVector = _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(),\r\n        updateMax   = function (delta, interim, goal, time) {\r\n            if (delta && (interim !== goal)) {\r\n                if (interim < goal) {\r\n                    return Math.min(interim + delta * time, goal);\r\n                } else {\r\n                    return Math.max(interim - delta * time, goal);\r\n                }\r\n            }\r\n            \r\n            return interim;\r\n        },\r\n        clampNumber = function (v, d) {\r\n            var mIn = this.maxMagnitudeInterim = updateMax(this.maxMagnitudeDelta, this.maxMagnitudeInterim, this.maxMagnitude, d);\r\n            \r\n            if (v.magnitude() > mIn) {\r\n                v.normalize().multiply(mIn);\r\n            }\r\n        },\r\n        clampObject = function (v, d) {\r\n            var max = this.maxMagnitude,\r\n                mD  = this.maxMagnitudeDelta,\r\n                mIn = this.maxMagnitudeInterim;\r\n\r\n            mIn.up    = updateMax(mD, mIn.up,    max.up,    d);\r\n            mIn.right = updateMax(mD, mIn.right, max.right, d);\r\n            mIn.down  = updateMax(mD, mIn.down,  max.down,  d);\r\n            mIn.left  = updateMax(mD, mIn.left,  max.left,  d);\r\n            \r\n            if (v.x > 0) {\r\n                if (v.x > mIn.right) {\r\n                    v.x = mIn.right;\r\n                }\r\n            } else if (v.x < 0) {\r\n                if (v.x < -mIn.left) {\r\n                    v.x = -mIn.left;\r\n                }\r\n            }\r\n\r\n            if (v.y > 0) {\r\n                if (v.y > mIn.down) {\r\n                    v.y = mIn.down;\r\n                }\r\n            } else if (v.y < 0) {\r\n                if (v.y < -mIn.up) {\r\n                    v.y = -mIn.up;\r\n                }\r\n            }\r\n        };\r\n        \r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'Mover',\r\n\r\n        properties: {\r\n            /** This is a normalized vector describing the direction the ground should face away from the entity.\r\n             *\r\n             * @property ground\r\n             * @type Array|Vector\r\n             * @default Vector(0, 1)\r\n             */\r\n            ground: [0, 1]\r\n        },\r\n        \r\n        publicProperties: {\r\n            /**\r\n             * A list of key/value pairs describing vectors or vector-like objects describing acceleration and velocity on the entity. See the [\"Motion\"](\"Motion\"%20Component.html) component for properties.\r\n             *\r\n             * @property movers\r\n             * @type Array\r\n             * @default []\r\n             */\r\n            movers: [],\r\n            \r\n            /**\r\n             * If specified, the property adds gravity motion to the entity.\r\n             *\r\n             * @property gravity\r\n             * @type number|Array|Vector\r\n             * @default: 0\r\n             */\r\n            gravity: 0,\r\n            \r\n            /**\r\n             * If specified, the property adds jumping motion to the entity.\r\n             *\r\n             * @property jump\r\n             * @type number|Array|Vector\r\n             * @default: 0\r\n             */\r\n            jump: 0,\r\n            \r\n            /**\r\n             * If specified, the property adds velocity to the entity.\r\n             *\r\n             * @property speed\r\n             * @type number|Array|Vector\r\n             * @default: 0\r\n             */\r\n            speed: 0,\r\n            \r\n            /**\r\n             * This property determines how quickly velocity is dampened when the entity is not in a \"grounded\" state. This should be a value between 1 (no motion) and 0 (no drag).\r\n             *\r\n             * @property drag\r\n             * @type number\r\n             * @default 0.01\r\n             */\r\n            drag: 0.01,\r\n            \r\n            /**\r\n             * This property determines how quickly velocity is dampened when the entity is in a \"grounded\" state. This should be a value between 1 (no motion) and 0 (no friction).\r\n             *\r\n             * @property friction\r\n             * @type number\r\n             * @default 0.06\r\n             */\r\n            friction: 0.06,\r\n            \r\n            /**\r\n             * This property determines the maximum amount of velocity this entity can maintain. This can be a number or an object describing maximum velocity in a particular direction. For example:\r\n             *\r\n             *     {\r\n             *         \"up\": 8,\r\n             *         \"right\": 12,\r\n             *         \"down\": 0.4,\r\n             *         \"left\": 12\r\n             *     }\r\n             *\r\n             * @property maxMagnitude\r\n             * @type number|Object\r\n             * @default Infinity\r\n             */\r\n            maxMagnitude: Infinity,\r\n            \r\n            /**\r\n             * This property determines the rate of change to new maximum amount of velocities.\r\n             *\r\n             * @property maxMagnitudeDelta\r\n             * @type number\r\n             * @default 0\r\n             */\r\n            maxMagnitudeDelta: 0,\r\n            \r\n            /**\r\n             * This property determines whether orientation changes should apply external velocities from pre-change momentum.\r\n             *\r\n             * @property reorientVelocities\r\n             * @type Boolean\r\n             * @default true\r\n             */\r\n            reorientVelocities: true\r\n        },\r\n        \r\n        initialize: function () {\r\n            var maxMagnitude = Infinity,\r\n                max = this.maxMagnitude,\r\n                thisState = this.owner.state;\r\n            \r\n            _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].assign(this.owner, 'position',  'x',  'y',  'z');\r\n            _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].assign(this.owner, 'velocity', 'dx', 'dy', 'dz');\r\n\r\n            this.position = this.owner.position;\r\n            this.velocity = this.owner.velocity;\r\n            this.lastVelocity = _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(this.velocity);\r\n            this.collision = null;\r\n            \r\n            this.pause = false;\r\n            \r\n            // Copy movers so we're not re-using mover definitions\r\n            this.moversCopy = this.movers;\r\n            this.movers = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n\r\n            this.velocityChanges = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.velocityDirections = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n\r\n            this.ground = _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(this.ground);\r\n            \r\n            this.state = thisState;\r\n            thisState.set('grounded', false);\r\n            \r\n            Object.defineProperty(this.owner, \"maxMagnitude\", {\r\n                get: function () {\r\n                    return maxMagnitude;\r\n                },\r\n                set: function (max) {\r\n                    if (typeof max === 'number') {\r\n                        this.clamp = clampNumber;\r\n                        maxMagnitude = max;\r\n                        if (!this.maxMagnitudeDelta) {\r\n                            this.maxMagnitudeInterim = max;\r\n                        }\r\n                    } else {\r\n                        this.clamp = clampObject;\r\n                        if (typeof maxMagnitude === 'number') {\r\n                            maxMagnitude = {\r\n                                up: maxMagnitude,\r\n                                right: maxMagnitude,\r\n                                down: maxMagnitude,\r\n                                left: maxMagnitude\r\n                            };\r\n                        }\r\n                        if (typeof max.up === 'number') {\r\n                            maxMagnitude.up = max.up;\r\n                        }\r\n                        if (typeof max.right === 'number') {\r\n                            maxMagnitude.right = max.right;\r\n                        }\r\n                        if (typeof max.down === 'number') {\r\n                            maxMagnitude.down = max.down;\r\n                        }\r\n                        if (typeof max.left === 'number') {\r\n                            maxMagnitude.left = max.left;\r\n                        }\r\n\r\n                        if (typeof this.maxMagnitudeInterim === 'number') {\r\n                            if (this.maxMagnitudeDelta) {\r\n                                this.maxMagnitudeInterim = {\r\n                                    up: this.maxMagnitudeInterim,\r\n                                    right: this.maxMagnitudeInterim,\r\n                                    down: this.maxMagnitudeInterim,\r\n                                    left: this.maxMagnitudeInterim\r\n                                };\r\n                            } else {\r\n                                this.maxMagnitudeInterim = {\r\n                                    up: maxMagnitude.up,\r\n                                    right: maxMagnitude.right,\r\n                                    down: maxMagnitude.down,\r\n                                    left: maxMagnitude.left\r\n                                };\r\n                            }\r\n                        } else if (!this.maxMagnitudeDelta) {\r\n                            this.maxMagnitudeInterim.up    = maxMagnitude.up;\r\n                            this.maxMagnitudeInterim.right = maxMagnitude.right;\r\n                            this.maxMagnitudeInterim.down  = maxMagnitude.down;\r\n                            this.maxMagnitudeInterim.left  = maxMagnitude.left;\r\n                        }\r\n                    }\r\n                }.bind(this)\r\n            });\r\n            this.maxMagnitudeInterim = 0;\r\n            this.maxMagnitude = max;\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * When a [\"Motion\"](\"Motion\"%20Component.html) component is added, this component adds it to its list of movers.\r\n             *\r\n             * @method 'component-added'\r\n             * @param component {\"Motion\" Component} The motion to add as a mover on this entity.\r\n             */\r\n            \"component-added\": function (component) {\r\n                if (component.type === 'Motion') {\r\n                    this.movers.push(component);\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * When a [\"Motion\"](\"Motion\"%20Component.html) component is removed, this component removes it from its list of movers.\r\n             *\r\n             * @method 'component-removed'\r\n             * @param component {\"Motion\" Component} The motion to remove as a mover from this entity.\r\n             */\r\n            \"component-removed\": function (component) {\r\n                var i = 0;\r\n                \r\n                if (component.type === 'Motion') {\r\n                    i = this.movers.indexOf(component);\r\n                    if (i >= 0) {\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.movers, i);\r\n                    }\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * This component listens for a \"load\" event before setting up its mover list.\r\n             *\r\n             * @method 'load'\r\n             */\r\n            \"load\": function () {\r\n                var i = 0,\r\n                    movs = this.moversCopy;\r\n                \r\n                delete this.moversCopy;\r\n                for (i = 0; i < movs.length; i++) {\r\n                    this.addMover(movs[i]);\r\n                }\r\n                \r\n                this.externalForces = this.addMover({\r\n                    velocity: [0, 0, 0],\r\n                    orient: false\r\n                }).velocity;\r\n                \r\n                // Set up speed property if supplied.\r\n                if (this.speed) {\r\n                    if (!isNaN(this.speed)) {\r\n                        this.speed = [this.speed, 0, 0];\r\n                    }\r\n                    this.speed = this.addMover({\r\n                        velocity: this.speed,\r\n                        controlState: \"moving\"\r\n                    }).velocity;\r\n                }\r\n\r\n                // Set up gravity property if supplied.\r\n                if (this.gravity) {\r\n                    if (!isNaN(this.gravity)) {\r\n                        this.gravity = [0, this.gravity, 0];\r\n                    }\r\n                    this.gravity = this.addMover({\r\n                        acceleration: this.gravity,\r\n                        orient: false,\r\n                        aliases: {\r\n                            \"gravitate\": \"control-acceleration\"\r\n                        }\r\n                    }).acceleration;\r\n                }\r\n                \r\n                // Set up jump property if supplied.\r\n                if (this.jump) {\r\n                    if (!isNaN(this.jump)) {\r\n                        this.jump = [0, this.jump, 0];\r\n                    }\r\n                    this.jump = this.addMover({\r\n                        velocity: this.jump,\r\n                        instant: true,\r\n                        controlState: \"grounded\",\r\n                        state: \"jumping\",\r\n                        instantSuccess: \"just-jumped\",\r\n                        instantDecay: 0.2,\r\n                        aliases: {\r\n                            \"jump\": \"instant-motion\"\r\n                        }\r\n                    }).instant;\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * On each \"handle-movement\" event, this component moves the entity according to the list of movers on the entity.\r\n             *\r\n             * @method 'handle-movement'\r\n             * @param tick {Object}\r\n             * @param tick.delta {number} The amount of time in milliseconds since the last tick.\r\n             * @since 0.6.8\r\n             */\r\n            \"handle-movement\": function (tick) {\r\n                var delta    = tick.delta,\r\n                    m        = null,\r\n                    thisState = this.state,\r\n                    vect     = null,\r\n                    velocity = this.velocity,\r\n                    position = this.position,\r\n                    movers   = this.movers,\r\n                    i        = movers.length;\r\n                \r\n                if (thisState.get('paused') || this.paused) {\r\n                    return;\r\n                }\r\n                \r\n                if (!velocity.equals(this.lastVelocity, 2)) {\r\n                    this.externalForces.addVector(velocity).subtractVector(this.lastVelocity);\r\n                }\r\n                \r\n                velocity.setXYZ(0, 0, 0);\r\n                \r\n                while (i--) {\r\n                    m = movers[i].update(delta);\r\n                    if (m) {\r\n                        if (this.grounded) { // put this in here to match earlier behavior\r\n                            if (movers[i].friction !== -1) {\r\n                                m.multiply(1 - movers[i].friction);\r\n                            } else {\r\n                                m.multiply(1 - this.friction);\r\n                            }\r\n                        } else if (movers[i].drag !== -1) {\r\n                            m.multiply(1 - movers[i].drag);\r\n                        } else {\r\n                            m.multiply(1 - this.drag);\r\n                        }\r\n                        velocity.add(m);\r\n                    }\r\n                }\r\n\r\n                this.clamp(velocity, delta);\r\n                this.lastVelocity.setVector(velocity);\r\n                \r\n                vect = _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(velocity).multiply(delta);\r\n                position.add(vect);\r\n                vect.recycle();\r\n                \r\n                thisState.set('grounded', this.grounded);\r\n                \r\n                this.grounded = false;\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, this component stops all velocities along the axis of the collision direction and sets \"grounded\" to `true` if colliding with the ground.\r\n             *\r\n             * @method 'hit-solid'\r\n             * @param collisionInfo {Object}\r\n             * @param collisionInfo.direction {platypus.Vector} The direction of collision from the entity's position.\r\n             */\r\n            \"hit-solid\": function (collisionInfo) {\r\n                var s = 0,\r\n                    e = 0,\r\n                    entityV = collisionInfo.entity && collisionInfo.entity.velocity,\r\n                    direction = collisionInfo.direction,\r\n                    add = true,\r\n                    vc = this.velocityChanges,\r\n                    vd = this.velocityDirections,\r\n                    i = vc.length;\r\n                \r\n                if (direction.dot(this.ground) > 0) {\r\n                    this.grounded = true;\r\n                }\r\n\r\n                s = this.velocity.scalarProjection(direction);\r\n                if (s > 0) {\r\n                    if (entityV) {\r\n                        e = Math.max(entityV.scalarProjection(direction), 0);\r\n                        if (e < s) {\r\n                            s = e;\r\n                        } else {\r\n                            s = 0;\r\n                        }\r\n                    } else {\r\n                        s = 0;\r\n                    }\r\n                    \r\n                    while (i--) {\r\n                        if ((s < vc[i]) && (vd[i].dot(direction) > 0)) {\r\n                            vc[i] = s;\r\n                            vd[i].setVector(direction);\r\n                            add = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    \r\n                    if (add) {\r\n                        vc.push(s);\r\n                        vd.push(_Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(direction));\r\n                    }\r\n                }\r\n            },\r\n            \r\n            \"handle-post-collision-logic\": function () {\r\n                var direction = null,\r\n                    ms = this.movers,\r\n                    vc = this.velocityChanges,\r\n                    vd = this.velocityDirections,\r\n                    i = vc.length,\r\n                    j = ms.length,\r\n                    m = null,\r\n                    s = 0,\r\n                    sdi = 0,\r\n                    soc = null,\r\n                    v = tempVector;\r\n                \r\n                if (i) {\r\n                    soc = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                    \r\n                    while (j--) {\r\n                        m = ms[j];\r\n                        if (m.stopOnCollision) {\r\n                            soc.push(m);\r\n                        }\r\n                    }\r\n                    \r\n                    while (i--) {\r\n                        direction = vd[i];\r\n                        s = vc[i];\r\n                        j = soc.length;\r\n                        sdi = s / j;\r\n                        while (j--) {\r\n                            m = soc[j];\r\n                            v.setVector(direction).normalize().multiply(sdi - m.velocity.scalarProjection(direction));\r\n                            m.velocity.add(v);\r\n                        }\r\n                        direction.recycle();\r\n                    }\r\n                    \r\n                    vc.length = 0;\r\n                    vd.length = 0;\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(soc);\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * Update mover properties.\r\n             *\r\n             * @method 'set-mover'\r\n             * @param mover {Object}\r\n             * @param [mover.maxMagnitude] {Number|Object} New maximums for magnitude.\r\n             * @param [mover.magnitude] {Number} Delta for the change in maximums.\r\n             * @since 0.6.8\r\n             */\r\n            \"set-mover\": function (mover) {\r\n                if (typeof mover.maxMagnitudeDelta === 'number') {\r\n                    this.maxMagnitudeDelta = mover.maxMagnitudeDelta;\r\n                }\r\n                \r\n                if (mover.maxMagnitude) {\r\n                    this.maxMagnitude = mover.maxMagnitude;\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * Stops all movement on the Entity.\r\n             *\r\n             * @method 'pause-movment'\r\n             * @since 0.6.8\r\n             */\r\n            \"pause-movement\": function () {\r\n                this.paused = true;\r\n            },\r\n            \r\n            /**\r\n             * Unpauses all movement on the Entity.\r\n             *\r\n             * @method 'unpause-movment'\r\n             * @since 0.6.8\r\n             */\r\n            \"unpause-movement\": function () {\r\n                this.paused = false;\r\n            },\r\n            \r\n            /**\r\n             * Handles velocity change if velocities should not be re-oriented.\r\n             *\r\n             * @method 'orientation-updated'\r\n             * @param matrix {Array} A 3x3 matrix describing the orientation change.\r\n             * @since 0.7.3\r\n             */\r\n            \"orientation-updated\": function (matrix) {\r\n                if (!this.reorientVelocities) {\r\n                    this.lastVelocity.multiply(matrix);\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                var i = 0,\r\n                    max = this.maxMagnitude;\r\n                \r\n                for (i = this.movers.length - 1; i >= 0; i--) {\r\n                    this.removeMover(this.movers[i]);\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.movers);\r\n                \r\n                this.ground.recycle();\r\n                this.lastVelocity.recycle();\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.velocityChanges);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.velocityDirections);\r\n                \r\n                delete this.owner.maxMagnitude; // remove property handlers\r\n                this.owner.maxMagnitude = max;\r\n                \r\n                this.state = null;\r\n            }\r\n        },\r\n        \r\n        publicMethods: {\r\n            /**\r\n             * This method adds a mover to the entity in the form of a [\"Motion\"](\"Motion\"%20Component.html) component definition.\r\n             *\r\n             * @method addMover\r\n             * @param mover {Object} For motion definition properties, see the [\"Motion\"](\"Motion\"%20Component.html) component.\r\n             * @return motion {\"Motion\" Component}\r\n             */\r\n            addMover: function (mover) {\r\n                var m = this.owner.addComponent(new platypus.components.Motion(this.owner, mover));\r\n\r\n                return m;\r\n            },\r\n            \r\n            /**\r\n             * This method removes a mover from the entity.\r\n             *\r\n             * @method removeMover\r\n             * @param motion {\"Motion\" Component}\r\n             */\r\n            removeMover: function (m) {\r\n                this.owner.removeComponent(m);\r\n            }\r\n        }\r\n    });\r\n}());\n\n//# sourceURL=webpack://platypus/./src/components/Mover.js?");

/***/ }),

/***/ "./src/components/Node.js":
/*!********************************!*\
  !*** ./src/components/Node.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/**\r\n# COMPONENT **Node**\r\nThis component causes an entity to be a position on a [[NodeMap]]. This component should not be confused with `NodeResident` which should be used on entities that move around on a NodeMap: `Node` simply represents a non-moving location on the NodeMap.\r\n  \r\n## JSON Definition\r\n    {\r\n      \"type\": \"NodeResident\",\r\n      \r\n      \"nodeId\": \"city-hall\",\r\n      // Optional. The id of the node that this entity should start on. Uses the entity's nodeId property if not set here.\r\n      \r\n      \"nodes\": ['path','sidewalk','road'],\r\n      // Optional. This is a list of node types that this entity can reside on. If not set, entity can reside on any type of node.\r\n      \r\n      \"shares\": ['friends','neighbors','city-council-members'],\r\n      // Optional. This is a list of entities that this entity can reside with on the same node. If not set, this entity cannot reside with any entities on the same node.\r\n      \r\n      \"speed\": 5,\r\n      // Optional. Sets the speed with which the entity moves along an edge to an adjacent node. Default is 0 (instantaneous movement).\r\n      \r\n      \"updateOrientation\": true\r\n      // Optional. Determines whether the entity's orientation is updated by movement across the NodeMap. Default is false.\r\n    }\r\n*/\r\n/* global platypus */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'Node',\r\n        \r\n        publicProperties: {\r\n            x: 0,\r\n            y: 0,\r\n            z: 0\r\n        },\r\n        \r\n        initialize: function (definition) {\r\n            this.nodeId = definition.nodeId || this.owner.nodeId || this.owner.id || String(Math.random());\r\n            \r\n            if ((typeof this.nodeId !== 'string') && (this.nodeId.length)) {\r\n                this.nodeId = definition.nodeId.join('|');\r\n            }\r\n            \r\n            this.owner.nodeId = this.nodeId;\r\n            \r\n            this.owner.isNode = true;\r\n            this.map = this.owner.map = this.owner.map || this.owner.parent || null;\r\n            this.contains = this.owner.contains = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.edgesContain = this.owner.edgesContain = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            \r\n            _Vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].assign(this.owner, 'position', 'x', 'y', 'z');\r\n            \r\n            this.neighbors = this.owner.neighbors = definition.neighbors || this.owner.neighbors || {};\r\n        },\r\n        \r\n        events: {\r\n            \"add-neighbors\": function (neighbors) {\r\n                var i = 0,\r\n                    direction = null;\r\n                \r\n                for (direction in neighbors) {\r\n                    if (neighbors.hasOwnProperty(direction)) {\r\n                        this.neighbors[direction] = neighbors[direction];\r\n                    }\r\n                }\r\n                \r\n                for (i = 0; i < this.contains.length; i++) {\r\n                    this.contains[i].triggerEvent('set-directions');\r\n                }\r\n            },\r\n            \"remove-neighbor\": function (nodeOrNodeId) {\r\n                var i  = null,\r\n                    id = nodeOrNodeId;\r\n                \r\n                if (typeof id !== 'string') {\r\n                    id = id.nodeId;\r\n                }\r\n\r\n                for (i in this.neighbors) {\r\n                    if (this.neighbors.hasOwnProperty(i)) {\r\n                        if (typeof this.neighbors[i] === 'string') {\r\n                            if (this.neighbors[i] === id) {\r\n                                delete this.neighbors[i];\r\n                                break;\r\n                            }\r\n                        } else if (this.neighbors[i].nodeId === id) {\r\n                            delete this.neighbors[i];\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.contains);\r\n                this.contains = this.owner.contains = null;\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.edgesContain);\r\n                this.edgesContain = this.owner.edgesContain = null;\r\n            }\r\n        },\r\n        \r\n        publicMethods: {\r\n            getNode: function (desc) {\r\n                var neighbor = null;\r\n                \r\n                //map check\r\n                if (!this.map && this.owner.map) {\r\n                    this.map = this.owner.map;\r\n                }\r\n                \r\n                if (this.neighbors[desc]) {\r\n                    neighbor = this.neighbors[desc];\r\n                    if (neighbor.isNode) {\r\n                        return neighbor;\r\n                    } else if (typeof neighbor === 'string') {\r\n                        neighbor = this.map.getNode(neighbor);\r\n                        if (neighbor) {\r\n                            this.neighbors[desc] = neighbor;\r\n                            return neighbor;\r\n                        }\r\n                    } else if (neighbor.length) {\r\n                        neighbor = this.map.getNode(neighbor.join('|'));\r\n                        if (neighbor) {\r\n                            this.neighbors[desc] = neighbor;\r\n                            return neighbor;\r\n                        }\r\n                    }\r\n                    return null;\r\n                } else {\r\n                    return null;\r\n                }\r\n            },\r\n            addToNode: function (entity) {\r\n                var i = 0;\r\n                \r\n                for (i = 0; i < this.contains.length; i++) {\r\n                    if (this.contains[i] === entity) {\r\n                        return false;\r\n                    }\r\n                }\r\n                this.contains.push(entity);\r\n                return entity;\r\n            },\r\n            removeFromNode: function (entity) {\r\n                var i = 0;\r\n                \r\n                for (i = 0; i < this.contains.length; i++) {\r\n                    if (this.contains[i] === entity) {\r\n                        return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.contains, i);\r\n                    }\r\n                }\r\n                return false;\r\n            },\r\n            addToEdge: function (entity) {\r\n                var i = 0;\r\n                \r\n                for (i = 0; i < this.edgesContain.length; i++) {\r\n                    if (this.edgesContain[i] === entity) {\r\n                        return false;\r\n                    }\r\n                }\r\n                this.edgesContain.push(entity);\r\n                return entity;\r\n            },\r\n            removeFromEdge: function (entity) {\r\n                var i = 0;\r\n                \r\n                for (i = 0; i < this.edgesContain.length; i++) {\r\n                    if (this.edgesContain[i] === entity) {\r\n                        return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.edgesContain, i);\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/Node.js?");

/***/ }),

/***/ "./src/components/NodeMap.js":
/*!***********************************!*\
  !*** ./src/components/NodeMap.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\r\n * This component sets up a NodeMap to be used by the [NodeResident](platypus.components.NodeResident.html) component on this entity's child entities.\r\n *\r\n * @namespace platypus.components\r\n * @class NodeMap\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var Node = function (definition, map) { // This is a basic node object, but can be replaced by entities having a `Node` component if more functionality is needed.\r\n            if (definition.id) {\r\n                if (typeof definition.id === 'string') {\r\n                    this.id = definition.id;\r\n                } else if (Array.isArray(definition.id)) {\r\n                    this.id = definition.id.join('|');\r\n                } else {\r\n                    this.id = String(Math.random());\r\n                }\r\n            } else {\r\n                this.id = String(Math.random());\r\n            }\r\n\r\n            this.isNode = true;\r\n            this.map = map;\r\n            this.contains = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.type = definition.type || '';\r\n            this.x = definition.x || 0;\r\n            this.y = definition.y || 0;\r\n            this.z = definition.z || 0;\r\n\r\n            this.neighbors = definition.neighbors || {};\r\n        },\r\n        proto = Node.prototype;\r\n    \r\n    proto.getNode = function (desc) {\r\n        var neighbor = null;\r\n        \r\n        if (this.neighbors[desc]) {\r\n            neighbor = this.neighbors[desc];\r\n            if (neighbor.isNode) {\r\n                return neighbor;\r\n            } else if (typeof neighbor === 'string') {\r\n                neighbor = this.map.getNode(neighbor);\r\n                if (neighbor) {\r\n                    this.neighbors[desc] = neighbor;\r\n                    return neighbor;\r\n                }\r\n            } else if (Array.isArray(neighbor)) {\r\n                neighbor = this.map.getNode(neighbor.join('|'));\r\n                if (neighbor) {\r\n                    this.neighbors[desc] = neighbor;\r\n                    return neighbor;\r\n                }\r\n            }\r\n            return null;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    proto.add = function (entity) {\r\n        var i = 0;\r\n        \r\n        for (i = 0; i < this.contains.length; i++) {\r\n            if (this.contains[i] === entity) {\r\n                return false;\r\n            }\r\n        }\r\n        this.contains.push(entity);\r\n        return entity;\r\n    };\r\n    \r\n    proto.remove = function (entity) {\r\n        var i = 0;\r\n        \r\n        for (i = 0; i < this.contains.length; i++) {\r\n            if (this.contains[i] === entity) {\r\n                return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.contains, i);\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    \r\n    recycle__WEBPACK_IMPORTED_MODULE_4__[\"default\"].add(Node, 'Node', Node, function () {\r\n        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.contains);\r\n    }, true, config__WEBPACK_IMPORTED_MODULE_3___default.a.dev);\r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'NodeMap',\r\n        \r\n        publicProperties: {\r\n            /**\r\n             * An array of node definitions to create the NodeMap. A node definition can take the following form:\r\n             *\r\n             *         {\r\n             *           \"NodeId\": \"Node1\",\r\n             *           // A string or array that becomes the id of the Node. Arrays are joined using \"|\" to create the id string.\r\n             *           \"type\": \"path\",\r\n             *           // A string that determines the type of the node.\r\n             *           \"x\": 0,\r\n             *           // Sets the x axis position of the node.\r\n             *           \"y\": 0,\r\n             *           // Sets the y axis position of the node.\r\n             *           \"z\": 0,\r\n             *           // Sets the z axis position of the node.\r\n             *           \"neighbors\": {\r\n             *           // A list of key/value pairs where the keys are directions from the node and values are node ids.\r\n             *             \"west\": \"node0\",\r\n             *             \"east\": \"node2\"\r\n             *           }\r\n             *         }\r\n             *\r\n             * @property map\r\n             * @type Array\r\n             * @default []\r\n             */\r\n            map: []\r\n        },\r\n        \r\n        initialize: function () {\r\n            var i   = 0,\r\n                map = this.map;\r\n            \r\n            this.map   = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(); // Original map is node definitions, so we replace it with actual nodes.\r\n            this.nodes = {};\r\n            this.residentsAwaitingNode = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            \r\n            for (i = 0; i < map.length; i++) {\r\n                this.addNode(Node.setUp(map[i], this));\r\n            }\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * Expects a node definition to create a node in the NodeMap.\r\n             *\r\n             * @method 'add-node'\r\n             * @param definition {Object} Key/value pairs.\r\n             * @param definition.nodeId {String|Array} This value becomes the id of the Node. Arrays are joined using \"|\" to create the id string.\r\n             * @param definition.type {String} This determines the type of the node.\r\n             * @param definition.x {String} Sets the x axis position of the node.\r\n             * @param definition.y {String} Sets the y axis position of the node.\r\n             * @param definition.z {String} Sets the z axis position of the node.\r\n             * @param definition.neighbors {Object} A list of key/value pairs where the keys are directions from the node and values are node ids. For example: {\"west\": \"node12\"}.\r\n             */\r\n            \"add-node\": function (nodeDefinition) {\r\n                var i = 0,\r\n                    entity = null,\r\n                    node   = null;\r\n                \r\n                if (nodeDefinition.isNode) {// if it's already a node, put it on the map.\r\n                    node = nodeDefinition;\r\n                    nodeDefinition.map = this;\r\n                } else {\r\n                    node = Node.setUp(nodeDefinition, this);\r\n                }\r\n                \r\n                this.addNode(node);\r\n                \r\n                for (i = this.residentsAwaitingNode.length - 1; i >= 0; i--) {\r\n                    entity = this.residentsAwaitingNode[i];\r\n                    if (node.id === entity.nodeId) {\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.residentsAwaitingNode, i);\r\n                        entity.node = this.getNode(entity.nodeId);\r\n                        entity.triggerEvent('on-node', entity.node);\r\n                    }\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Checks the child entity for a nodeId and if found adds the child to the corresponding node.\r\n             *\r\n             * @method 'child-entity-added'\r\n             * @param entity {platypus.Entity} The entity that may be placed on a node, or if the entity is a node it is added to the map of nodes.\r\n             */\r\n            \"child-entity-added\": function (entity) {\r\n                if (entity.isNode) {        // a node\r\n                    this.owner.triggerEvent('add-node', entity);\r\n                } else if (entity.nodeId) { // a NodeResident\r\n                    entity.node = this.getNode(entity.nodeId);\r\n                    if (!entity.node) {\r\n                        this.residentsAwaitingNode.push(entity);\r\n                    } else {\r\n                        entity.triggerEvent('on-node', entity.node);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            addNode: function (node) {\r\n                this.map.push(node);\r\n                this.nodes[node.id] = node;\r\n            },\r\n            \r\n            destroy: function () {\r\n                var i = 0;\r\n                \r\n                // Destroy simple node objects.\r\n                for (i = 0; i < this.map.length; i++) {\r\n                    if (!(this.map[i] instanceof _Entity_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])) {\r\n                        this.map[i].recycle();\r\n                    }\r\n                }\r\n                \r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.map);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.residentsAwaitingNode);\r\n            }\r\n        },\r\n        \r\n        publicMethods: {\r\n            /**\r\n             * Gets a node by node id.\r\n             *\r\n             * @method getNode\r\n             * @param id {String|Array|Node} This id of the node to retrieve. If an array or more than one parameter is supplied, values are concatenated with \"|\" to create a single string id. Supplying a node returns the same node (useful for processing a mixed list of nodes and node ids).\r\n             */\r\n            getNode: function () {\r\n                var i       = 0,\r\n                    id      = '',\r\n                    divider = '',\r\n                    args    = arguments;\r\n                \r\n                if (args.length === 1) {\r\n                    if (args[0].isNode) {\r\n                        return args[0];\r\n                    } else if (Array.isArray(args[0])) {\r\n                        args = args[0];\r\n                    }\r\n                }\r\n                \r\n                for (i = 0; i < args.length; i++) {\r\n                    id += divider + args[i];\r\n                    divider = '|';\r\n                }\r\n\r\n                return this.nodes[id] || null;\r\n            },\r\n            \r\n            /**\r\n             * Finds the closest node to a given point, with respect to any inclusion or exclusion lists.\r\n             *\r\n             * method getClosestNode\r\n             * @param point {platypus.Vector} A location for which a closest node is being found.\r\n             * @param [including] {Array} A list of nodes to include in the search. If not set, the entire map is searched.\r\n             * @param [excluding] {Array} A list of nodes to exclude from the search.\r\n             */\r\n            getClosestNode: function (point, including, excluding) {\r\n                var i = 0,\r\n                    j = 0,\r\n                    p1 = _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(point),\r\n                    p2 = _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(),\r\n                    m = 0,\r\n                    list = including || this.map,\r\n                    closest = null,\r\n                    d = Infinity;\r\n                \r\n                for (i = 0; i < list.length; i++) {\r\n                    m = p2.setVector(p1).subtractVector(list[i].position).magnitude();\r\n                    if (m < d) {\r\n                        if (excluding) {\r\n                            j = excluding.indexOf(list[i]);\r\n                            if (j >= 0) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        \r\n                        d = m;\r\n                        closest = list[i];\r\n                    }\r\n                }\r\n                \r\n                p1.recycle();\r\n                p2.recycle();\r\n                \r\n                return closest;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/NodeMap.js?");

/***/ }),

/***/ "./src/components/NodeResident.js":
/*!****************************************!*\
  !*** ./src/components/NodeResident.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n# COMPONENT **NodeResident**\r\nThis component connects an entity to its parent's [[NodeMap]]. It manages navigating the NodeMap and triggering events on the entity related to its position.\r\n\r\n## Dependencies\r\n- [[NodeMap]] (on entity's parent) - This component uses the `NodeMap` to determine its location and navigate to other nodes.\r\n- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.\r\n\r\n## Messages\r\n\r\n### Listens for:\r\n- **handle-logic** - On a `tick` logic message, the component updates its location and triggers messages regarding its neighbors.\r\n  - @param message.delta (Number) - This component uses the current time to determine its progress along an edge if moving from node to node on the map.\r\n- **on-node** - Sets the entity's position to the sent node, updates its coordinates, and triggers messages regarding its neighbors if any.\r\n  - @param node (Node) - The node that this entity should be located on.\r\n- **leave-node** - Removes the entity from its current node if it's on one.\r\n- **goto-node** - Begins moving the entity along edges to get to sent node.\r\n  - @param node (Node) - The node that this entity should move to.\r\n- **follow** - Causes this entity to follow another entity. The leading entity must also have a `NodeResident` component and exist in the NodeMap.\r\n  - @param entity (Entity) - The entity that this entity should follow.\r\n\r\n### Local Broadcasts:\r\n- **next-to-[entity-type]** - This message is triggered when the entity is placed on a node. It will trigger on all neighboring entities, as well as on itself on behalf of neighboring entities.\r\n  - @param entity (Entity) - The entity that is next to the listening entity.\r\n- **with-[entity-type]** - This message is triggered when the entity is placed on a node. It will trigger on all entities residing on the same node, as well as on itself on behalf of all resident entities.\r\n  - @param entity (Entity) - The entity that is with the listening entity.\r\n- **left-node** - Triggered when the entity leaves a node.\r\n  - @param node (Node) - The node that the entity just left.\r\n- **[Messages specified in definition]** - When the entity is placed on a node, it checks out the type of node and triggers a message on the entity if an event is listed for the current node type.\r\n\r\n## States\r\n- **on-node** - This state is true when the entity is on a node.\r\n- **moving** - This state is true when the entity is moving from one node to another.\r\n- **going-[direction]** - This state is true when the entity is moving (or has just moved) in a direction (determined by the NodeMap) from one node to another.\r\n  \r\n## JSON Definition\r\n    {\r\n      \"type\": \"NodeResident\",\r\n      \r\n      \"nodeId\": \"city-hall\",\r\n      // Optional. The id of the node that this entity should start on. Uses the entity's nodeId property if not set here.\r\n      \r\n      \"nodes\": {\"path\": \"walking\", \"sidewalk\": \"walking\", \"road\": \"driving\"],\r\n      // Optional. This is a list of node types that this entity can reside on. If not set, entity can reside on any type of node.\r\n      \r\n      \"shares\": ['friends','neighbors','city-council-members'],\r\n      // Optional. This is a list of entities that this entity can reside with on the same node. If not set, this entity can reside with any entities on the same node.\r\n      \r\n      \"speed\": 5,\r\n      // Optional. Sets the speed with which the entity moves along an edge to an adjacent node. Default is 0 (instantaneous movement).\r\n      \r\n      \"updateOrientation\": true\r\n      // Optional. Determines whether the entity's orientation is updated by movement across the NodeMap. Default is false.\r\n    }\r\n*/\r\n\r\n/**\r\n * This component connects an entity to its parent's [[NodeMap]]. It manages navigating the NodeMap and triggering events on the entity related to its position.\r\n *\r\n * @namespace platypus.components\r\n * @class NodeResident\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var createGateway = function (nodeDefinition, map, gateway) {\r\n            return function () {\r\n                // ensure it's a node if one is available at this gateway\r\n                var node = map.getNode(nodeDefinition);\r\n\r\n                if (this.isPassable(node)) {\r\n                    this.destinationNodes.length = 0;\r\n                    this.destinationNodes.push(node);\r\n\r\n                    if (this.node) {\r\n                        this.onEdge(node);\r\n                    } else {\r\n                        this.distance = 0;\r\n                    }\r\n                    this.progress = 0;\r\n\r\n                    this.setState('going-' + gateway);\r\n                    return true;\r\n                }\r\n\r\n                return false;\r\n            };\r\n        },\r\n        distance = function (origin, destination) {\r\n            var x = destination.x - origin.x,\r\n                y = destination.y - origin.y,\r\n                z = destination.z - origin.z;\r\n\r\n            return Math.sqrt(x * x + y * y + z * z);\r\n        },\r\n        angle = function (origin, destination, distance, ratio) {\r\n            var x = destination.x - origin.x,\r\n                y = destination.y - origin.y,\r\n                a = 0;\r\n\r\n            if (origin.rotation && destination.rotation) {\r\n                x = (origin.rotation + 180) % 360;\r\n                y = (destination.rotation + 180) % 360;\r\n                return (x * (1 - ratio) + y * ratio + 180) % 360;\r\n            } else {\r\n                if (!distance) {\r\n                    return a;\r\n                }\r\n\r\n                a = Math.acos(x / distance);\r\n                if (y < 0) {\r\n                    a = (Math.PI * 2) - a;\r\n                }\r\n                return a * 180 / Math.PI;\r\n            }\r\n        },\r\n        axisProgress = function (r, o, d, f) {\r\n            return o * (1 - r) + d * r + f;\r\n        },\r\n        isFriendly = function (entities, kinds) {\r\n            var x = 0,\r\n                y = 0,\r\n                found = false;\r\n\r\n            if (kinds === null) {\r\n                return true;\r\n            }\r\n\r\n            for (x = 0; x < entities.length; x++) {\r\n                for (y = 0; y < kinds.length; y++) {\r\n                    if (entities[x].type === kinds[y]) {\r\n                        found = true;\r\n                    }\r\n                }\r\n                if (!found) {\r\n                    return false;\r\n                } else {\r\n                    found = false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'NodeResident',\r\n        \r\n        publicProperties: {\r\n\r\n            /**\r\n             * This describes the rate at which a node resident should progress along an edge to another node. This property is set on the entity itself and can be manipulated in real-time.\r\n             *\r\n             * @property speed\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            speed: 0\r\n        },\r\n        \r\n        initialize: function (definition) {\r\n            var offset = definition.offset || this.owner.nodeOffset || {};\r\n            \r\n            this.nodeId = this.owner.nodeId = definition.nodeId || this.owner.nodeId;\r\n            \r\n            this.neighbors = {};\r\n            this.friendlyNodes = definition.nodes || null;\r\n            this.friendlyEntities = definition.shares || null;\r\n            this.snapToNodes = definition.snapToNodes || false;\r\n            this.updateOrientation = definition.updateOrientation || false;\r\n            this.distance = 0;\r\n            this.buffer   = definition.buffer || 0;\r\n            this.progress = 0;\r\n            this.offset = {\r\n                x: offset.x || 0,\r\n                y: offset.y || 0,\r\n                z: offset.z || 0\r\n            };\r\n            this.destinationNodes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            this.algorithm = definition.algorithm || distance;\r\n            \r\n            this.state = this.owner.state;\r\n            this.state.set('moving', false);\r\n            this.state.set('on-node', false);\r\n            this.currentState = '';\r\n        },\r\n        \r\n        events: {\r\n            \"set-algorithm\": function (algorithm) {\r\n                this.algorithm = algorithm || distance;\r\n            },\r\n            \"handle-logic\": function (resp) {\r\n                var i = 0,\r\n                    ratio    = 0,\r\n                    momentum = 0,\r\n                    node     = null,\r\n                    arr = null;\r\n                \r\n                if (!this.owner.node) {\r\n                    arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(this.owner.x, this.owner.y);\r\n                    this.owner.triggerEvent('on-node', this.owner.parent.getClosestNode(arr));\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\r\n                    \r\n                    /**\r\n                     * This event is triggered if the entity is placed on the map but not assigned a node. It is moved to the nearest node and \"in-location\" is triggered.\r\n                     *\r\n                     * @event 'in-location'\r\n                     * @param entity {platypus.Entity} The entity that is in location.\r\n                     */\r\n                    this.owner.triggerEvent('in-location', this.owner);\r\n                }\r\n\r\n                if (this.followEntity) {\r\n                    node = this.followEntity.node || this.followEntity;\r\n                    if (node && node.isNode && (node !== this.node)) {\r\n                        this.lag = 0;\r\n                        this.state.set('moving', this.gotoNode());\r\n                        if (this.followDistance) {\r\n                            momentum = this.lag;\r\n                        }\r\n                    } else {\r\n                        this.followEntity = null;\r\n                    }\r\n                } else {\r\n                    momentum = this.speed * resp.delta;\r\n                }\r\n\r\n                // if goto-node was blocked, try again.\r\n                if (this.blocked) {\r\n                    this.blocked = false;\r\n                    if (this.goingToNode) {\r\n                        this.owner.triggerEvent('goto-closest-node', this.goingToNode);\r\n                    }\r\n                }\r\n                \r\n                if (this.destinationNodes.length) {\r\n                    this.state.set('moving', (this.speed !== 0));\r\n                    if (this.node) {\r\n                        this.onEdge(this.destinationNodes[0]);\r\n                    } else if (!this.lastNode) {\r\n                        this.owner.triggerEvent('on-node', this.destinationNodes[0]);\r\n                        this.destinationNodes.shift();\r\n                        if (!this.destinationNodes.length) {\r\n                            this.state.set('moving', false);\r\n                            return;\r\n                        }\r\n                    }\r\n                    \r\n                    if (this.snapToNodes) {\r\n                        for (i = 0; i < this.destinationNodes.length; i++) {\r\n                            this.owner.triggerEvent('on-node', this.destinationNodes[i]);\r\n                        }\r\n                        this.destinationNodes.length = 0;\r\n                    } else {\r\n                        while (this.destinationNodes.length && momentum) {\r\n                            if ((this.progress + momentum) >= this.distance) {\r\n                                node = this.destinationNodes[0];\r\n                                momentum -= (this.distance - this.progress);\r\n                                this.progress = 0;\r\n                                this.destinationNodes.shift();\r\n                                this.owner.triggerEvent('on-node', node);\r\n                                if (this.destinationNodes.length && momentum) {\r\n                                    this.onEdge(this.destinationNodes[0]);\r\n                                }\r\n                            } else {\r\n                                this.progress += momentum;\r\n                                ratio = this.progress / this.distance;\r\n                                this.owner.x = axisProgress(ratio, this.lastNode.x, this.destinationNodes[0].x, this.offset.x);\r\n                                this.owner.y = axisProgress(ratio, this.lastNode.y, this.destinationNodes[0].y, this.offset.y);\r\n                                this.owner.z = axisProgress(ratio, this.lastNode.z, this.destinationNodes[0].z, this.offset.z);\r\n                                if (this.updateOrientation) {\r\n                                    this.owner.rotation = angle(this.lastNode, this.destinationNodes[0], this.distance, ratio);\r\n                                }\r\n                                momentum = 0;\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.state.set('moving', false);\r\n                }\r\n            },\r\n            \"on-node\": function (node) {\r\n                var j = 0,\r\n                    entities = null;\r\n                \r\n                this.owner.node = this.node = node; //TODO: not sure if this needs to be accessible outside this component.\r\n                this.node.removeFromEdge(this.owner);\r\n                if (this.lastNode) {\r\n                    this.lastNode.removeFromEdge(this.owner);\r\n                }\r\n                this.node.addToNode(this.owner);\r\n                \r\n                this.setState('on-node');\r\n                \r\n                this.owner.x = this.node.x + this.offset.x;\r\n                this.owner.y = this.node.y + this.offset.y;\r\n                this.owner.z = this.node.z + this.offset.z;\r\n                if (this.updateOrientation && this.node.rotation) {\r\n                    this.owner.rotation = this.node.rotation;\r\n                }\r\n                \r\n                //add listeners for directions\r\n                this.owner.triggerEvent('set-directions');\r\n                \r\n                //trigger mapped messages for node types\r\n                if (this.friendlyNodes && this.friendlyNodes[node.type]) {\r\n                    this.owner.trigger(this.friendlyNodes[node.type], node);\r\n                }\r\n\r\n                //trigger \"with\" events\r\n                entities = node.contains;\r\n                for (j = 0; j < entities.length; j++) {\r\n                    if (this.owner !== entities[j]) {\r\n                        entities[j].triggerEvent(\"with-\" + this.owner.type, this.owner);\r\n                        this.owner.triggerEvent(\"with-\" + entities[j].type, entities[j]);\r\n                    }\r\n                }\r\n            },\r\n            \"leave-node\": function () {\r\n                if (this.node) {\r\n                    this.node.removeFromNode(this.owner);\r\n                    this.owner.triggerEvent('left-node', this.node);\r\n                    this.owner.triggerEvent('remove-directions');\r\n                }\r\n                this.lastNode = this.node;\r\n                this.node = null;\r\n            },\r\n            \"goto-node\": function (node) {\r\n                this.gotoNode(node);\r\n            },\r\n            \"follow\": function (entityOrNode) {\r\n                if (entityOrNode.entity) {\r\n                    this.followDistance = entityOrNode.distance;\r\n                    this.followEntity = entityOrNode.entity;\r\n                } else {\r\n                    this.followDistance = 0;\r\n                    this.followEntity = entityOrNode;\r\n                }\r\n            },\r\n            \"goto-closest-node\": (function () {\r\n                var checkList = function (here, list) {\r\n                        var i = 0;\r\n\r\n                        for (i = 0; i < list.length; i++) {\r\n                            if (list[i] === here) {\r\n                                return true;\r\n                            }\r\n                        }\r\n\r\n                        return false;\r\n                    },\r\n                    checkType = function (here, type) {\r\n                        return (here.type === type);\r\n                    },\r\n                    checkObjectType = function (here, node) {\r\n                        return (here.type === node.type);\r\n                    };\r\n                \r\n                return function (nodesOrNodeType) {\r\n                    var travResp = null,\r\n                        depth    = 20, //arbitrary limit\r\n                        origin   = this.node || this.lastNode,\r\n                        test     = null,\r\n                        steps    = nodesOrNodeType.steps || 0,\r\n                        nodes    = null;\r\n\r\n                    this.goingToNode = nodesOrNodeType;\r\n                    \r\n                    if (typeof nodesOrNodeType === 'string') {\r\n                        test = checkType;\r\n                    } else if (typeof nodesOrNodeType.type === 'string') {\r\n                        test = checkObjectType;\r\n                    } else {\r\n                        test = checkList;\r\n                    }\r\n                    \r\n                    if (origin && nodesOrNodeType && !test(origin, nodesOrNodeType)) {\r\n                        nodes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                        travResp = this.traverseNode({\r\n                            depth: depth,\r\n                            origin: origin,\r\n                            position: origin,\r\n                            test: test,\r\n                            destination: nodesOrNodeType,\r\n                            nodes: nodes,\r\n                            shortestPath: Infinity,\r\n                            distance: 0,\r\n                            found: false,\r\n                            algorithm: this.algorithm,\r\n                            blocked: false\r\n                        });\r\n                        \r\n                        travResp.distance -= this.progress;\r\n                        \r\n                        if (travResp.found) {\r\n                            //TODO: should probably set this up apart from this containing function\r\n                            if (this.followEntity) {\r\n                                if (!this.followDistance) {\r\n                                    this.setPath(travResp, steps);\r\n                                } else if ((travResp.distance + (this.followEntity.progress || 0)) > this.followDistance) {\r\n                                    this.lag = travResp.distance + (this.followEntity.progress || 0) - this.followDistance;\r\n                                    this.setPath(travResp, steps);\r\n                                } else {\r\n                                    this.lag = 0;\r\n                                }\r\n                            } else {\r\n                                this.setPath(travResp, steps);\r\n                            }\r\n                        } else if (travResp.blocked) {\r\n                            this.blocked = true;\r\n                        }\r\n                        \r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(nodes);\r\n                    }\r\n                };\r\n            }()),\r\n            \"set-directions\": function () {\r\n                var i = '',\r\n                    j = 0,\r\n                    entities = null,\r\n                    node     = this.node,\r\n                    nextNode = null;\r\n                \r\n                this.owner.triggerEvent('remove-directions');\r\n                \r\n                for (i in node.neighbors) {\r\n                    if (node.neighbors.hasOwnProperty(i)) {\r\n                        this.neighbors[i] = createGateway(node.neighbors[i], node.map, i);\r\n                        this.addEventListener(i, this.neighbors[i]);\r\n\r\n                        //trigger \"next-to\" events\r\n                        nextNode = node.map.getNode(node.neighbors[i]);\r\n                        if (nextNode) {\r\n                            entities = nextNode.contains;\r\n                            for (j = 0; j < entities.length; j++) {\r\n                                entities[j].triggerEvent(\"next-to-\" + this.owner.type, this.owner);\r\n                                this.owner.triggerEvent(\"next-to-\" + entities[j].type, entities[j]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            \"remove-directions\": function () {\r\n                var i = '';\r\n                \r\n                for (i in this.neighbors) {\r\n                    if (this.neighbors.hasOwnProperty(i)) {\r\n                        this.removeEventListener(i, this.neighbors[i]);\r\n                        delete this.neighbors[i];\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            gotoNode: (function () {\r\n                var test = function (here, there) {\r\n                    return (here === there);\r\n                };\r\n                \r\n                return function (node) {\r\n                    var travResp = null,\r\n                        depth = 20, //arbitrary limit\r\n                        origin = this.node || this.lastNode,\r\n                        nodes = null,\r\n                        moving = false;\r\n                    \r\n                    if (!node && this.followEntity) {\r\n                        node = this.followEntity.node || this.followEntity.lastNode || this.followEntity;\r\n                    }\r\n                    \r\n                    if (origin && node && (this.node !== node)) {\r\n                        nodes = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                        \r\n                        travResp = this.traverseNode({\r\n                            depth: depth,\r\n                            origin: origin,\r\n                            position: origin,\r\n                            test: test,\r\n                            destination: node,\r\n                            nodes: nodes,\r\n                            shortestPath: Infinity,\r\n                            distance: 0,\r\n                            found: false,\r\n                            algorithm: this.algorithm,\r\n                            blocked: false\r\n                        });\r\n                        \r\n                        travResp.distance -= this.progress;\r\n                        \r\n                        if (travResp.found) {\r\n                            //TODO: should probably set this up apart from this containing function\r\n                            if (this.followEntity) {\r\n                                if (!this.followDistance) {\r\n                                    this.setPath(travResp);\r\n                                    moving = true;\r\n                                } else if ((travResp.distance + (this.followEntity.progress || 0)) > this.followDistance) {\r\n                                    this.lag = travResp.distance + (this.followEntity.progress || 0) - this.followDistance;\r\n                                    this.setPath(travResp);\r\n                                    moving = true;\r\n                                } else {\r\n                                    this.lag = 0;\r\n                                }\r\n                            } else {\r\n                                this.setPath(travResp);\r\n                                moving = true;\r\n                            }\r\n                        } else if (travResp.blocked) {\r\n                            this.blocked = true;\r\n                        }\r\n                        \r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(nodes);\r\n                    }\r\n                    \r\n                    return moving;\r\n                };\r\n            }()),\r\n            \r\n            isPassable: function (node) {\r\n                return node && (this.node !== node) && (!this.friendlyNodes || (typeof this.friendlyNodes[node.type] !== 'undefined')) && (!node.contains.length || isFriendly(node.contains, this.friendlyEntities));\r\n            },\r\n            traverseNode: function (record) {\r\n                //TODO: may want to make this use A*. Currently node traversal order is arbitrary and essentially searches entire graph, but does clip out paths that are too long.\r\n                \r\n                var i         = 1,\r\n                    j         = '',\r\n                    map       = record.position.map,\r\n                    neighbors = null,\r\n                    node      = null,\r\n                    nodeList  = null,\r\n                    resp      = null,\r\n                    algorithm = record.algorithm || distance,\r\n                    savedResp = {\r\n                        shortestPath: Infinity,\r\n                        found: false,\r\n                        blocked: false\r\n                    },\r\n                    blocked   = true,\r\n                    hasNeighbor = false;\r\n\r\n                if ((record.depth === 0) || (record.distance > record.shortestPath)) {\r\n                    // if we've reached our search depth or are following a path longer than our recorded successful distance, bail\r\n                    return record;\r\n                } else if (record.test(record.position, record.destination)) {\r\n                    // if we've reached our destination, set shortest path information and bail.\r\n                    record.found = true;\r\n                    record.shortestPath = record.distance;\r\n                    return record;\r\n                } else {\r\n                    //Make sure we do not trace an infinite node loop.\r\n                    nodeList = record.nodes;\r\n                    for (i = 1; i < nodeList.length - 1; i++) {\r\n                        if (nodeList[i] === record.position) {\r\n                            return record;\r\n                        }\r\n                    }\r\n                        \r\n                    neighbors = record.position.neighbors;\r\n                    for (j in neighbors) {\r\n                        if (neighbors.hasOwnProperty(j)) {\r\n                            node = map.getNode(neighbors[j]);\r\n                            hasNeighbor = true;\r\n                            if (this.isPassable(node)) {\r\n                                nodeList = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(record.nodes);\r\n                                nodeList.push(node);\r\n                                resp = this.traverseNode({\r\n                                    depth: record.depth - 1,\r\n                                    origin: record.origin,\r\n                                    position: node,\r\n                                    destination: record.destination,\r\n                                    test: record.test,\r\n                                    algorithm: algorithm,\r\n                                    nodes: nodeList,\r\n                                    shortestPath: record.shortestPath,\r\n                                    distance: record.distance + algorithm(record.position, node),\r\n                                    gateway: record.gateway || j,\r\n                                    found: false,\r\n                                    blocked: false\r\n                                });\r\n                                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(nodeList);\r\n                                if (resp.found && (savedResp.shortestPath > resp.shortestPath)) {\r\n                                    savedResp = resp;\r\n                                }\r\n                                blocked = false;\r\n                            }\r\n                        }\r\n                    }\r\n                    savedResp.blocked = (hasNeighbor && blocked);\r\n                    return savedResp;\r\n                }\r\n            },\r\n            setPath: function (resp, steps) {\r\n                if (resp.nodes[0] === this.node) {\r\n                    resp.nodes.shift();\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.destinationNodes);\r\n                this.destinationNodes = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(resp.nodes);\r\n                if (steps) {\r\n                    this.destinationNodes.length = Math.min(steps, this.destinationNodes.length);\r\n                }\r\n            },\r\n            setState: function (state) {\r\n                if (state === 'on-node') {\r\n                    this.state.set('on-node', true);\r\n                } else {\r\n                    this.state.set('on-node', false);\r\n                    if (this.currentState) {\r\n                        this.state.set(this.currentState, false);\r\n                    }\r\n                    this.currentState = state;\r\n                    this.state.set(state, true);\r\n                }\r\n            },\r\n            onEdge: function (toNode) {\r\n                this.distance = distance(this.node, toNode);\r\n                if (this.updateOrientation) {\r\n                    this.owner.rotation = angle(this.node, toNode, this.distance, this.progress / this.distance);\r\n                }\r\n                this.node.addToEdge(this.owner);\r\n                toNode.addToEdge(this.owner);\r\n                this.owner.triggerEvent('leave-node');\r\n            },\r\n            destroy: function () {\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.destinationNodes);\r\n                this.destinationNodes = null;\r\n                this.state = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/NodeResident.js?");

/***/ }),

/***/ "./src/components/Orientation.js":
/*!***************************************!*\
  !*** ./src/components/Orientation.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/* harmony import */ var _utils_string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/string.js */ \"./src/utils/string.js\");\n/**\r\n * This component handles the orientation of an entity. It maintains an `orientationMatrix` property on the owner to describe the entity's orientation using an affine transformation matrix.\r\n *\r\n * Several methods on this component accept either a 3x3 2D Array or a string to describe orientation changes. Accepted strings include:\r\n *  - \"horizontal\"       - This flips the entity around the y-axis.\r\n *  - \"vertical\"         - This flips the entity around the x-axis.\r\n *  - \"diagonal\"         - This flips the entity around the x=y axis.\r\n *  - \"diagonal-inverse\" - This flips the entity around the x=-y axis.\r\n *  - \"rotate-90\"        - This rotates the entity 90 degrees clockwise.\r\n *  - \"rotate-180\"       - This rotates the entity 180 degrees clockwise (noticeable when tweening).\r\n *  - \"rotate-270\"       - This rotates the entity 90 degrees counter-clockwise.\r\n *\r\n * NOTE: This component absorbs specific properties already on the entity into orientation:\r\n *  - **orientationMatrix**: 3x3 2D array describing an affine transformation.\r\n *  - If the above is not provided, these properties are used to set initial orientation. This is useful when importing Tiled maps.\r\n *     - **scaleX**: absorb -1 if described\r\n *     - **scaleY**: absorb -1 if described\r\n *     - **rotation**: absorb 90 degree rotations\r\n *\r\n * @namespace platypus.components\r\n * @class Orientation\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var normal = _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(0, 0, 1),\r\n        origin = _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(1, 0, 0),\r\n        matrices = {\r\n            'identity': [[  1,  0,  0],\r\n                         [  0,  1,  0],\r\n                         [  0,  0,  1]],\r\n            'horizontal': [[ -1,  0,  0],\r\n                           [  0,  1,  0],\r\n                           [  0,  0, -1]],\r\n            'vertical': [[  1,  0,  0],\r\n                         [  0, -1,  0],\r\n                         [  0,  0, -1]],\r\n            'diagonal': [[  0,  1,  0],\r\n                         [  1,  0,  0],\r\n                         [  0,  0, -1]],\r\n            'diagonal-inverse': [[  0, -1,  0],\r\n                                 [ -1,  0,  0],\r\n                                 [  0,  0, -1]],\r\n            'rotate-90': [[  0, -1,  0],\r\n                          [  1,  0,  0],\r\n                          [  0,  0,  1]],\r\n            'rotate-180': [[ -1,  0,  0],\r\n                           [  0, -1,  0],\r\n                           [  0,  0,  1]],\r\n            'rotate-270': [[  0,  1,  0],\r\n                           [ -1,  0,  0],\r\n                           [  0,  0,  1]]\r\n        },\r\n        multiply = (function () {\r\n            var cell = function (row, column, m) {\r\n                var i = 0,\r\n                    sum = 0;\r\n\r\n                for (i = 0; i < row.length; i++) {\r\n                    sum += row[i] * m[i][column];\r\n                }\r\n\r\n                return sum;\r\n            };\r\n\r\n            return function (a, b, dest) {\r\n                var i   = 0,\r\n                    j   = 0,\r\n                    arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n\r\n                for (i = 0; i < a.length; i++) {\r\n                    for (j = 0; j < a[0].length; j++) {\r\n                        arr.push(cell(a[i], j, b));\r\n                    }\r\n                }\r\n\r\n                for (i = 0; i < a.length; i++) {\r\n                    for (j = 0; j < a[0].length; j++) {\r\n                        dest[i][j] = arr.shift();\r\n                    }\r\n                }\r\n                \r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\r\n            };\r\n        }()),\r\n        identitize = function (m) {\r\n            var i = 0,\r\n                j = 0;\r\n\r\n            for (i = 0; i < 3; i++) {\r\n                for (j = 0; j < 3; j++) {\r\n                    if (i === j) {\r\n                        m[i][j] = 1;\r\n                    } else {\r\n                        m[i][j] = 0;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return m;\r\n        };\r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'Orientation',\r\n        publicProperties: {\r\n            /**\r\n             * The Entity's scale along the X-axis will mirror the entity's initial orientation if it is negative. This value is available via `entity.scaleX`, but is not manipulated by this component after instantiation.\r\n             *\r\n             * @property scaleX\r\n             * @type number\r\n             * @default 1\r\n             */\r\n            \"scaleX\": 1,\r\n\r\n            /**\r\n             * The Entity's scale along the Y-axis will flip the entity's initial orientation if it is negative. This value is available via `entity.scaleY`, but is not manipulated by this component after instantiation.\r\n             *\r\n             * @property scaleY\r\n             * @type number\r\n             * @default 1\r\n             */\r\n            \"scaleY\": 1,\r\n\r\n            /**\r\n             * The Entity's rotation will rotate entity's initial orientation if it is a multiple of 90 degrees. This value is available via `entity.rotation`, but is not manipulated by this component after instantiation.\r\n             *\r\n             * @property rotation\r\n             * @type number\r\n             * @default 0\r\n             */\r\n            \"rotation\": 0,\r\n\r\n            /**\r\n             * The Entity's orientation is an angle in radians describing an entity's orientation around the Z-axis. This property is affected by a changing `entity.orientationMatrix` but does not itself change the orientation matrix.\r\n             *\r\n             * @property orientation\r\n             * @type number\r\n             * @default 0\r\n             */\r\n            \"orientation\": 0,\r\n            \r\n            /**\r\n             * The entity's orientation matrix determines the orientation of an entity and its vectors. It's a 3x3 2D Array describing an affine transformation of the entity.\r\n             *\r\n             * @property orientationMatrix\r\n             * @type Array\r\n             * @default 3x3 identity matrix\r\n             */\r\n            \"orientationMatrix\": null\r\n        },\r\n        initialize: (function () {\r\n            var setupOrientation = function (self, orientation) {\r\n                var vector = _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(1, 0, 0),\r\n                    owner  = self.owner,\r\n                    matrix = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(1, 0, 0),\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 1, 0),\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 0, 1)\r\n                    );\r\n                \r\n                Object.defineProperty(owner, 'orientationMatrix', {\r\n                    get: function () {\r\n                        multiply(self.matrixTween, self.matrix, identitize(matrix));\r\n                        return matrix;\r\n                    },\r\n                    enumerable: true\r\n                });\r\n\r\n                delete owner.orientation;\r\n                Object.defineProperty(owner, 'orientation', {\r\n                    get: function () {\r\n                        return vector.signedAngleTo(origin, normal);\r\n                    },\r\n                    set: function (value) {\r\n                        vector.setVector(origin).rotate(value);\r\n                    },\r\n                    enumerable: true\r\n                });\r\n\r\n                Object.defineProperty(owner, 'rotation', {\r\n                    get: function () {\r\n                        return owner.orientation / Math.PI * 180;\r\n                    },\r\n                    set: function (value) {\r\n                        owner.orientation = value * Math.PI / 180;\r\n                    },\r\n                    enumerable: true\r\n                });\r\n\r\n                if (orientation) {\r\n                    if (typeof orientation !== 'number') {\r\n                        vector.set(orientation);\r\n                    } else {\r\n                        vector.rotate(orientation);\r\n                    }\r\n                }\r\n\r\n                return vector;\r\n            };\r\n            \r\n            return function () {\r\n                this.loadedOrientationMatrix = this.orientationMatrix;\r\n                \r\n                // This is the stationary transform\r\n                this.matrix = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(1, 0, 0),\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 1, 0),\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 0, 1)\r\n                );\r\n                \r\n                // This is the tweening transform\r\n                this.matrixTween = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(1, 0, 0),\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 1, 0),\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 0, 1)\r\n                );\r\n                \r\n                this.relocationMessage = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\r\n                    \"position\", null\r\n                );\r\n                \r\n                this.vectors  = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                this.inverses = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                this.tweens   = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                \r\n                this.orientationVector = setupOrientation(this, this.orientation);\r\n                this.owner.triggerEvent('orient-vector', this.orientationVector);\r\n                \r\n                this.owner.state.set('reorienting', false);\r\n            };\r\n        }()),\r\n\r\n        events: {\r\n            /**\r\n             * This component listens for this event prior to loading initial transformations.\r\n             *\r\n             * @method 'load'\r\n             */\r\n            \"load\": function () {\r\n                if (this.loadedOrientationMatrix) {\r\n                    this.transform(this.loadedOrientationMatrix);\r\n                } else {\r\n                    if (this.scaleX && this.scaleX < 0) {\r\n                        this.scaleX = -this.scaleX;\r\n                        this.transform('horizontal');\r\n                    }\r\n                    if (this.scaleY && this.scaleY < 0) {\r\n                        this.scaleY = -this.scaleY;\r\n                        this.transform('vertical');\r\n                    }\r\n                    if (this.rotation) {\r\n                        if (((this.rotation + 270) % 360) === 0) {\r\n                            this.rotation = 0;\r\n                            this.transform('rotate-90');\r\n                        } else if (((this.rotation + 180) % 360) === 0) {\r\n                            this.rotation = 0;\r\n                            this.transform('rotate-180');\r\n                        } else if (((this.rotation + 90) % 360) === 0) {\r\n                            this.rotation = 0;\r\n                            this.transform('rotate-270');\r\n                        }\r\n                    }\r\n                }\r\n                delete this.loadedOrientationMatrix;\r\n            },\r\n            \r\n            /**\r\n             * On the 'handle-logic' event, this component updates any transformational tweening of the entity.\r\n             *\r\n             * @method 'handle-logic'\r\n             * @param tick.delta {number} Time passed since the last logic step.\r\n             */\r\n            \"handle-logic\": function (tick) {\r\n                var i = this.tweens.length,\r\n                    delta = tick.delta,\r\n                    state = this.owner.state,\r\n                    finishedTweening = null,\r\n                    tween = null,\r\n                    msg = this.relocationMessage;\r\n                \r\n                if (i) {\r\n                    finishedTweening = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                    state.set('reorienting', true);\r\n                    identitize(this.matrixTween);\r\n                    \r\n                    while (i--) {\r\n                        if (this.updateTween(this.tweens[i], delta)) { // finished tweening\r\n                            finishedTweening.push(Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.tweens, i));\r\n                        }\r\n                    }\r\n                    \r\n                    i = this.vectors.length;\r\n                    while (i--) {\r\n                        this.updateVector(this.vectors[i], this.inverses[i]);\r\n                    }\r\n                    \r\n                    i = finishedTweening.length;\r\n                    while (i--) {\r\n                        tween = finishedTweening[i];\r\n                        this.transform(tween.endMatrix);\r\n                        if (tween.anchor) {\r\n                            tween.offset.multiply(tween.endMatrix).addVector(tween.anchor);\r\n                            msg.position = tween.offset;\r\n                            this.owner.triggerEvent('relocate-entity', msg);\r\n                            if (tween.recycleOffset) {\r\n                                tween.offset.recycle();\r\n                            }\r\n                        }\r\n                        tween.onFinished(tween.endMatrix);\r\n                        tween.recycle();\r\n                    }\r\n                    \r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(finishedTweening);\r\n                } else if (state.get('reorienting')) {\r\n                    identitize(this.matrixTween);\r\n                    state.set('reorienting', false);\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, any currently running orientation tweens are immediately completed to give the entity a new stable position.\r\n             *\r\n             * @method 'complete-tweens'\r\n             * @since 0.7.1\r\n             */\r\n            \"complete-tweens\": function () {\r\n                var i = 0;\r\n                \r\n                for (i = 0; i < this.tweens.length; i++) {\r\n                    this.tweens[i].time = this.tweens[i].endTime;\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, any currently running orientation tweens are discarded, returning the entity to its last stable position.\r\n             *\r\n             * @method 'drop-tweens'\r\n             */\r\n            \"drop-tweens\": function () {\r\n                var i = 0;\r\n                \r\n                i = this.tweens.length;\r\n                while (i--) {\r\n                    if (this.tweens[i].offset) {\r\n                        this.tweens[i].offset.recycle();\r\n                    }\r\n                }\r\n                this.tweens.length = 0;\r\n                \r\n                i = this.vectors.length;\r\n                while (i--) {\r\n                    this.updateVector(this.vectors[i], this.inverses[i]);\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * On receiving a vector via this event, the component will transform the vector using the current orientation matrix and then store the vector and continue manipulating it as the orientation matrix changes.\r\n             *\r\n             * @method 'orient-vector'\r\n             * @param vector {platypus.Vector} The vector whose orientation will be maintained.\r\n             */\r\n            \"orient-vector\": function (vector) {\r\n                var aligned = vector.aligned || false;\r\n                \r\n                if (vector.vector) {\r\n                    vector = vector.vector;\r\n                }\r\n                \r\n                if (this.vectors.indexOf(vector) === -1) {\r\n                    if (!aligned) {\r\n                        vector.multiply(this.matrix);\r\n                    }\r\n                    this.vectors.push(vector);\r\n                    this.inverses.push(_Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp());\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, the maintained vector is immediately dropped from the list of maintained vectors.\r\n             *\r\n             * @method 'remove-vector'\r\n             * @param vector {platypus.Vector} The vector to be removed.\r\n             */\r\n            \"remove-vector\": function (vector) {\r\n                var i = this.vectors.indexOf(vector);\r\n                \r\n                if (i >= 0) {\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.vectors, i);\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.inverses, i).recycle();\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * This message causes the component to begin tweening the entity's orientation over a span of time into the new orientation.\r\n             *\r\n             * @method 'tween-transform'\r\n             * @param options {Object} A list of key/value pairs describing the tween options.\r\n             * @param options.matrix {Array} A transformation matrix: only required if `transform` is not provided\r\n             * @param options.transform {String} A transformation type: only required if `matrix` is not provided.\r\n             * @param options.time {number} The time over which the tween occurs. 0 makes it instantaneous.\r\n             * @param [options.anchor] {platypus.Vector} The anchor of the orientation change. If not provided, the owner's position is used.\r\n             * @param [options.offset] {platypus.Vector} If an anchor is supplied, this vector describes the entity's distance from the anchor. It defaults to the entity's current position relative to the anchor position.\r\n             * @param [options.angle] {number} Angle in radians to transform. This is only valid for rotations and is derived from the transform if not provided.\r\n             * @param [options.tween] {Function} A function describing the transition. Performs a linear transition by default. See CreateJS Ease for other options.\r\n             * @param [options.beforeTick] {Function} A function that should be processed before each tick as the tween occurs. This function should return `true`, otherwise the tween doesn't take a step.\r\n             * @param [options.afterTick] {Function} A function that should be processed after each tick as the tween occurs.\r\n             * @param [options.onFinished] {Function} A function that should be run once the transition is complete.\r\n             */\r\n            \"tween-transform\": (function () {\r\n                var doNothing = function () {\r\n                        // Doing nothing!\r\n                    },\r\n                    returnTrue = function () {\r\n                        return true;\r\n                    },\r\n                    linearEase = function (t) {\r\n                        return t;\r\n                    };\r\n\r\n                return function (props) {\r\n                    var arr = null,\r\n                        angle  = props.angle || 0,\r\n                        matrix = props.matrix,\r\n                        tween  = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\r\n                            \"transform\", props.transform,\r\n                            \"anchor\", props.anchor,\r\n                            \"endTime\", props.time || 0,\r\n                            \"time\", 0,\r\n                            \"tween\", props.tween || linearEase,\r\n                            \"onFinished\", props.onFinished || doNothing,\r\n                            \"beforeTick\", props.beforeTick || returnTrue,\r\n                            \"afterTick\", props.afterTick || doNothing\r\n                        );\r\n                    \r\n                    if (!matrix) {\r\n                        matrix = matrices[props.transform];\r\n                    }\r\n                    tween.endMatrix = matrix;\r\n                    \r\n                    if (!angle && (props.transform.indexOf('rotate') === 0)) {\r\n                        switch (props.transform) {\r\n                        case 'rotate-90':\r\n                            angle = Math.PI / 2;\r\n                            break;\r\n                        case 'rotate-180':\r\n                            angle = Math.PI;\r\n                            break;\r\n                        case 'rotate-270':\r\n                            angle = -Math.PI / 2;\r\n                            break;\r\n                        default:\r\n                            arr = Object(_utils_string_js__WEBPACK_IMPORTED_MODULE_3__[\"greenSplit\"])(props.transform, '-');\r\n                            angle = (arr[1] / 180) * Math.PI;\r\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\r\n                            break;\r\n                        }\r\n                    }\r\n                    tween.angle = angle;\r\n                    \r\n                    if (props.anchor) {\r\n                        tween.offset = props.offset;\r\n                        if (!tween.offset) {\r\n                            tween.offset = this.owner.position.copy().subtractVector(props.anchor, 2);\r\n                            tween.recycleOffset = true;\r\n                        }\r\n                    }\r\n                    \r\n                    this.tweens.push(tween);\r\n                };\r\n            }()),\r\n            \r\n            /**\r\n             * This message performs an immediate transform of the entity by performing the transformation via a prepended matrix multiplication.\r\n             *\r\n             * @method 'transform'\r\n             * @param transform {Array|String} A 3x3 @D Array or a string describing a transformation.\r\n             */\r\n            \"transform\": function (transform) {\r\n                this.transform(transform);\r\n            },\r\n            \r\n            /**\r\n             * This message performs an immediate transform of the entity by performing the transformation via a prepended matrix multiplication.\r\n             *\r\n             * @method 'prepend-transform'\r\n             * @param transform {Array|String} A 3x3 @D Array or a string describing a transformation.\r\n             */\r\n            \"prepend-transform\": function (transform) {\r\n                this.transform(transform);\r\n            },\r\n            \r\n            /**\r\n             * This message performs an immediate transform of the entity by performing the transformation via an appended matrix multiplication.\r\n             *\r\n             * @method 'append-transform'\r\n             * @param transform {Array|String} A 3x3 @D Array or a string describing a transformation.\r\n             */\r\n            \"append-transform\": function (transform) {\r\n                this.transform(transform, true);\r\n            },\r\n            \r\n            /**\r\n             * This message performs an immediate transform of the entity by returning the entity to an identity transform before performing a matrix multiplication.\r\n             *\r\n             * @method 'replace-transform'\r\n             * @param transform {Array|String} A 3x3 @D Array or a string describing a transformation.\r\n             */\r\n            \"replace-transform\": function (transform) {\r\n                if (Array.isArray(transform)) {\r\n                    this.replace(transform);\r\n                } else if (typeof transform === 'string') {\r\n                    if (matrices[transform]) {\r\n                        this.replace(matrices[transform]);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            transform: function (transform, append) {\r\n                if (Array.isArray(transform)) {\r\n                    this.multiply(transform, append);\r\n                } else if (typeof transform === 'string') {\r\n                    if (matrices[transform]) {\r\n                        this.multiply(matrices[transform], append);\r\n                    }\r\n                }\r\n            },\r\n            \r\n            multiply: (function () {\r\n                return function (m, append) {\r\n                    var i = 0;\r\n                    \r\n                    if (append) {\r\n                        multiply(this.matrix, m, this.matrix);\r\n                    } else {\r\n                        multiply(m, this.matrix, this.matrix);\r\n                    }\r\n                    \r\n                    for (i = 0; i < this.vectors.length; i++) {\r\n                        this.vectors[i].multiply(m);\r\n                        this.inverses[i].multiply(m);\r\n                    }\r\n                    \r\n                    /**\r\n                     * Once a transform is complete, this event is triggered to notify the entity of the completed transformation.\r\n                     *\r\n                     * @event 'orientation-updated'\r\n                     * @param matrix {Array} A 3x3 2D array describing the change in orientation.\r\n                     */\r\n                    this.owner.triggerEvent('orientation-updated', m);\r\n                };\r\n            }()),\r\n\r\n            replace: (function () {\r\n                var det2 = function (a, b, c, d) {\r\n                        return a * d - b * c;\r\n                    },\r\n                    det3 = function (a) {\r\n                        var i = 0,\r\n                            sum = 0;\r\n\r\n                        for (i = 0; i < 3; i++) {\r\n                            sum += a[i][0] * a[(i + 1) % 3][1] * a[(i + 2) % 3][2];\r\n                            sum -= a[i][2] * a[(i + 1) % 3][1] * a[(i + 2) % 3][0];\r\n                        }\r\n                        return sum;\r\n                    },\r\n                    invert = function (a) {\r\n                        var arr = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(), _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(), _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp()),\r\n                            inv = 1 / det3(a);\r\n\r\n                        arr[0].push(det2(a[1][1], a[1][2], a[2][1], a[2][2]) * inv);\r\n                        arr[0].push(det2(a[0][2], a[0][1], a[2][2], a[2][1]) * inv);\r\n                        arr[0].push(det2(a[0][1], a[0][2], a[1][1], a[1][2]) * inv);\r\n                        arr[1].push(det2(a[1][2], a[1][0], a[2][2], a[2][0]) * inv);\r\n                        arr[1].push(det2(a[0][0], a[0][2], a[2][0], a[2][2]) * inv);\r\n                        arr[1].push(det2(a[0][2], a[0][0], a[1][2], a[1][0]) * inv);\r\n                        arr[2].push(det2(a[1][0], a[1][1], a[2][0], a[2][1]) * inv);\r\n                        arr[2].push(det2(a[0][1], a[0][0], a[2][1], a[2][0]) * inv);\r\n                        arr[2].push(det2(a[0][0], a[0][1], a[1][0], a[1][1]) * inv);\r\n\r\n                        return arr;\r\n                    };\r\n                \r\n                return function (m) {\r\n                    var inversion = invert(this.matrix);\r\n                    \r\n                    // We invert the matrix so we can re-orient all vectors for the incoming replacement matrix.\r\n                    this.multiply(inversion);\r\n                    this.multiply(m);\r\n                    \r\n                    // clean-up\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(inversion, 2);\r\n                };\r\n            }()),\r\n            \r\n            updateTween: (function () {\r\n                var getMid = function (a, b, t) {\r\n                    return (a * (1 - t) + b * t);\r\n                };\r\n                \r\n                return function (tween, delta) {\r\n                    var t = 0,\r\n                        a = 1,                //  a c -\r\n                        b = 0,                //  b d -\r\n                        c = 0,                //  - - z\r\n                        d = 1,\r\n                        z = 1,\r\n                        angle = 0,\r\n                        m = tween.endMatrix,\r\n                        matrix = null,\r\n                        initialOffset = null,\r\n                        finalOffset = null;\r\n                    \r\n                    if (tween.beforeTick(tween.time)) {\r\n                        tween.time += delta;\r\n                    }\r\n                    \r\n                    if (tween.time >= tween.endTime) {\r\n                        return true;\r\n                    }\r\n                    \r\n                    t = tween.tween(tween.time / tween.endTime);\r\n                    \r\n                    if (tween.angle) {\r\n                        angle = t * tween.angle;\r\n                        a = d = Math.cos(angle);\r\n                        b = Math.sin(angle);\r\n                        c = -b;\r\n                    } else {\r\n                        a = getMid(a, m[0][0], t);\r\n                        b = getMid(b, m[1][0], t);\r\n                        c = getMid(c, m[0][1], t);\r\n                        d = getMid(d, m[1][1], t);\r\n                        z = getMid(z, m[2][2], t);\r\n                    }\r\n                    \r\n                    matrix = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(a, c, 0),\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(b, d, 0),\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(0, 0, z)\r\n                    );\r\n\r\n                    multiply(this.matrixTween, matrix, this.matrixTween);\r\n                    \r\n                    if (tween.anchor) {\r\n                        initialOffset = _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(tween.offset).multiply(1 - t);\r\n                        finalOffset = _Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(tween.offset).multiply(t);\r\n                        \r\n                        this.owner.triggerEvent('relocate-entity', {\r\n                            position: initialOffset.add(finalOffset).multiply(matrix).addVector(tween.anchor)\r\n                        });\r\n                        \r\n                        initialOffset.recycle();\r\n                        finalOffset.recycle();\r\n                    }\r\n\r\n                    tween.afterTick(t, matrix);\r\n                    \r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(matrix, 2);\r\n                    \r\n                    return false;\r\n                };\r\n            }()),\r\n            \r\n            updateVector: function (vector, inverse) {\r\n                inverse.setVector(vector.add(inverse)); // Inverses are stored to return to the original postion, *but* also allow outside changes on the vectors to be retained. This introduces floating point errors on tweened vectors. - DDD 2/10/2016\r\n                vector.multiply(this.matrixTween);\r\n                inverse.subtractVector(vector);\r\n            },\r\n            \r\n            destroy: function () {\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.vectors); this.vectors = null;\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.inverses); this.inverses = null;\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.tweens); this.tweens = null;\r\n                this.orientationVector.recycle(); this.orientationVector = null;\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.orientationMatrix, 2);/* this.orientationMatrix = null; - Only has a setter */\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.matrix, 2); this.matrix = null;\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.matrixTween, 2); this.matrixTween = null;\r\n                this.relocationMessage.recycle(); this.relocationMessage = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/Orientation.js?");

/***/ }),

/***/ "./src/components/RandomEvents.js":
/*!****************************************!*\
  !*** ./src/components/RandomEvents.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * This component listens for certain messages, picks a message from a related list of events, and triggers it. This is useful for adding random behaviors to an entity, such as having an entity say one thing from a list of audio clips. For example, defining this component on an Entity may look like this:\r\n * \r\n *     {\r\n *       \"type\": \"RandomEvents\",\r\n *       \r\n *       \"events\": {\r\n *       // This is a key/value list of events to listen for, with each event mapping to an array of events to pick from.\r\n *       \r\n *         \"make-sound\": [\"scream\", \"whisper\", \"talk\"]\r\n *         //on the component receiving the \"make-sound\" message, it will trigger one of the three possible messages listed here.\r\n *       }\r\n *     }\r\n *     \r\n * @namespace platypus.components\r\n * @class RandomEvents\r\n * @uses platypus.Component\r\n*/\r\n/*global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n\r\n    var createTrigger = function (eventList) {\r\n        return function (value, debug) {\r\n            this.owner.trigger(eventList[Math.floor(Math.random() * eventList.length)], value, debug);\r\n        };\r\n    };\r\n\r\n    return platypus.createComponentClass({\r\n        id: 'RandomEvents',\r\n        \r\n        initialize: function (definition) {\r\n            var event = '';\r\n            \r\n            if (definition.events) {\r\n                for (event in definition.events) {\r\n                    if (definition.events.hasOwnProperty(event)) {\r\n                        this.addEventListener(event, createTrigger(definition.events[event]));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RandomEvents.js?");

/***/ }),

/***/ "./src/components/RelativePosition.js":
/*!********************************************!*\
  !*** ./src/components/RelativePosition.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/**\r\n * This component positions an entity relative to the camera viewport, according to `left`, `top`, `right`, and `left` properties.\r\n *\r\n * @class RelativePosition\r\n * @uses platypus.Component\r\n * @since 1.0.0\r\n */\r\n/* global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'RelativePosition',\r\n\r\n        properties: {\r\n            /**\r\n             * This optional array sets varying properties depending on the aspect ratio of the camera. This is useful if the camera aspect ratio varies greatly and entities must be repositioned accordingly.\r\n             *\r\n             * In this example, the entity maintains a particular horizontal location until the camera viewport becomes narrower than 2:1, at which point it maintains a particular `left` value:\r\n             *\r\n             *      \"cameraSizes\": [{\r\n             *          \"minRatio\": 2, // This block applies for wide aspect ratios until 2:1 is reached.\r\n             *          \"x\": -1226\r\n             *      }, {\r\n             *          \"minRatio\": 0, // This block applies for everything else.\r\n             *          \"left\": 130\r\n             *      }]\r\n             *\r\n             * @property cameraSizes\r\n             * @type Array\r\n             * @default null\r\n             */\r\n            cameraSizes: null\r\n        },\r\n        \r\n        publicProperties: {\r\n            /**\r\n             * This sets the distance in world units from the bottom of the camera's world viewport. If set, it will override the entity's y coordinate. This property is accessible on the entity as `entity.bottom`.\r\n             *\r\n             * @property bottom\r\n             * @type Number\r\n             * @default null\r\n             */\r\n            \"bottom\": null,\r\n\r\n            /**\r\n             * This sets the distance in world units from the left of the camera's world viewport. If set, it will override the entity's x coordinate. This property is accessible on the entity as `entity.left`.\r\n             *\r\n             * @property left\r\n             * @type Number\r\n             * @default null\r\n             */\r\n            \"left\": null,\r\n\r\n            /**\r\n             * This sets the distance in world units from the right of the camera's world viewport. If set, it will override the entity's x coordinate. This property is accessible on the entity as `entity.right`.\r\n             *\r\n             * @property right\r\n             * @type Number\r\n             * @default null\r\n             */\r\n            \"right\": null,\r\n\r\n            /**\r\n             * This sets the distance in world units from the top of the camera's world viewport. If set, it will override the entity's y coordinate. This property is accessible on the entity as `entity.top`.\r\n             *\r\n             * @property top\r\n             * @type Number\r\n             * @default null\r\n             */\r\n            \"top\": null,\r\n\r\n            scaleX: 1,\r\n            scaleY: 1,\r\n\r\n            /**\r\n             * This sets the `x` coordinate for the entity. It is overridden by `left` and `right` properties if supplied.\r\n             *\r\n             * @property x\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            \"x\": 0,\r\n\r\n            /**\r\n             * This sets the `y` coordinate for the entity. It is overridden by `top` and `bottom` properties if supplied.\r\n             *\r\n             * @property y\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            \"y\": 0\r\n        },\r\n        \r\n        initialize: function (/*definition, callback*/) {\r\n            this.aabb = _AABB_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\r\n            this.lastBottom = null;\r\n            this.lastLeft = null;\r\n            this.lastRight = null;\r\n            this.lastTop = null;\r\n            this.cameraSizesIndex = -1;\r\n        },\r\n\r\n        events: {// These are messages that this component listens for\r\n            /**\r\n             * This component uses location updates to reposition the entity if its bottom, left, right, or top properties have been set.\r\n             *\r\n             * @method 'handle-logic'\r\n             */\r\n            \"handle-logic\": function () {\r\n                var bottom = this.bottom,\r\n                    left = this.left,\r\n                    right = this.right,\r\n                    top = this.top;\r\n\r\n                if ((this.lastBottom !== bottom) || (this.lastLeft !== left) || (this.lastRight !== right) || (this.lastTop !== top)) {\r\n                    this.updatePosition(this.aabb);\r\n                    this.lastBottom = bottom;\r\n                    this.lastLeft = left;\r\n                    this.lastRight = right;\r\n                    this.lastTop = top;\r\n                }\r\n            },\r\n\r\n            /**\r\n             * This component listens for camera updates to reposition the entity if its bottom, left, right, or top properties have been set.\r\n             *\r\n             * @method 'camera-update'\r\n             * @param camera {platypus.Data} Camera update information\r\n             * @param camera.viewport {platypus.AABB} The bounding box describing the camera viewport location in the world.\r\n             * @since 0.9.0\r\n             */\r\n            \"camera-update\": function (camera) {\r\n                this.aabb.set(camera.viewport);\r\n                if (this.cameraSizes) {\r\n                    this.checkCamera(this.aabb);\r\n                }\r\n                this.updatePosition(this.aabb);\r\n            }\r\n        },\r\n        \r\n        methods: {// These are internal methods that are invoked by this component.\r\n            checkCamera: function (aabb) {\r\n                var arr = this.cameraSizes,\r\n                    i = 0,\r\n                    ratio = aabb.width / aabb.height;\r\n\r\n                for (i = 0; i < arr.length; i++) {\r\n                    if (ratio > arr[i].minRatio) {\r\n                        if (i !== this.cameraSizesIndex) {\r\n                            this.updateProperties(arr[i]);\r\n                            this.cameraSizesIndex = i;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            },\r\n\r\n            updateProperties: function (props) {\r\n                this.right = (typeof props.right === 'number') ? props.right : null;\r\n                this.left = (typeof props.left === 'number') ? props.left : null;\r\n                this.top = (typeof props.top === 'number') ? props.top : null;\r\n                this.bottom = (typeof props.bottom === 'number') ? props.bottom : null;\r\n                if (typeof props.x === 'number') {\r\n                    this.x = props.x;\r\n                }\r\n                if (typeof props.y === 'number') {\r\n                    this.y = props.y;\r\n                }\r\n                if (typeof props.scaleX === 'number') {\r\n                    this.scaleX = props.scaleX;\r\n                }\r\n                if (typeof props.scaleY === 'number') {\r\n                    this.scaleY = props.scaleY;\r\n                }\r\n            },\r\n\r\n            updatePosition: function (vp) {\r\n                var bottom = this.bottom,\r\n                    left = this.left,\r\n                    owner = this.owner,\r\n                    right = this.right,\r\n                    top = this.top;\r\n\r\n                if (typeof left === 'number') {\r\n                    owner.x = vp.left + left;\r\n                } else if (typeof right === 'number') {\r\n                    owner.x = vp.right - right;\r\n                }\r\n\r\n                if (typeof top === 'number') {\r\n                    owner.y = vp.top + top;\r\n                } else if (typeof bottom === 'number') {\r\n                    owner.y = vp.bottom - bottom;\r\n                }\r\n            },\r\n\r\n            destroy: function () {\r\n                this.aabb.recycle();\r\n                this.aabb = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RelativePosition.js?");

/***/ }),

/***/ "./src/components/RelayFamily.js":
/*!***************************************!*\
  !*** ./src/components/RelayFamily.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n * This component allows an entity to communicate directly with one or more entities via the message model, by passing local messages directly to entities in the same family as new triggered events. This component is placed on a single entity and all entities created by this entity become part of its \"family\".\r\n *\r\n * @namespace platypus.components\r\n * @class RelayFamily\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        id: 'RelayFamily',\r\n        \r\n        properties: {\r\n            /**\r\n             * This is an object of key/value pairs. The keys are events this component is listening for locally, the value is the event that will be broadcast to its linked entities. The value can also be an array of events to be fired on linked entities.\r\n             *\r\n             *      \"events\": {\r\n             *          \"sleeping\": \"good-night\",\r\n             *          \"awake\": [\"alarm\", \"get-up\"]\r\n             *      }\r\n             *\r\n             * @property events\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            events: null\r\n        },\r\n\r\n        initialize: function () {\r\n            var event = '';\r\n            \r\n            if (this.events) {\r\n                for (event in this.events) {\r\n                    if (this.events.hasOwnProperty(event)) {\r\n                        this.addEventListener(event, this.broadcast.bind(this, null, this.events[event]));\r\n                    }\r\n                }\r\n            }\r\n    \r\n            this.owner.familyLinks = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(this.owner);\r\n        },\r\n        \r\n        events: {\r\n            /**\r\n             * Called when linking a new member to the family, this event accepts a list of family members from the new member and uses it to link all the family members together.\r\n             *\r\n             * @method 'link-family'\r\n             * @param links {Array|Entities} An array of entities.\r\n             */\r\n            \"link-family\": function (links) {\r\n                var i = 0,\r\n                    oldList = this.owner.familyLinks,\r\n                    newList = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(), links), oldList);\r\n\r\n                for (i = 0; i < newList.length; i++) {\r\n                    newList[i].familyLinks = newList;\r\n                }\r\n                this.broadcast(links,   'family-members-added', oldList);\r\n                this.broadcast(oldList, 'family-members-added', links);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(oldList);\r\n            },\r\n            \r\n            /**\r\n             * Called when this entity spawns a new entity, this event links the newly created entity to this entity.\r\n             *\r\n             * @method 'entity-created'\r\n             * @param entity {platypus.Entity} The entity to link.\r\n             */\r\n            \"entity-created\": function (entity) {\r\n                if (!entity.triggerEvent('link-family', this.owner.familyLinks)) {\r\n                    entity.addComponent(new platypus.components.RelayFamily(entity, {}));\r\n                    entity.triggerEvent('link-family', this.owner.familyLinks);\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            broadcast: function (links) {\r\n                var entities = links || this.owner.familyLinks,\r\n                    i = 0,\r\n                    args = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(arguments);\r\n\r\n                args.shift();\r\n\r\n                for (i = 0; i < entities.length; i++) {\r\n                    entities[i].trigger.apply(entities[i], args);\r\n                }\r\n                \r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(args);\r\n            },\r\n            \r\n            destroy: function () {\r\n                var familyLinks = this.owner.familyLinks,\r\n                    i = familyLinks.indexOf(this.owner);\r\n                \r\n                if (i >= 0) {\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(familyLinks, i);\r\n                }\r\n                this.broadcast(familyLinks, 'family-member-removed', this.owner);\r\n                this.events = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RelayFamily.js?");

/***/ }),

/***/ "./src/components/RelayGame.js":
/*!*************************************!*\
  !*** ./src/components/RelayGame.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * This component listens for specified local entity messages and re-broadcasts them at the scene level.\r\n *\r\n * @namespace platypus.components\r\n * @class RelayGame\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n\r\n    var broadcast = function () {\r\n        var currentScene = platypus.game.currentScene;\r\n        \r\n        currentScene.triggerOnChildren.apply(currentScene, arguments);\r\n    };\r\n\r\n    return platypus.createComponentClass({\r\n        id: 'RelayGame',\r\n        \r\n        properties: {\r\n            /**\r\n             * This is an object of key/value pairs. The keys are events this component is listening for locally, and the value is the event to be broadcast to the scene. The value can also be an array of events to be fired on the scene.\r\n             *\r\n             *      \"events\": {\r\n             *          \"sleeping\": \"good-night\",\r\n             *          \"awake\": [\"alarm\", \"get-up\"]\r\n             *      }\r\n             *\r\n             * @property events\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            events: null\r\n        },\r\n\r\n        initialize: function () {\r\n            var event = '',\r\n                events = this.events;\r\n            \r\n            // Messages that this component listens for and then broadcasts to all layers.\r\n            if (events) {\r\n                for (event in events) {\r\n                    if (events.hasOwnProperty(event)) {\r\n                        this.addEventListener(event, broadcast.bind(this, events[event]));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RelayGame.js?");

/***/ }),

/***/ "./src/components/RelayLinker.js":
/*!***************************************!*\
  !*** ./src/components/RelayLinker.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n * Allows an entity to communicate directly with one or more entities via the message model by passing local events directly to the linked entities as new triggered events.\r\n *\r\n * @namespace platypus.components\r\n * @class RelayLinker\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var broadcast = function () {\r\n        var i = 0,\r\n            link = null;\r\n        \r\n        for (i = 0; i < this.links.length; i++) {\r\n            link = this.links[i];\r\n            link.trigger.apply(link, arguments);\r\n        }\r\n    };\r\n\r\n    return platypus.createComponentClass({\r\n        id: 'RelayLinker',\r\n\r\n        properties: {\r\n            /**\r\n             * The id that defines the 'channel' the linkers are talking on. This should be matched on the entity/entities you want to talk between.\r\n             *\r\n             * @property linkId\r\n             * @type String\r\n             * @default 'linked'\r\n             */\r\n            linkId: 'linked',\r\n            \r\n            /**\r\n             * This is an object of key/value pairs. The keys are events this component is listening for locally, the value is the event to be broadcast to its linked entities. The value can also be an array of events to be fired on linked entities.\r\n             *\r\n             *      \"events\": {\r\n             *          \"sleeping\": \"good-night\",\r\n             *          \"awake\": [\"alarm\", \"get-up\"]\r\n             *      }\r\n             *\r\n             * @property events\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            events: null\r\n        },\r\n\r\n        initialize: function () {\r\n            var i = 0,\r\n                event = '';\r\n\r\n            if (this.events) {\r\n                for (event in this.events) {\r\n                    if (this.events.hasOwnProperty(event)) {\r\n                        this.addEventListener(event, broadcast.bind(this, this.events[event]));\r\n                    }\r\n                }\r\n            }\r\n            \r\n            if (!this.owner.linkId) {\r\n                this.owner.linkId = this.linkId;\r\n            }\r\n            \r\n            this.addEventListener('to-' + this.linkId + '-entities', broadcast.bind(this, 'from-' + this.linkId + '-entities'));\r\n            this.addEventListener('from-' + this.linkId + '-entities', function (resp) {\r\n                this.owner.trigger(resp.message, resp.value, resp.debug);\r\n            }.bind(this));\r\n            \r\n            this.links = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            \r\n            if (this.owner.linkEntities) {\r\n                for (i = 0; i < this.owner.linkEntities.length; i++) {\r\n                    this.links.push(this.owner.linkEntities[i]);\r\n                }\r\n            }\r\n            \r\n            this.message = {\r\n                message: '',\r\n                value: null\r\n            };\r\n            this.linkMessage = {\r\n                entity: this.owner,\r\n                linkId: this.linkId,\r\n                reciprocate: false\r\n            };\r\n        },\r\n        \r\n        events: {\r\n\r\n            /**\r\n             * Called when the object is added to its parent, on receiving this message, the component tries to link itself with objects with the same link id.\r\n             *\r\n             * @method 'load'\r\n             */\r\n            \"load\": function () {\r\n                var grandparent = this.owner.parent;\r\n\r\n                while (grandparent.parent) {\r\n                    grandparent = grandparent.parent;\r\n                }\r\n                this.linkMessage.reciprocate = true;\r\n                grandparent.triggerOnChildren('link-entity', this.linkMessage);\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, this component checks the linkId of the requesting entity and adds it to its list of connections if it matches.\r\n             *\r\n             * @method 'link-entity'\r\n             * @param toLink {platypus.Entity} The enquiring entity.\r\n             */\r\n            \"link-entity\": function (toLink) {\r\n                if ((toLink.linkId === this.linkId) && (toLink.entity !== this.owner)) {\r\n                    // Make sure this link is not already in place\r\n                    if (this.links.indexOf(toLink.entity) === -1) {\r\n                        this.links.push(toLink.entity);\r\n                        if (toLink.reciprocate) {\r\n                            this.linkMessage.reciprocate = false;\r\n                            toLink.entity.triggerEvent('link-entity', this.linkMessage);\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * Removes the requesting entity from this component's list of linked entities and no farther messages will be transmitted.\r\n             *\r\n             * @method 'unlink-entity'\r\n             * @param toUnlink {platypus.Entity} The enquiring entity.\r\n             */\r\n            \"unlink-entity\": function (toUnlink) {\r\n                var i = this.links.indexOf(toUnlink.entity);\r\n                \r\n                if (i >= 0) {\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(this.links, i);\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                var i = 0;\r\n                \r\n                for (i = 0; i < this.links.length; i++) {\r\n                    this.links[i].triggerEvent('unlink-entity', this.linkMessage);\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.links);\r\n                this.links = null;\r\n                this.events = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RelayLinker.js?");

/***/ }),

/***/ "./src/components/RelayParent.js":
/*!***************************************!*\
  !*** ./src/components/RelayParent.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * This component listens for specified local entity messages and re-broadcasts them on its parent entity.\r\n *\r\n * @namespace platypus.components\r\n * @class RelayParent\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n\r\n    var broadcast = function () {\r\n        var parent = this.owner.parent;\r\n        \r\n        if (parent) {\r\n            parent.trigger.apply(parent, arguments);\r\n        }\r\n    };\r\n    \r\n    return platypus.createComponentClass({\r\n        id: 'RelayParent',\r\n        \r\n        properties: {\r\n            /**\r\n             * This is an object of key/value pairs. The keys are events this component is listening for locally, and the value is the event to be broadcast on the parent. The value can also be an array of events to be triggered on the parent.\r\n             *\r\n             *      \"events\": {\r\n             *          \"sleeping\": \"good-night\",\r\n             *          \"awake\": [\"alarm\", \"get-up\"]\r\n             *      }\r\n             *\r\n             * @property events\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            events: null\r\n        },\r\n\r\n        initialize: function () {\r\n            var event = '',\r\n                events = this.events;\r\n            \r\n            // Messages that this component listens for and then broadcasts to parent.\r\n            if (events) {\r\n                for (event in events) {\r\n                    if (events.hasOwnProperty(event)) {\r\n                        this.addEventListener(event, broadcast.bind(this, events[event]));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RelayParent.js?");

/***/ }),

/***/ "./src/components/RelaySelf.js":
/*!*************************************!*\
  !*** ./src/components/RelaySelf.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * This component listens for specified local entity messages and re-broadcasts them on itself as other messages.\r\n *\r\n * @namespace platypus.components\r\n * @class RelaySelf\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n    \r\n    var trigger = function () {\r\n        var owner = this.owner;\r\n        \r\n        owner.trigger.apply(owner, arguments);\r\n    };\r\n\r\n    return platypus.createComponentClass({\r\n        id: 'RelaySelf',\r\n        \r\n        properties: {\r\n            /**\r\n             * This is an object of key/value pairs. The keys are events this component is listening for locally, the value is the new event to be broadcast on this entity. The value can also be an array of events to be fired.\r\n             *\r\n             *      \"events\": {\r\n             *          \"sleeping\": \"good-night\",\r\n             *          \"awake\": [\"alarm\", \"get-up\"]\r\n             *      }\r\n             *\r\n             * @property events\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            events: null\r\n        },\r\n\r\n        initialize: function () {\r\n            var event = '',\r\n                events = this.events;\r\n            \r\n            // Messages that this component listens for and then triggers on itself as a renamed message - useful as a logic place-holder for simple entities.\r\n            if (events) {\r\n                for (event in events) {\r\n                    if (events.hasOwnProperty(event)) {\r\n                        this.addEventListener(event, trigger.bind(this, events[event]));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RelaySelf.js?");

/***/ }),

/***/ "./src/components/RenderAnimator.js":
/*!******************************************!*\
  !*** ./src/components/RenderAnimator.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../StateMap.js */ \"./src/StateMap.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n * This component is typically added to an entity automatically by a render component. It handles mapping entity states and events to playable animations.\r\n *\r\n * @class RenderAnimator\r\n * @uses platypus.Component\r\n * @since 1.0.0\r\n */\r\n/*global platypus */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var createTest = function (testStates, animation) {\r\n            if (testStates === 'default') {\r\n                return defaultTest.bind(null, animation);\r\n            } else {\r\n                //TODO: Better clean-up: Create a lot of these without removing them later... DDD 2/5/2016\r\n                return stateTest.bind(null, animation, _StateMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(testStates));\r\n            }\r\n        },\r\n        defaultTest = function (animation) {\r\n            return animation;\r\n        },\r\n        methodPlay = function (animation, restart) {\r\n            this.component.playAnimation(animation, restart);\r\n        },\r\n        methodStop = function (animation) {\r\n            this.component.stopAnimation(animation);\r\n        },\r\n        stateTest = function (animation, states, ownerState) {\r\n            if (ownerState.includes(states)) {\r\n                return animation;\r\n            }\r\n            return false;\r\n        },\r\n        triggerPlay = function (animation, restart) {\r\n            /**\r\n             * On entering a new animation-mapped state, this component triggers this event to play an animation.\r\n             *\r\n             * @event 'play-animation'\r\n             * @param animation {String} Describes the animation to play.\r\n             * @param restart {Boolean} Whether to restart a playing animation.\r\n             */\r\n            this.owner.triggerEvent('play-animation', animation, restart);\r\n        },\r\n        triggerStop = function (animation) {\r\n            /**\r\n             * On attaining an animation-mapped state, this component triggers this event to stop a previous animation.\r\n             *\r\n             * @event 'stop-animation'\r\n             * @param animation {String} Describes the animation to stop.\r\n             */\r\n            this.owner.triggerEvent('stop-animation', animation);\r\n        };\r\n\r\n    return platypus.createComponentClass({\r\n        id: 'RenderAnimator',\r\n\r\n        properties: {\r\n            /**\r\n             * An object containg key-value pairs that define a mapping from entity states to the animation that should play. The list is processed from top to bottom, so the most important actions should be listed first (for example, a jumping animation might take precedence over an idle animation). If not specified, an 1-to-1 animation map is created from the list of animations in the sprite sheet definition using the animation names as the keys.\r\n             *\r\n             *  \"animationStates\":{\r\n             *      \"standing\": \"default-animation\"  // On receiving a \"standing\" event, or when this.owner.state.standing === true, the \"default\" animation will begin playing.\r\n             *      \"ground,moving\": \"walking\",  // Comma separated values have a special meaning when evaluating \"state-changed\" messages. The above example will cause the \"walking\" animation to play ONLY if the entity's state includes both \"moving\" and \"ground\" equal to true.\r\n             *      \"ground,striking\": \"swing!\", // Putting an exclamation after an animation name causes this animation to complete before going to the next animation. This is useful for animations that would look poorly if interrupted.\r\n             *      \"default\": \"default-animation\" // Optional. \"default\" is a special property that matches all states. If none of the above states are valid for the entity, it will use the default animation listed here.\r\n             *  }\r\n             *\r\n             * @property animationStates\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            animationStates: null,\r\n\r\n            /**\r\n             * An object containg key-value pairs that define a mapping from triggered events to the animation that should play.\r\n             *\r\n             *     \"animationEvents\":{\r\n             *         \"move\": \"walk-animation\",\r\n             *         \"jump\": \"jumping-animation\"\r\n             *     }\r\n             *\r\n             * The above will create two event listeners on the entity, \"move\" and \"jump\", that will play their corresponding animations when the events are triggered.\r\n             *\r\n             * @property animationEvents\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            animationEvents: null,\r\n\r\n            /**\r\n             * Sets a component that this component should be connected to.\r\n             *\r\n             * @property component\r\n             * @type Component\r\n             * @default null\r\n             * @since 0.9.2\r\n             */\r\n            component: null,\r\n\r\n            /**\r\n             * Optional. Forces animations to complete before starting a new animation. Defaults to `false`.\r\n             *\r\n             * @property forcePlayThrough\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            forcePlayThrough: false,\r\n\r\n            /**\r\n             * Whether to restart a playing animation on event.\r\n             *\r\n             * @property restart\r\n             * @type Boolean\r\n             * @default true\r\n             * @since 0.9.2\r\n             */\r\n            restart: true\r\n        },\r\n\r\n        initialize: (function () {\r\n            const\r\n                trigger = function (animation, restart) {\r\n                    /**\r\n                     * On receiving an animation-mapped event, this component triggers this event to play an animation.\r\n                     *\r\n                     * @event 'play-animation'\r\n                     * @param animation {String} Describes the animation to play.\r\n                     * @param restart {Boolean} Whether to restart a playing animation.\r\n                     */\r\n                    this.override = animation;\r\n                    this.owner.triggerEvent('play-animation', animation, restart);\r\n                },\r\n                method = function (animation, restart) {\r\n                    this.override = animation;\r\n                    this.playAnimation(animation, restart);\r\n                };\r\n\r\n            return function () {\r\n                const\r\n                    events = this.animationEvents,\r\n                    states = this.animationStates;\r\n\r\n                //Handle Events:\r\n                this.override = false;\r\n                if (events) {\r\n                    for (const animation in events) {\r\n                        if (events.hasOwnProperty(animation)) {\r\n                            if (this.component) {\r\n                                this.addEventListener(animation, method.bind(this.component, events[animation], this.restart));\r\n                            } else {\r\n                                this.addEventListener(animation, trigger.bind(this, events[animation], this.restart));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                //Handle States:\r\n                this.followThroughs = {};\r\n                this.checkStates = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n                this.state = this.owner.state;\r\n                this.stateChange = true; //Check state against entity's prior state to update animation if necessary on instantiation.\r\n                this.lastState = -1;\r\n\r\n                if (states) {\r\n                    for (const anim in states) {\r\n                        if (states.hasOwnProperty(anim)) {\r\n                            const animation = states[anim];\r\n\r\n                            //TODO: Should probably find a cleaner way to accomplish this. Maybe in the animationMap definition? - DDD\r\n                            if (animation[animation.length - 1] === '!') {\r\n                                animation = animation.substring(0, animation.length - 1);\r\n                                this.followThroughs[animation] = true;\r\n                            } else {\r\n                                this.followThroughs[animation] = false;\r\n                            }\r\n\r\n                            this.checkStates.push(createTest(anim, animation));\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.waitingAnimation = false;\r\n                this.waitingState = 0;\r\n                this.playWaiting = false;\r\n                this.animationFinished = false;\r\n\r\n                if (this.component) {\r\n                    this.playAnimation = methodPlay;\r\n                    this.stopAnimation = methodStop;\r\n                } else {\r\n                    this.playAnimation = triggerPlay;\r\n                    this.stopAnimation = triggerStop;\r\n                }\r\n            };\r\n        } ()),\r\n\r\n        events: {\r\n            /**\r\n             * This listens for the entity state to change and will update the currently playing animation.\r\n             *\r\n             * @method 'state-changed'\r\n             */\r\n            \"state-changed\": function () {\r\n                this.stateChange = true;\r\n            },\r\n\r\n            /**\r\n             * On receiving this event, the component checks for any waiting animations and begins playing them if so.\r\n             *\r\n             * @method 'animation-ended'\r\n             * @param animation {String} The animation that completed.\r\n             */\r\n            \"animation-ended\": function (animation) {\r\n                if (animation === this.currentAnimation) {\r\n                    if (this.override && (animation === this.override)) {\r\n                        this.stateChange = true;\r\n                        this.override = false;\r\n                    }\r\n\r\n                    if (this.waitingAnimation) {\r\n                        this.currentAnimation = this.waitingAnimation;\r\n                        this.waitingAnimation = false;\r\n                        this.lastState = this.waitingState;\r\n                        \r\n                        this.animationFinished = false;\r\n                        this.playAnimation(this.currentAnimation);\r\n                    } else {\r\n                        this.animationFinished = true;\r\n                    }\r\n                }\r\n            },\r\n\r\n            /**\r\n             * This checks to determine whether another animation should begin playing.\r\n             *\r\n             * @method update-animation\r\n             * @param playing {Boolean} Whether the new animation should play or pause on the first frame.\r\n             */\r\n            \"update-animation\": function (playing) {\r\n                var i = 0,\r\n                    testCase = false;\r\n\r\n                if (this.stateChange && !this.override) {\r\n                    if (this.state.has('visible')) {\r\n                        this.visible = this.state.get('visible');\r\n                    }\r\n                    for (i = 0; i < this.checkStates.length; i++) {\r\n                        testCase = this.checkStates[i](this.state);\r\n                        if (testCase) {\r\n                            if (this.currentAnimation !== testCase) {\r\n                                if (!this.followThroughs[this.currentAnimation] && (!this.forcePlaythrough || (this.animationFinished || (this.lastState >= +i)))) {\r\n                                    this.currentAnimation = testCase;\r\n                                    this.lastState = +i;\r\n                                    this.animationFinished = false;\r\n                                    if (playing) {\r\n                                        this.playAnimation(this.currentAnimation);\r\n                                    } else {\r\n                                        this.stopAnimation(this.currentAnimation);\r\n                                    }\r\n                                } else {\r\n                                    this.waitingAnimation = testCase;\r\n                                    this.waitingState = +i;\r\n                                }\r\n                            } else if (this.waitingAnimation && !this.followThroughs[this.currentAnimation]) {// keep animating this animation since this animation has already overlapped the waiting animation.\r\n                                this.waitingAnimation = false;\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                    this.stateChange = false;\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            toJSON: function () { // This component is added by another component, so it shouldn't be returned for reconstruction.\r\n                return null;\r\n            },\r\n\r\n            destroy: function () {\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.checkStates);\r\n                this.checkStates = null;\r\n                this.followThroughs = null;\r\n                this.state = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderAnimator.js?");

/***/ }),

/***/ "./src/components/RenderContainer.js":
/*!*******************************************!*\
  !*** ./src/components/RenderContainer.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _Interactive_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Interactive.js */ \"./src/components/Interactive.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _utils_string_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/string.js */ \"./src/utils/string.js\");\n/**\r\n * This component is attached to entities that will appear in the game world. It creates a PIXI Container to contain all other display objects on the entity and keeps the container updates with the entity's location and other dynamic properties.\r\n *\r\n * @namespace platypus.components\r\n * @class RenderContainer\r\n * @uses platypus.Component\r\n * @since 0.11.0\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var ColorMatrixFilter = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"filters\"].ColorMatrixFilter,\r\n        pixiMatrix = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"](),\r\n        castValue = function (color) {\r\n            if (color === null) {\r\n                return color;\r\n            }\r\n            if ((typeof color === 'string') && (color[0] === '#')) {\r\n                color = '0x' + color.substring(1);\r\n            }\r\n            return +color;\r\n        },\r\n        processGraphics = (function () {\r\n            var process = function (gfx, value) {\r\n                var i = 0,\r\n                    paren  = value.indexOf('('),\r\n                    func   = value.substring(0, paren),\r\n                    values = value.substring(paren + 1, value.indexOf(')')),\r\n                    polyRay = false;\r\n\r\n                if (values.length) {\r\n                    if (values[0] === '[') {\r\n                        values = values.substring(1, values.length - 1);\r\n                        polyRay = true;\r\n                    }\r\n                    values = Object(_utils_string_js__WEBPACK_IMPORTED_MODULE_5__[\"greenSplit\"])(values, ',');\r\n                    i = values.length;\r\n                    while (i--) {\r\n                        values[i] = +values[i];\r\n                    }\r\n                    if (polyRay) {\r\n                        gfx[func](values);\r\n                    } else {\r\n                        gfx[func].apply(gfx, values);\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_4__[\"arrayCache\"].recycle(values); // cannot recycle polygon above since it's used by the polygon shape.\r\n                    }\r\n                } else {\r\n                    gfx[func]();\r\n                }\r\n            };\r\n\r\n            return function (gfx, value) {\r\n                var i = 0,\r\n                    arr = Object(_utils_string_js__WEBPACK_IMPORTED_MODULE_5__[\"greenSplit\"])(value, '.');\r\n\r\n                for (i = 0; i < arr.length; i++) {\r\n                    process(gfx, arr[i]);\r\n                }\r\n                \r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_4__[\"arrayCache\"].recycle(arr);\r\n            };\r\n        }());\r\n    \r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'RenderContainer',\r\n        \r\n        properties: {\r\n            /**\r\n             * Optional. A mask definition that determines where the image should clip. A string can also be used to create more complex shapes via the PIXI graphics API like: \"mask\": \"r(10,20,40,40).drawCircle(30,10,12)\". Defaults to no mask or, if simply set to true, a rectangle using the entity's dimensions. Note that the mask is in world coordinates by default. To make the mask local to the entity's coordinates, set `localMask` to `true` in the RenderContainer properties.\r\n             *\r\n             *  \"mask\": {\r\n             *      \"x\": 10,\r\n             *      \"y\": 10,\r\n             *      \"width\": 40,\r\n             *      \"height\": 40\r\n             *  },\r\n             *\r\n             *  -OR-\r\n             *\r\n             *  \"mask\": \"r(10,20,40,40).drawCircle(30,10,12)\"\r\n             *\r\n             * @property mask\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            mask: null,\r\n\r\n            /**\r\n             * Defines whether the entity will respond to touch and click events. Setting this value will create an Interactive component on this entity with these properties. For example:\r\n             *\r\n             *  \"interactive\": {\r\n             *      \"hover\": false,\r\n             *      \"hitArea\": {\r\n             *          \"x\": 10,\r\n             *          \"y\": 10,\r\n             *          \"width\": 40,\r\n             *          \"height\": 40\r\n             *      }\r\n             *  }\r\n             *\r\n             * @property interactive\r\n             * @type Boolean|Object\r\n             * @default false\r\n             * @since 0.9.0\r\n             */\r\n            interactive: false,\r\n\r\n            /**\r\n             * Optional. What field this object should use to rotate.\r\n             *\r\n             * @property rotate\r\n             * @type String\r\n             * @default 'rotation'\r\n             */\r\n            rotate: 'rotation',\r\n\r\n            /**\r\n             * Whether this object can be mirrored over X. To mirror it over X set the this.owner.rotation value to be > 90  and < 270.\r\n             *\r\n             * @property mirror\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            mirror: false,\r\n\r\n            /**\r\n             * Optional. Whether this object can be flipped over Y. To flip it over Y set the this.owner.rotation to be > 180.\r\n             *\r\n             * @property flip\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            flip: false,\r\n\r\n            /**\r\n             * Optional. Whether this object is visible or not. To change the visible value dynamically set this.owner.state.visible to true or false.\r\n             *\r\n             * @property visible\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            visible: true,\r\n\r\n            /**\r\n             * Optional. Whether this sprite should be cached into an entity with a `RenderTiles` component (like \"render-layer\"). The `RenderTiles` component must have its \"entityCache\" property set to `true`. Warning! This is a one-direction setting and will remove this component from the entity once the current frame has been cached.\r\n             *\r\n             * @property cache\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            cache: false,\r\n\r\n            /**\r\n             * Optional. Ignores the opacity of the owner.\r\n             *\r\n             * @property ignoreOpacity\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            ignoreOpacity: false,\r\n\r\n            /**\r\n             * Whether the mask should be relative to the entity's coordinates.\r\n             *\r\n             * @property localMask\r\n             * @type boolean\r\n             * @default false\r\n             */\r\n            localMask: false\r\n        },\r\n\r\n        publicProperties: {\r\n            /**\r\n             * Prevents sprite from becoming invisible out of frame and losing mouse input connection.\r\n             *\r\n             * @property dragMode\r\n             * @type Boolean\r\n             * @default false\r\n             * @since 0.8.3\r\n             */\r\n            dragMode: false,\r\n\r\n            /**\r\n             * The entity or id of the entity that will act as the parent container. If not set, the entity will be rendered in the layer's container.\r\n             *\r\n             * @property renderParent\r\n             * @type String|Object\r\n             * @default null\r\n             * @since 2.0.0\r\n             */\r\n            renderParent: null,\r\n\r\n            /**\r\n             * Optional. The rotation of the sprite in degrees. All sprites on the same entity are rotated the same amount unless they ignore the rotation value by setting 'rotate' to \"\".\r\n             *\r\n             * Boolean values for the \"rotate\" property has been deprecated. Use \"rotation\" or \"orientationMatrix\" to specify the source of rotation for the render container.\r\n             *\r\n             * @property rotation\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            rotation: 0,\r\n\r\n            /**\r\n             * Optional. The X scaling factor for the image. Defaults to 1.\r\n             *\r\n             * @property scaleX\r\n             * @type Number\r\n             * @default 1\r\n             */\r\n            scaleX: 1,\r\n\r\n            /**\r\n             * Optional. The Y scaling factor for the image. Defaults to 1.\r\n             *\r\n             * @property scaleY\r\n             * @type Number\r\n             * @default 1\r\n             */\r\n            scaleY: 1,\r\n\r\n            /**\r\n             * Optional. The X skew factor of the sprite. Defaults to 0.\r\n             *\r\n             * @property skewX\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            skewX: 0,\r\n\r\n            /**\r\n             * Optional. The Y skew factor for the image. Defaults to 0.\r\n             *\r\n             * @property skewY\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            skewY: 0,\r\n\r\n            /**\r\n             * Optional. The tint applied to the sprite. Tint may be specified by number or text. For example, to give the sprite a red tint, set to 0xff0000 or \"#ff0000\". Tint will be stored as a number even when set using text. Defaults to no tint.\r\n             *\r\n             * @property tint\r\n             * @type Number|String\r\n             * @default null\r\n             */\r\n            tint: null,\r\n\r\n            /**\r\n             * Optional. The x position of the entity. Defaults to 0.\r\n             *\r\n             * @property x\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            x: 0,\r\n            \r\n            /**\r\n             * Optional. The y position of the entity. Defaults to 0.\r\n             *\r\n             * @property y\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            y: 0,\r\n            \r\n            /**\r\n             * Optional. The z position of the entity. Defaults to 0.\r\n             *\r\n             * @property z\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            z: 0\r\n        },\r\n        \r\n        initialize: function () {\r\n            var container = this.container = this.owner.container = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"](),\r\n                definition = null,\r\n                initialTint = this.tint;\r\n\r\n            if (this.rotate === true) {\r\n                this.rotate = 'rotation';\r\n                platypus.debug.warn('RenderContainer: Boolean values for the \"rotate\" property has been deprecated. Use \"rotation\", \"orientationMatrix\", or \"\" to specify the source of rotation for the render container. This property defaults to \"rotation\".');\r\n            }\r\n\r\n            this.parentContainer = null;\r\n            this.wasVisible = this.visible;\r\n            this.lastX = this.owner.x;\r\n            this.lastY = this.owner.y;\r\n            this.camera = _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp();\r\n            this.isOnCamera = true;\r\n            this.needsCameraCheck = true;\r\n\r\n            this._tint = null;\r\n\r\n            Object.defineProperty(this.owner, 'tint', {\r\n                get: function () {\r\n                    return this._tint;\r\n                }.bind(this),\r\n                set: function (value) {\r\n                    var filters = this.container.filters,\r\n                        matrix = null,\r\n                        color = castValue(value);\r\n\r\n                    if (color === this._tint) {\r\n                        return;\r\n                    }\r\n\r\n                    if (color === null) {\r\n                        if (filters) {\r\n                            this.container.filters = null;\r\n                        }\r\n                    } else {\r\n                        if (!filters) {\r\n                            filters = this.container.filters = _utils_array_js__WEBPACK_IMPORTED_MODULE_4__[\"arrayCache\"].setUp(new ColorMatrixFilter());\r\n                        }\r\n                        matrix = filters[0].matrix;\r\n                        matrix[0] = (color & 0xff0000) / 0xff0000; // Red\r\n                        matrix[6] = (color & 0xff00) / 0xff00; // Green\r\n                        matrix[12] = (color & 0xff) / 0xff; // Blue\r\n                    }\r\n\r\n                    this._tint = color;\r\n                }.bind(this)\r\n            });\r\n        \r\n            if (initialTint !== null) {\r\n                this.tint = initialTint; // feed initial tint through setter.\r\n            }\r\n\r\n            if (this.interactive) {\r\n                definition = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                    'container', container,\r\n                    'hitArea', this.interactive.hitArea,\r\n                    'hover', this.interactive.hover\r\n                );\r\n                this.owner.addComponent(new _Interactive_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.owner, definition));\r\n                definition.recycle();\r\n            }\r\n\r\n            if (this.cache) {\r\n                this.updateSprite(false);\r\n                this.owner.cacheRender = this.container;\r\n            }\r\n        },\r\n        \r\n        events: {\r\n            /**\r\n             * On receiving a \"cache\" event, this component triggers \"cache-sprite\" to cache its rendering into the background. This is an optimization for static images to reduce render calls.\r\n             *\r\n             * @method 'cache'\r\n             */\r\n            \"cache\": function () {\r\n                this.updateSprite(false);\r\n                this.owner.cacheRender = this.container;\r\n                this.cache = true;\r\n                if (this.owner.parent.triggerEventOnChildren) {\r\n                    /**\r\n                     * On receiving a \"cache\" event, this component triggers \"cache-sprite\" to cache its rendering into the background. This is an optimization for static images to reduce render calls.\r\n                     *\r\n                     * @event 'cache-sprite'\r\n                     * @param entity {platypus.Entity} This component's owner.\r\n                     */\r\n                    this.owner.parent.triggerEventOnChildren('cache-sprite', this.owner);\r\n                } else {\r\n                    platypus.debug.warn('Unable to cache sprite for ' + this.owner.type);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Listens for this event to determine whether this sprite is visible.\r\n             *\r\n             * @method 'camera-update'\r\n             * @param camera.viewport {platypus.AABB} Camera position and size.\r\n             */\r\n            \"camera-update\": function (camera) {\r\n                this.camera.set(camera.viewport);\r\n                \r\n                // Set visiblity of sprite if within camera bounds\r\n                this.needsCameraCheck = true;\r\n            },\r\n            \r\n            /**\r\n             * A setup message used to add the sprite to the stage. On receiving this message, the component sets its parent container to the stage contained in the message if it doesn't already have one.\r\n             *\r\n             * @method 'handle-render-load'\r\n             * @param handlerData {Object} Data from the render handler\r\n             * @param handlerData.container {PIXI.Container} The parent container.\r\n             * @param data.renderGroups {Array of PIXI.Container} Containers to categorize display of groups of entities.\r\n             */\r\n            \"handle-render-load\": function (handlerData) {\r\n                /**\r\n                 * This event is triggered once the RenderSprite is ready to handle interactivity.\r\n                 *\r\n                 * @event 'input-on'\r\n                 */\r\n                this.owner.triggerEvent('input-on');\r\n                this.updateSprite(true);\r\n            },\r\n            \r\n            /**\r\n             * The render update message updates the sprite. If a sprite doesn't have a container, it's removed.\r\n             *\r\n             * @method 'handle-render'\r\n             * @param renderData {Object} Data from the render handler\r\n             * @param renderData.container {PIXI.Container} The parent container.\r\n             */\r\n            \"handle-render\": function (renderData) {\r\n                if (!this.container) { // If this component's removal is pending\r\n                    return;\r\n                }\r\n\r\n                this.updateSprite(true);\r\n            },\r\n            \r\n            /**\r\n             * This event makes the sprite invisible.\r\n             *\r\n             * @method 'hide-sprite'\r\n             */\r\n            \"hide-sprite\": function () {\r\n                this.visible = false;\r\n            },\r\n\r\n            /**\r\n             * This event makes the sprite visible.\r\n             *\r\n             * @method 'show-sprite'\r\n             */\r\n            \"show-sprite\": function () {\r\n                this.visible = true;\r\n            },\r\n            \r\n            /**\r\n             * Defines the mask on the container/sprite. If no mask is specified, the mask is set to null.\r\n             *\r\n             * @method 'set-mask'\r\n             * @param mask {Object} The mask. This can specified the same way as the 'mask' parameter on the component.\r\n             */\r\n            \"set-mask\": function (mask) {\r\n                this.setMask(mask);\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            updateSprite: (function () {\r\n                var sort = function (a, b) {\r\n                    return a.z - b.z;\r\n                };\r\n                \r\n                return function (uncached) {\r\n                    var x = 0,\r\n                        y = 0,\r\n                        rotation = 0,\r\n                        matrix = pixiMatrix,\r\n                        mirrored = 1,\r\n                        flipped  = 1,\r\n                        angle    = null;\r\n                    \r\n                    x = this.owner.x;\r\n                    y = this.owner.y;\r\n                    if (this.rotate === 'rotation') {\r\n                        rotation = this.rotation;\r\n                    }\r\n                    if (this.container.z !== this.owner.z) {\r\n                        if (this.parentContainer) {\r\n                            this.parentContainer.reorder = true;\r\n                        }\r\n                        this.container.z = this.owner.z;\r\n                    }\r\n\r\n                    if (!this.ignoreOpacity && (this.owner.opacity || (this.owner.opacity === 0))) {\r\n                        this.container.alpha = this.owner.opacity;\r\n                    }\r\n                    \r\n                    if (this.container.reorder) {\r\n                        this.container.reorder = false;\r\n                        this.container.children.sort(sort);\r\n                        this.needsCameraCheck = true; // reorder is set when adding children, so force another camera check.\r\n                    }\r\n                    \r\n                    if (this.mirror || this.flip) {\r\n                        angle = this.rotation % 360;\r\n                        \r\n                        if (this.mirror && (angle > 90) && (angle < 270)) {\r\n                            mirrored = -1;\r\n                        }\r\n                        \r\n                        if (this.flip && (angle < 180)) {\r\n                            flipped = -1;\r\n                        }\r\n                    }\r\n                    \r\n                    if (this.rotate === 'orientationMatrix') { // This is a 3x3 2D matrix describing an affine transformation.\r\n                        const o = this.owner.orientationMatrix;\r\n\r\n                        matrix.a = o[0][0];\r\n                        matrix.b = o[1][0];\r\n                        matrix.tx = x + o[0][2];\r\n                        matrix.c = o[0][1];\r\n                        matrix.d = o[1][1];\r\n                        matrix.ty = y + o[1][2];\r\n                        this.container.transform.setFromMatrix(matrix);\r\n                    } else {\r\n                        this.container.setTransform(x, y, this.scaleX * mirrored, this.scaleY * flipped, (rotation ? (rotation / 180) * Math.PI : 0), this.skewX, this.skewY);\r\n                    }\r\n                    \r\n                    if (this.parentContainer && this.parentContainer.parentUpdated) {\r\n                        this.needsCameraCheck = true;\r\n                    }\r\n                    if (this.container) {\r\n                        if (this.container.childUpdated) {\r\n                            this.needsCameraCheck = true;\r\n                            this.container.childUpdated = false;\r\n                        }\r\n                        this.container.parentUpdated = false;\r\n                    }\r\n                    // Set isCameraOn of sprite if within camera bounds\r\n                    if (!this.needsCameraCheck) {\r\n                        this.needsCameraCheck = (this.lastX !== this.owner.x) || (this.lastY !== this.owner.y);\r\n                    }\r\n                    if (uncached && this.container && (this.needsCameraCheck || (!this.wasVisible && this.visible))) {\r\n                        this.isOnCamera = this.owner.parent.isOnCanvas(this.container.getBounds(false));\r\n                        this.needsCameraCheck = false;\r\n                        if (this.parentContainer) {\r\n                            this.parentContainer.childUpdated = true;\r\n                        }\r\n                        this.container.parentUpdated = true;\r\n                    }\r\n                    \r\n                    this.lastX = this.owner.x;\r\n                    this.lastY = this.owner.y;\r\n                    this.wasVisible = this.visible;\r\n                    this.container.visible = (this.visible && this.isOnCamera) || this.dragMode;\r\n                };\r\n            }()),\r\n            \r\n            setMask: function (shape) {\r\n                var gfx = null;\r\n                \r\n                if (this.mask) {\r\n                    if (this.localMask) {\r\n                        this.container.removeChild(this.mask);\r\n                    } else if (this.parentContainer) {\r\n                        this.parentContainer.removeChild(this.mask);\r\n                    }\r\n                }\r\n                \r\n                if (!shape) {\r\n                    this.mask = this.container.mask = null;\r\n                    return;\r\n                }\r\n                \r\n                if (shape.isMask || (shape instanceof pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"])) {\r\n                    gfx = shape;\r\n                } else {\r\n                    gfx = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"]();\r\n                    gfx.beginFill(0x000000, 1);\r\n                    if (typeof shape === 'string') {\r\n                        processGraphics(gfx, shape);\r\n                    } else if (shape.radius) {\r\n                        gfx.drawCircle(shape.x || 0, shape.y || 0, shape.radius);\r\n                    } else if (shape.width && shape.height) {\r\n                        gfx.drawRect(shape.x || 0, shape.y || 0, shape.width, shape.height);\r\n                    }\r\n                    gfx.endFill();\r\n                }\r\n                \r\n                gfx.isMask = true;\r\n\r\n                this.mask = this.container.mask = gfx;\r\n                this.mask.z = 0; //TML 12-4-16 - Masks don't need a Z, but this makes it play nice with the Z-ordering in HandlerRender.\r\n\r\n                if (this.localMask) {\r\n                    this.container.addChild(this.mask);\r\n                } else if (this.parentContainer) {\r\n                    this.parentContainer.addChild(this.mask);\r\n                }\r\n            },\r\n            \r\n            destroy: function () {\r\n                this.camera.recycle();\r\n                if (this.parentContainer && !this.container.mouseTarget) {\r\n                    this.parentContainer.removeChild(this.container);\r\n                    this.parentContainer = null;\r\n                } else if (!this.cache) {\r\n                    this.container.destroy();\r\n                }\r\n                this.container = null;\r\n            }\r\n        },\r\n    \r\n        publicMethods: {// These are methods that are available on the entity.\r\n            removeFromParentContainer: function () {\r\n                if (this.parentContainer) {\r\n                    if (this.mask) {\r\n                        this.setMask();\r\n                    }\r\n\r\n                    this.parentContainer.removeChild(this.container);\r\n                }\r\n            },\r\n            \r\n            addToParentContainer: function (container) {\r\n                this.parentContainer = container;\r\n                this.parentContainer.addChild(this.container);\r\n                this.parentContainer.reorder = true;\r\n\r\n                if (this.mask) {\r\n                    this.setMask(this.mask);\r\n                }\r\n\r\n            }\r\n            \r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderContainer.js?");

/***/ }),

/***/ "./src/components/RenderDebug.js":
/*!***************************************!*\
  !*** ./src/components/RenderDebug.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _RenderContainer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RenderContainer.js */ \"./src/components/RenderContainer.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n * This component is attached to entities that will appear in the game world. It serves two purposes. First, it displays a rectangle that indicates the location of the entity. By default it uses the specified position and dimensions of the object (in grey). If the object has a collision component it will display the AABB of the collision shape (in pink). If the entity has a LogicCarrier component and is/was carrying an object, a green rectangle will be drawn showing the collision group. The RenderDebug component also allows the developer to right-click on an entity and it will print the object in the debug console.\r\n *\r\n * @namespace platypus.components\r\n * @class RenderDebug\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var createShape = function (shape, color, left, top, width, height, z, outline) {\r\n            var newShape = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"]().beginFill(color, 0.1);\r\n\r\n            if (outline) {\r\n                newShape.lineStyle(outline, color);\r\n            }\r\n\r\n            switch (shape) {\r\n            case 'rectangle':\r\n                newShape.drawRect(left, top, width, height);\r\n                break;\r\n            case 'circle':\r\n                newShape.drawCircle(0, 0, width);\r\n                break;\r\n            }\r\n            newShape.z = z;\r\n\r\n            return newShape;\r\n        },\r\n        standardizeColor = function (color) {\r\n            if (typeof color === 'string') {\r\n                return parseInt(color.replace('#', ''), 16);\r\n            } else {\r\n                return color;\r\n            }\r\n        };\r\n    \r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'RenderDebug',\r\n\r\n        properties: {\r\n            /**\r\n             * The color to use to highlight an entity's AABB. For example, use `\"#ffffff\"` or `0xffffff` to set as white.\r\n             *\r\n             * @property aabbColor\r\n             * @type Number|String\r\n             * @default 0xff88ff\r\n             * @since 0.11.3\r\n             */\r\n            aabbColor: 0xff88ff,\r\n\r\n            /**\r\n             * The color to use to highlight an entity's collision shape. For example, use `\"#ffffff\"` or `0xffffff` to set as white.\r\n             *\r\n             * @property collisionColor\r\n             * @type Number|String\r\n             * @default 0xff00ff\r\n             * @since 0.11.3\r\n             */\r\n            collisionColor: 0xff00ff,\r\n\r\n            /**\r\n             * The color to use to highlight the AABB for a group of entities attached to this entity. For example, use `\"#ffffff\"` or `0xffffff` to set as white.\r\n             *\r\n             * @property groupColor\r\n             * @type Number|String\r\n             * @default 0x00ff00\r\n             * @since 0.11.3\r\n             */\r\n            groupColor: 0x00ff00,\r\n\r\n            /**\r\n             * The color to use to highlight an entity. This property is only used if there is no `CollisionBasic` component attached to the entity: this component uses the entity's `width` and `height` properties if defined. For example, use `\"#ffffff\"` or `0xffffff` to set as white.\r\n             *\r\n             * @property renderColor\r\n             * @type Number|String\r\n             * @default 0x0000ff\r\n             * @since 0.11.3\r\n             */\r\n            renderColor: 0x0000ff,\r\n\r\n            /**\r\n             * The height of the entity.\r\n             *\r\n             * @property height\r\n             * @type Number\r\n             * @default 100\r\n             * @since 0.11.3\r\n             */\r\n            width: 100,\r\n\r\n            /**\r\n             * The width of the entity.\r\n             *\r\n             * @property width\r\n             * @type Number\r\n             * @default 100\r\n             * @since 0.11.3\r\n             */\r\n            height: 100,\r\n\r\n            /**\r\n             * The local offset in z-index for the rendered debug area.\r\n             *\r\n             * @property offsetZ\r\n             * @type Number\r\n             * @default 10000\r\n             * @since 0.11.3\r\n             */\r\n            offsetZ: 10000\r\n        },\r\n        \r\n        initialize: function () {\r\n            this.shapes = _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp();\r\n            this.isOutdated = true;\r\n\r\n            this.aabbColor = standardizeColor(this.aabbColor);\r\n            this.collisionColor = standardizeColor(this.collisionColor);\r\n            this.groupColor = standardizeColor(this.groupColor);\r\n            this.renderColor = standardizeColor(this.renderColor);\r\n        },\r\n        \r\n        events: {// These are messages that this component listens for\r\n            /**\r\n             * Removes this component if not in a debug build.\r\n             *\r\n             * @method 'load'\r\n             * @since 0.11.3\r\n             */\r\n            \"load\": function () {\r\n                if (!platypus.game.settings.debug) {\r\n                    this.owner.removeComponent(this);\r\n                    return;\r\n                } else if (!this.owner.container) {\r\n                    this.owner.addComponent(new _RenderContainer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.owner, null));\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Repositions the pieces of the component in preparation for rendering\r\n             *\r\n             * @method 'handle-render'\r\n             */\r\n            \"handle-render\": function () {\r\n                var aabb = null,\r\n                    offset = -0.5;\r\n\r\n                if (this.isOutdated) {\r\n                    this.updateSprites();\r\n                    this.isOutdated = false;\r\n                }\r\n                \r\n                if (this.owner.getCollisionGroupAABB) {\r\n                    aabb = this.owner.getCollisionGroupAABB();\r\n                    if (!this.groupShape) {\r\n                        this.groupShape = createShape('rectangle', this.groupColor, offset, offset, 1, 1, this.offsetZ);\r\n                        this.owner.container.addChild(this.groupShape);\r\n                    }\r\n                    this.groupShape.scaleX = aabb.width;\r\n                    this.groupShape.scaleY = aabb.height;\r\n                    this.groupShape.x      = aabb.x - this.owner.x;\r\n                    this.groupShape.y      = aabb.y - this.owner.y;\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * On receiving this message, will re-orient itself on the next update.\r\n             *\r\n             * @method 'orientation-updated'\r\n             */\r\n            \"orientation-updated\": function () {\r\n                this.isOutdated = true;\r\n            }            \r\n        },\r\n        \r\n        methods: {\r\n            updateSprites: function () {\r\n                var owner = this.owner,\r\n                    z        = this.offsetZ,\r\n                    i        = 0,\r\n                    j        = 0,\r\n                    lineWidth = 2,\r\n                    width    = this.width,\r\n                    height   = this.height,\r\n                    shapes   = null,\r\n                    aabb     = null,\r\n                    shape    = null;\r\n\r\n                for (i = 0; i < this.shapes.length; i++) {\r\n                    owner.container.removeChild(this.shapes[i]);\r\n                }\r\n                this.shapes.length = 0;\r\n\r\n                if (owner.getAABB) {\r\n                    for (j = 0; j < owner.collisionTypes.length; j++) {\r\n                        aabb   = owner.getAABB(owner.collisionTypes[j]);\r\n                        width  = this.initialWidth  = aabb.width;\r\n                        height = this.initialHeight = aabb.height;\r\n                        shapes = owner.getShapes(owner.collisionTypes[j]);\r\n                        \r\n                        shape  = createShape('rectangle', this.aabbColor, aabb.left - owner.x, aabb.top - owner.y, width, height, z--);\r\n                        this.shapes.push(shape);\r\n                        owner.container.addChild(shape);\r\n                        this.addInput(shape);\r\n                        \r\n                        for (i = 0; i < shapes.length; i++) {\r\n                            width = shapes[i].width - lineWidth;\r\n                            height = shapes[i].height - lineWidth;\r\n                            shape = createShape(shapes[i].type, this.collisionColor, shapes[i].offsetX - width / 2, shapes[i].offsetY - height / 2, (shapes[i].radius ? shapes[i].radius - lineWidth : width), height, z--, lineWidth);\r\n                            this.shapes.push(shape);\r\n                            owner.container.addChild(shape);\r\n                            this.addInput(shape);\r\n                        }\r\n                    }\r\n                } else {\r\n                    shape = createShape('rectangle', this.renderColor, -width / 2, -height / 2, width, height, z--);\r\n                    this.shapes.push(shape);\r\n                    owner.container.addChild(shape);\r\n                    this.addInput(shape);\r\n                }\r\n\r\n                owner.container.reorder = true;\r\n            },\r\n            \r\n            addInput: (function () {\r\n                var lastEntityLog = null,\r\n                    handler = function () {\r\n                        if (lastEntityLog !== this.owner) {\r\n                            lastEntityLog = this.owner;\r\n                            platypus.debug.olive('Entity \"' + lastEntityLog.type + '\":', lastEntityLog);\r\n                        }\r\n\r\n                        return false;\r\n                    };\r\n                \r\n                return function (sprite) {\r\n                    sprite.interactive = true;\r\n                    sprite.addListener('rightdown', handler.bind(this));\r\n                };\r\n            }()),\r\n            \r\n            destroy: function () {\r\n                var i = 0;\r\n                \r\n                for (i = 0; i < this.shapes.length; i++) {\r\n                    this.owner.container.removeChild(this.shapes[i]);\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].recycle(this.shapes);\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderDebug.js?");

/***/ }),

/***/ "./src/components/RenderDestroyMe.js":
/*!*******************************************!*\
  !*** ./src/components/RenderDestroyMe.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n * This component will destroy the entity once an animation has finished. This is useful for explosions or similar animations where the entity is no longer needed once the animation completes.\r\n *\r\n * @namespace platypus.components\r\n * @class RenderDestroyMe\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        id: 'RenderDestroyMe',\r\n        \r\n        properties: {\r\n            /**\r\n             * This or animationIds required. This is a String identifying the animation that should destroy this entity on its completion.\r\n             *\r\n             * @property animationId\r\n             * @type String\r\n             * @default ''\r\n             */\r\n            animationId: '',\r\n            \r\n            /**\r\n             * This or animationId required. This is an array of Strings identifying the animations that should destroy this entity on their completion.\r\n             *\r\n             * @property animationIds\r\n             * @type Array\r\n             * @default null\r\n             */\r\n            animationIds: null\r\n        },\r\n\r\n        initialize: function (definition) {\r\n            if (this.animationId) {\r\n                this.animationIds = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(definition.animationId);\r\n            } else if (this.animationIds) {\r\n                this.animationIds = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(this.animationIds);\r\n            }\r\n        },\r\n\r\n        events: {// These are messages that this component listens for\r\n            /**\r\n             * On receiving this message, the component matches the animation id with its animation id setting and destroys the entity if they match.\r\n             *\r\n             * @method 'animation-ended'\r\n             * @param animation {String} Animation id for the animation that just finished.\r\n             */\r\n            \"animation-ended\": function (animation) {\r\n                if (!this.animationIds || (this.animationIds.indexOf(animation) >= 0)) {\r\n                    this.owner.parent.removeEntity(this.owner);\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                if (this.animationIds) {\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(this.animationIds);\r\n                    this.animationIds = null;\r\n                }\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderDestroyMe.js?");

/***/ }),

/***/ "./src/components/RenderProgress.js":
/*!******************************************!*\
  !*** ./src/components/RenderProgress.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/**\r\n * This component creates a visual progress bar that can be used for loading assets or showing other types of progress changes.\r\n *\r\n * @namespace platypus.components\r\n * @class RenderProgress\r\n * @uses platypus.Component\r\n */\r\n/*global platypus */\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'RenderProgress',\r\n        \r\n        properties: {\r\n            //TODO: Document!\r\n            backgroundColor: 0x000000,\r\n            \r\n            color: 0xffffff,\r\n            \r\n            mirror: false,\r\n            \r\n            flip: false,\r\n            \r\n            width: 100,\r\n            \r\n            height: 20,\r\n            \r\n            regX: 0,\r\n            \r\n            regY: 0\r\n        },\r\n        \r\n        publicProperties: {\r\n            x: 0,\r\n            \r\n            y: 0,\r\n            \r\n            z: 0\r\n        },\r\n        \r\n        initialize: function () {\r\n            var b   = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"](),\r\n                f   = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"](),\r\n                con = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"]();\r\n            \r\n            this.parentContainer = null;\r\n            this.background = b;\r\n            this.progress   = f;\r\n            this.container  = con;\r\n            \r\n            if (typeof this.backgroundColor === 'string') {\r\n                this.backgroundColor = +this.backgroundColor.replace('#', '0x');\r\n            }\r\n            if (typeof this.color === 'string') {\r\n                this.color = +this.color.replace('#', '0x');\r\n            }\r\n            \r\n            b.f(this.backgroundColor).drawRect(-this.regX, -this.regY, this.width, this.height);\r\n            f.f(this.color).drawRect(-this.regX, -this.regY, this.width, this.height);\r\n            f.scale = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](0.0001, 1);\r\n            con.addChild(b);\r\n            con.addChild(f);\r\n        },\r\n        \r\n        events: {\r\n            \"handle-render-load\": function (resp) {\r\n                if (!this.parentContainer && resp && resp.container) {\r\n                    this.parentContainer = resp.container;\r\n                    this.parentContainer.addChild(this.container);\r\n                }\r\n            },\r\n            \r\n            \"handle-render\": function (resp) {\r\n                if (!this.container) { // If this component's removal is pending\r\n                    return;\r\n                }\r\n\r\n                if (!this.parentContainer) {\r\n                    if (resp && resp.container) {\r\n                        this.parentContainer = resp.container;\r\n                        this.parentContainer.addChild(this.container);\r\n                    } else {\r\n                        platypus.debug.warn('No PIXI Stage, removing ProgressRender component from \"' + this.owner.type + '\".');\r\n                        this.owner.removeComponent(this);\r\n                    }\r\n                }\r\n                \r\n                this.container.x = this.x;\r\n                this.container.y = this.y;\r\n                this.container.z = this.z;\r\n            },\r\n            \r\n            \"update-progress\": function (progress) {\r\n                if (isNaN(progress)) {\r\n                    if (typeof progress.fraction === 'number') {\r\n                        this.progress.scale.x = progress.fraction;\r\n                    } else if ((typeof progress.total === 'number') && (typeof progress.progress === 'number')) {\r\n                        this.progress.scale.x = progress.progress / progress.total;\r\n                    }\r\n                } else {\r\n                    this.progress.scale.x = progress;\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                if (this.parentContainer) {\r\n                    this.parentContainer.removeChild(this.container);\r\n                    this.parentContainer = null;\r\n                }\r\n                this.container = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderProgress.js?");

/***/ }),

/***/ "./src/components/RenderSpine.js":
/*!***************************************!*\
  !*** ./src/components/RenderSpine.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(PIXI) {/* harmony import */ var pixi_spine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi-spine */ \"pixi-spine\");\n/* harmony import */ var pixi_spine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_spine__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _RenderAnimator_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RenderAnimator.js */ \"./src/components/RenderAnimator.js\");\n/* harmony import */ var _RenderContainer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RenderContainer.js */ \"./src/components/RenderContainer.js\");\n/**\r\n * This component is attached to entities that will appear in the game world. It renders a spine-based puppet. It listens for messages triggered on the entity or changes in the logical state of the entity to play a corresponding animation.\r\n *\r\n * @namespace platypus.components\r\n * @class RenderSpine\r\n * @uses platypus.Component\r\n */\r\n/* global PIXI, platypus */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ((function () {\r\n    var spine = PIXI.spine,\r\n        core = spine && spine.core,\r\n        TextureAtlas = core && core.TextureAtlas,\r\n        AtlasAttachmentLoader = core && core.AtlasAttachmentLoader,\r\n        BaseTexture = PIXI.BaseTexture,\r\n        SkeletonJson = core && core.SkeletonJson,\r\n        Spine = spine && spine.Spine,\r\n        getBaseTexture = function (path, pma) {\r\n            var asset = platypus.assetCache.get(path.substring(path.lastIndexOf('/') + 1, path.lastIndexOf('.')));\r\n            \r\n            if (!asset) {\r\n                platypus.debug.warn('RenderSpine: \"' + path + '\" is not a loaded asset.');\r\n            }\r\n            return new BaseTexture(asset, {\r\n                alphaMode: pma ? PIXI.ALPHA_MODES.PMA : PIXI.ALPHA_MODES.UNPACK\r\n            });\r\n        };\r\n    \r\n    // If PIXI.spine is unavailable, this component doesn't work.\r\n    if (!Spine) {\r\n        return function () {\r\n            platypus.debug.error('RenderSpine requires `PIXI.spine` to function.');\r\n        };\r\n    }\r\n\r\n    return platypus.createComponentClass({\r\n\r\n        id: 'RenderSpine',\r\n\r\n        properties: {\r\n            /**\r\n             * An object containg key-value pairs that define a mapping from entity states to the animation that should play. The list is processed from top to bottom, so the most important actions should be listed first (for example, a jumping animation might take precedence over an idle animation). If not specified, an 1-to-1 animation map is created from the list of animations in the sprite sheet definition using the animation names as the keys.\r\n             *\r\n             *  \"animationStates\":{\r\n             *      \"standing\": \"default-animation\"  // On receiving a \"standing\" event, or when this.owner.state.standing === true, the \"default\" animation will begin playing.\r\n             *      \"ground,moving\": \"walking\",  // Comma separated values have a special meaning when evaluating \"state-changed\" messages. The above example will cause the \"walking\" animation to play ONLY if the entity's state includes both \"moving\" and \"ground\" equal to true.\r\n             *      \"ground,striking\": \"swing!\", // Putting an exclamation after an animation name causes this animation to complete before going to the next animation. This is useful for animations that would look poorly if interrupted.\r\n             *      \"default\": \"default-animation\" // Optional. \"default\" is a special property that matches all states. If none of the above states are valid for the entity, it will use the default animation listed here.\r\n             *  }\r\n             *\r\n             * If `stateBased` is `true` and this property is not set, this component will use the `animationMap` property value to define state mappings.\r\n             *\r\n             * @property animationStates\r\n             * @type Object\r\n             * @default animationMap\r\n             */\r\n            animationStates: null,\r\n\r\n            /**\r\n             * An object containg key-value pairs that define a mapping from triggered events to the animation that should play.\r\n             *\r\n             *     \"animationEvents\":{\r\n             *         \"move\": \"walk-animation\",\r\n             *         \"jump\": \"jumping-animation\"\r\n             *     }\r\n             *\r\n             * The above will create two event listeners on the entity, \"move\" and \"jump\", that will play their corresponding animations when the events are triggered.\r\n             *\r\n             * If `eventBased` is `true` and this property is not set, this component will use the `animationMap` property value to define event mappings.\r\n             *\r\n             * @property animationEvents\r\n             * @type Object\r\n             * @default animationMap\r\n             */\r\n            animationEvents: null,\r\n\r\n            /**\r\n             * Optional. An object containing key-value pairs that define a mapping from triggered events or entity states to the animation that should play. The list is processed from top to bottom, so the most important actions should be listed first (for example, a jumping animation might take precedence over an idle animation). If not specified, an 1-to-1 animation map is created from the list of animations in the skeleton definition using the animation names as the keys.\r\n             *\r\n             *  \"animationMap\":{\r\n             *      \"standing\": \"default-animation\"  // On receiving a \"standing\" event, or when this.owner.state.standing === true, the \"default\" animation will begin playing.\r\n             *      \"ground,moving\": \"walking\",  // Comma separated values have a special meaning when evaluating \"state-changed\" messages. The above example will cause the \"walking\" animation to play ONLY if the entity's state includes both \"moving\" and \"ground\" equal to true.\r\n             *      \"ground,striking\": \"swing!\", // Putting an exclamation after an animation name causes this animation to complete before going to the next animation. This is useful for animations that would look poorly if interrupted.\r\n             *      \"default\": \"default-animation\" // Optional. \"default\" is a special property that matches all states. If none of the above states are valid for the entity, it will use the default animation listed here.\r\n             *  }\r\n             *\r\n             * @property animationMap\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            animationMap: null,\r\n\r\n            /**\r\n             * Optional. A mask definition that determines where the image should clip. A string can also be used to create more complex shapes via the PIXI graphics API like: \"mask\": \"r(10,20,40,40).drawCircle(30,10,12)\". Defaults to no mask or, if simply set to true, a rectangle using the entity's dimensions.\r\n             *\r\n             *  \"mask\": {\r\n             *      \"x\": 10,\r\n             *      \"y\": 10,\r\n             *      \"width\": 40,\r\n             *      \"height\": 40\r\n             *  },\r\n             *\r\n             *  -OR-\r\n             *\r\n             *  \"mask\": \"r(10,20,40,40).drawCircle(30,10,12)\"\r\n             *\r\n             * @property mask\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            mask: null,\r\n\r\n            /**\r\n             * Defines whether the entity will respond to touch and click events. Setting this value will create an Interactive component on this entity with these properties. For example:\r\n             *\r\n             *  \"interactive\": {\r\n             *      \"hover\": false,\r\n             *      \"hitArea\": {\r\n             *          \"x\": 10,\r\n             *          \"y\": 10,\r\n             *          \"width\": 40,\r\n             *          \"height\": 40\r\n             *      }\r\n             *  }\r\n             *\r\n             * @property interactive\r\n             * @type Boolean|Object\r\n             * @default false\r\n             */\r\n            interactive: false,\r\n\r\n            /**\r\n             * Sets the transition time between animations. If a number is defined, the transition time applies to all animation changes. If an object is specified, the key value pairs should match this syntax where the first part of the key lists the animation currently playing and the second part of the key lists the animation being transitioned to:\r\n             *\r\n             *     {\r\n             *         \"jump:walk\": 0.4,\r\n             *         \"walk:jump\": 0.2\r\n             *     }\r\n             *\r\n             * @property mixTimes\r\n             * @type Number|Object\r\n             * @default 0\r\n             */\r\n            mixTimes: 0,\r\n\r\n            /**\r\n             * The offset of the x-axis position of the sprite from the entity's x-axis position.\r\n             *\r\n             * @property offsetX\r\n             * @type Number\r\n             * @default 0\r\n             * @since 0.11.4\r\n             */\r\n            offsetX: 0,\r\n\r\n            /**\r\n             * The offset of the y-axis position of the sprite from the entity's y-axis position.\r\n             *\r\n             * @property offsetY\r\n             * @type Number\r\n             * @default 0\r\n             * @since 0.11.4\r\n             */\r\n            offsetY: 0,\r\n\r\n            /**\r\n             * The z-index relative to other render components on the entity.\r\n             *\r\n             * @property offsetZ\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            offsetZ: 0,\r\n\r\n            /**\r\n             * Text describing an atlas of graphic assets for the Spine animation or an asset id for the same.\r\n             *\r\n             * @property atlas\r\n             * @type String\r\n             * @default \"\"\r\n             */\r\n            atlas: \"\",\r\n\r\n            /**\r\n             * A JSON structure defining a Spine skeleton and behaviors for the animation, or an asset id for the same.\r\n             *\r\n             * @property skeleton\r\n             * @type String|Object\r\n             * @default null\r\n             */\r\n            skeleton: null,\r\n\r\n            /**\r\n             * Whether this object can be mirrored over X. To mirror it over X set the this.owner.rotation value to be > 90  and < 270.\r\n             *\r\n             * @property mirror\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            mirror: false,\r\n\r\n            /**\r\n             * Optional. Whether this object can be flipped over Y. To flip it over Y set the this.owner.rotation to be > 180.\r\n             *\r\n             * @property flip\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            flip: false,\r\n\r\n            /**\r\n             * Optional. Whether this object is visible or not. To change the visible value dynamically set this.owner.state.visible to true or false.\r\n             *\r\n             * @property visible\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            visible: true,\r\n\r\n            /**\r\n             * Optional. Specifies whether this component should create a RenderAnimator component to listen to events matching the animationMap to animate. Set this to true if the component should animate for on events. Default is `false`.\r\n             *\r\n             * @property eventBased\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            eventBased: false,\r\n\r\n            /**\r\n             * Optional. Specifies whether the spine image alpha has been premultiplied. Set this to `false` if you see bright borders around image parts. Make sure it's `true` if you see thin black lines around image pieces.\r\n             *\r\n             * @property preMultipliedAlpha\r\n             * @type Boolean\r\n             * @default true\r\n             */\r\n            preMultipliedAlpha: true,\r\n\r\n            /**\r\n             * Optional. Specifies whether this component should create a RenderAnimator component to handle changes in the entity's state that match the animationMap to animate. Set this to true if the component should animate based on `this.owner.state`. Default is `true`.\r\n             *\r\n             * @property stateBased\r\n             * @type Boolean\r\n             * @default true\r\n             */\r\n            stateBased: true\r\n        },\r\n\r\n        publicProperties: {\r\n            /**\r\n             * Prevents the spine from becoming invisible out of frame and losing mouse input connection.\r\n             *\r\n             * @property dragMode\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            dragMode: false,\r\n\r\n            /**\r\n             * Optional. The X scaling factor for the image. Defaults to 1.\r\n             *\r\n             * @property scaleX\r\n             * @type Number\r\n             * @default 1\r\n             */\r\n            scaleX: 1,\r\n\r\n            /**\r\n             * Optional. The Y scaling factor for the image. Defaults to 1.\r\n             *\r\n             * @property scaleY\r\n             * @type Number\r\n             * @default 1\r\n             */\r\n            scaleY: 1,\r\n\r\n            /**\r\n             * Optional. The X swek factor of the sprite. Defaults to 0.\r\n             *\r\n             * @property skewX\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            skewX: 0,\r\n\r\n            /**\r\n             * Optional. The Y skew factor for the image. Defaults to 0.\r\n             *\r\n             * @property skewY\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            skewY: 0,\r\n\r\n            /**\r\n             * Optional. The x position of the entity. Defaults to 0.\r\n             *\r\n             * @property x\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            x: 0,\r\n            \r\n            /**\r\n             * Optional. The y position of the entity. Defaults to 0.\r\n             *\r\n             * @property y\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            y: 0,\r\n            \r\n            /**\r\n             * Optional. The z position of the entity. Defaults to 0.\r\n             *\r\n             * @property z\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            z: 0\r\n        },\r\n\r\n        initialize: (function () {\r\n            var\r\n                createAnimationMap = function (animationMap, animations) {\r\n                    var map  = null,\r\n                        anim = '';\r\n\r\n                    if (animationMap) {\r\n                        return animationMap;\r\n                    } else {\r\n                        // Create 1-to-1 animation map since none was defined\r\n                        map = {};\r\n                        for (anim in animations) {\r\n                            if (animations.hasOwnProperty(anim)) {\r\n                                map[anim] = anim;\r\n                            }\r\n                        }\r\n                        return map;\r\n                    }\r\n                },\r\n                imageCallback = function (pma, loadFinished, line, callback) {\r\n                    // Not sure if this handles memory well - keeping it in for now.\r\n                    var baseTexture = getBaseTexture(line, pma);\r\n\r\n                    callback(baseTexture);\r\n\r\n                    if (baseTexture.isLoading) {\r\n                        baseTexture.on('loaded', loadFinished);\r\n                    } else {\r\n                        loadFinished();\r\n                    }\r\n                },\r\n                animationEnded = function () {\r\n                    /**\r\n                     * This event fires each time an animation completes.\r\n                     *\r\n                     * @event 'animation-ended'\r\n                     * @param animation {String} The id of the animation that ended.\r\n                     */\r\n                    this.owner.triggerEvent('animation-ended', this.currentAnimation);\r\n                },\r\n                handleSpineEvent = function (entry, event) {\r\n                    var eventName = event.data.name;\r\n\r\n                    if (this.playAnimation(eventName)) {\r\n                        this.spine.update(0.000001);\r\n                    }\r\n\r\n                    this.owner.trigger(eventName, event.data);\r\n                };\r\n            \r\n            return function (def, callback) {\r\n                var animation = '',\r\n                    definition = null,\r\n                    settings = platypus.game.settings,\r\n                    atlas = settings.atlases[this.atlas],\r\n                    map = null,\r\n                    skeleton = settings.skeletons[this.skeleton],\r\n                    spineAtlas = new TextureAtlas(atlas, imageCallback.bind(null, this.preMultipliedAlpha, callback)),\r\n                    spineJsonParser = new SkeletonJson(new AtlasAttachmentLoader(spineAtlas)),\r\n                    skeletonData = spineJsonParser.readSkeletonData(skeleton),\r\n                    spine = this.spine = new Spine(skeletonData);\r\n\r\n                spine.state.addListener({\r\n                    event: handleSpineEvent.bind(this),\r\n                    complete: animationEnded.bind(this)\r\n                });\r\n                spine.autoUpdate = false;\r\n\r\n                map = createAnimationMap(this.animationMap, skeleton.animations);\r\n                this.stateBased = map && this.stateBased;\r\n                this.eventBased = map && this.eventBased;\r\n                if (map) {\r\n                    animation = map.default || '';\r\n\r\n                    definition = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                        'animationEvents', this.eventBased ? this.animationEvents || map : null,\r\n                        'animationStates', this.stateBased ? this.animationStates || map : null,\r\n                        'forcePlayThrough', this.forcePlayThrough,\r\n                        'component', this\r\n                    );\r\n                    this.owner.addComponent(new _RenderAnimator_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.owner, definition));\r\n                    definition.recycle();\r\n                }\r\n\r\n                // set up the mixes!\r\n                if (this.mixTimes) {\r\n                    this.setMixTimes(this.mixTimes);\r\n                }\r\n\r\n                // play animation\r\n                if (animation) {\r\n                    this.currentAnimation = animation;\r\n                    spine.state.setAnimation(0, animation, true);\r\n                }\r\n\r\n                spine.x = this.offsetX;\r\n                spine.y = this.offsetY;\r\n                spine.z = this.offsetZ;\r\n\r\n                if (!this.owner.container) {\r\n                    definition = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                        'interactive', this.interactive,\r\n                        'mask', this.mask,\r\n                        'mirror', this.mirror,\r\n                        'flip', this.flip,\r\n                        'visible', this.visible,\r\n                        'cache', this.cache,\r\n                        'ignoreOpacity', this.ignoreOpacity,\r\n                        'scaleX', this.scaleX,\r\n                        'scaleY', this.scaleY,\r\n                        'skewX', this.skewX,\r\n                        'skewY', this.skewY\r\n                    );\r\n                    this.owner.addComponent(new _RenderContainer_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.owner, definition, this.addToContainer.bind(this)));\r\n                    definition.recycle();\r\n                } else {\r\n                    this.addToContainer();\r\n                }\r\n\r\n                return true; //using callback\r\n            };\r\n        }()),\r\n\r\n        events: {\r\n            /**\r\n             * The render update message updates the spine.\r\n             *\r\n             * @method 'handle-render'\r\n             * @param renderData {Object} Data from the render handler\r\n             * @param renderData.container {PIXI.Container} The parent container.\r\n             */\r\n            \"handle-render\": function (renderData) {\r\n                if (this.spine) {\r\n                    /**\r\n                     * This event is triggered each tick to check for animation updates.\r\n                     *\r\n                     * @event 'update-animation'\r\n                     * @param playing {Boolean} Whether the animation is in a playing or paused state.\r\n                     */\r\n                    this.owner.triggerEvent('update-animation', true);\r\n\r\n                    this.spine.update(renderData.delta / 1000);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * This sets the mix times.\r\n             *\r\n             * @method 'set-mix-times'\r\n             * @param mixTimes {Object} This matches the syntax required for this component's `mixTimes` property\r\n             */\r\n            \"set-mix-times\": function (mixTimes) {\r\n                this.setMixTimes(mixTimes);\r\n            },\r\n            \r\n            /**\r\n             * This event makes the spine invisible.\r\n             *\r\n             * @method 'hide'\r\n             */\r\n            \"hide\": function () {\r\n                this.visible = false;\r\n            },\r\n\r\n            /**\r\n             * This event makes the spine visible.\r\n             *\r\n             * @method 'show'\r\n             */\r\n            \"show\": function () {\r\n                this.visible = true;\r\n            },\r\n\r\n            /**\r\n             * Stops the sprite's animation.\r\n             *\r\n             * @method 'stop-animation'\r\n             * @param [animation] {String} The animation to show and pause. If not specified, this method simply pauses the current animation.\r\n             * @since 0.9.0\r\n             */\r\n            \"stop-animation\": function (animation) {\r\n                this.stopAnimation(animation);\r\n            },\r\n            \r\n            /**\r\n             * Starts the sprite's animation.\r\n             *\r\n             * @method 'play-animation'\r\n             * @param [animation] {String} The animation to play. If not specified, this method simply unpauses the current animation.\r\n             * @since 0.9.0\r\n             */\r\n            \"play-animation\": function (animation) {\r\n                this.playAnimation(animation);\r\n            }\r\n        },\r\n\r\n        methods: {\r\n            addToContainer: function () {\r\n                var container = this.owner.container;\r\n\r\n                container.addChild(this.spine);\r\n                container.reorder = true;\r\n            },\r\n            \r\n            playAnimation: function (animation) {\r\n                var spine = this.spine;\r\n\r\n                if (animation && spine.state.hasAnimation(animation)) {\r\n                    this.currentAnimation = animation;\r\n                    spine.state.setAnimation(0, animation, true);\r\n                    this.paused = false;\r\n\r\n                    return true;\r\n                }\r\n\r\n                return false;\r\n            },\r\n\r\n            stopAnimation: function (animation) {\r\n                var spine = this.spine;\r\n\r\n                if (animation && spine.state.hasAnimation(animation)) {\r\n                    this.currentAnimation = animation;\r\n                    spine.state.setAnimation(0, animation, false);\r\n                }\r\n\r\n                this.paused = true;\r\n            },\r\n\r\n            setMixTimes: function (mixTimes) {\r\n                var spine = this.spine,\r\n                    animations = spine.spineData.animations,\r\n                    colon = 0,\r\n                    i = 0,\r\n                    j = 0,\r\n                    key = '',\r\n                    stateData = spine.stateData;\r\n\r\n                if (typeof mixTimes === 'number') {\r\n                    i = animations.length;\r\n                    while (i--) {\r\n                        j = animations.length;\r\n                        while (j--) {\r\n                            if (i !== j) {\r\n                                stateData.setMix(animations[i].name, animations[j].name, mixTimes);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    for (key in mixTimes) {\r\n                        if (mixTimes.hasOwnProperty(key)) {\r\n                            colon = key.indexOf(':');\r\n                            if (colon >= 0) {\r\n                                stateData.setMix(key.substring(0, colon), key.substring(colon + 1), mixTimes[key]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.mixTimes = stateData.animationToMixTime;\r\n            },\r\n\r\n            destroy: function () {\r\n                this.owner.container.removeChild(this.spine);\r\n                this.spine.destroy();\r\n                this.spine = null;\r\n                this.mixTimes = null;\r\n            }\r\n        },\r\n        \r\n        getAssetList: (function () {\r\n            var\r\n                getImages = function (atlas, atlases) {\r\n                    var images = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\r\n                        lines = null,\r\n                        j = 0;\r\n\r\n                    if (atlas) {\r\n                        lines = atlas.split('\\n');\r\n                        if (lines.length === 1) { // id, not an actual atlas\r\n                            atlas = atlases[atlas];\r\n                            if (atlas) {\r\n                                lines = atlas.split('\\n');\r\n                            } else {\r\n                                return images;\r\n                            }\r\n                        }\r\n                        j = lines.length;\r\n                        while (j--) { // Fix up relative image location paths.\r\n                            if (lines[j].substr(lines[j].length - 4) === '.png') {\r\n                                images.push(lines[j]);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return images;\r\n                };\r\n            \r\n            return function (component, props, defaultProps) {\r\n                var arr = null,\r\n                    i = 0,\r\n                    images = null,\r\n                    atlases = platypus.game.settings.atlases,\r\n                    atlas = component.atlas || props.atlas || defaultProps.atlas;\r\n                \r\n                if (Array.isArray(atlas)) {\r\n                    i = atlas.length;\r\n                    images = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n                    while (i--) {\r\n                        arr = getImages(atlas[i], atlases);\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"union\"])(images, arr);\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(arr);\r\n                    }\r\n                    return images;\r\n                } else {\r\n                    return getImages(atlas, atlases);\r\n                }\r\n            };\r\n        }())\r\n    });\r\n})());\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pixi.js */ \"pixi.js\")))\n\n//# sourceURL=webpack://platypus/./src/components/RenderSpine.js?");

/***/ }),

/***/ "./src/components/RenderSprite.js":
/*!****************************************!*\
  !*** ./src/components/RenderSprite.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PIXIAnimation.js */ \"./src/PIXIAnimation.js\");\n/* harmony import */ var _RenderAnimator_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RenderAnimator.js */ \"./src/components/RenderAnimator.js\");\n/* harmony import */ var _RenderContainer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RenderContainer.js */ \"./src/components/RenderContainer.js\");\n/**\r\n * This component is attached to entities that will appear in the game world. It renders a static or animated image. It listens for messages triggered on the entity or changes in the logical state of the entity to play a corresponding animation.\r\n *\r\n * @namespace platypus.components\r\n * @class RenderSprite\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'RenderSprite',\r\n        \r\n        properties: {\r\n            /**\r\n             * An object containg key-value pairs that define a mapping from entity states to the animation that should play. The list is processed from top to bottom, so the most important actions should be listed first (for example, a jumping animation might take precedence over an idle animation). If not specified, an 1-to-1 animation map is created from the list of animations in the sprite sheet definition using the animation names as the keys.\r\n             *\r\n             *  \"animationStates\":{\r\n             *      \"standing\": \"default-animation\"  // On receiving a \"standing\" event, or when this.owner.state.standing === true, the \"default\" animation will begin playing.\r\n             *      \"ground,moving\": \"walking\",  // Comma separated values have a special meaning when evaluating \"state-changed\" messages. The above example will cause the \"walking\" animation to play ONLY if the entity's state includes both \"moving\" and \"ground\" equal to true.\r\n             *      \"ground,striking\": \"swing!\", // Putting an exclamation after an animation name causes this animation to complete before going to the next animation. This is useful for animations that would look poorly if interrupted.\r\n             *      \"default\": \"default-animation\" // Optional. \"default\" is a special property that matches all states. If none of the above states are valid for the entity, it will use the default animation listed here.\r\n             *  }\r\n             *\r\n             * If `stateBased` is `true` and this property is not set, this component will use the `animationMap` property value to define state mappings.\r\n             *\r\n             * @property animationStates\r\n             * @type Object\r\n             * @default animationMap\r\n             */\r\n            animationStates: null,\r\n\r\n            /**\r\n             * An object containg key-value pairs that define a mapping from triggered events to the animation that should play.\r\n             *\r\n             *     \"animationEvents\":{\r\n             *         \"move\": \"walk-animation\",\r\n             *         \"jump\": \"jumping-animation\"\r\n             *     }\r\n             *\r\n             * The above will create two event listeners on the entity, \"move\" and \"jump\", that will play their corresponding animations when the events are triggered.\r\n             *\r\n             * If `eventBased` is `true` and this property is not set, this component will use the `animationMap` property value to define event mappings.\r\n             *\r\n             * @property animationEvents\r\n             * @type Object\r\n             * @default animationMap\r\n             */\r\n            animationEvents: null,\r\n\r\n           /**\r\n             * spriteSheet can either be a String or an object. If a string, the spritesheet data will be loaded from the file with a matching name in the spritesheet folder. Otherwise the definition is in full here. That spritesheet data defines an EaselJS sprite sheet to use for rendering. See https://createjs.com/docs/easeljs/classes/SpriteSheet.html for the full specification.\r\n             *\r\n             *  \"spriteSheet\": 'hero-image'\r\n             *\r\n             *  -OR-\r\n             *\r\n             *  \"spriteSheet\": {\r\n             *\r\n             *      \"images\": [\"example0\", \"example1\"], //Can also define 'image' and give the\r\n             *      \"frames\": {\r\n             *          \"width\":  100,\r\n             *          \"height\": 100,\r\n             *          \"regY\":   100,\r\n             *          \"regX\":   50\r\n             *      },\r\n             *      \"animations\":{\r\n             *          \"default-animation\":[2],\r\n             *          \"walking\": {\"frames\": [0, 1, 2], \"speed\": 4},\r\n             *          \"swing\": {\"frames\": [3, 4, 5], \"speed\": 4}\r\n             *      }\r\n             *  }\r\n             *\r\n             *  -OR- an Array of the above (since 0.8.4)\r\n             *\r\n             * @property spriteSheet\r\n             * @type String|Array|Object\r\n             * @default null\r\n             */\r\n            spriteSheet: null,\r\n\r\n            /**\r\n             * Optional. An object containg key-value pairs that define a mapping from triggered events or entity states to the animation that should play. The list is processed from top to bottom, so the most important actions should be listed first (for example, a jumping animation might take precedence over an idle animation). If not specified, an 1-to-1 animation map is created from the list of animations in the sprite sheet definition using the animation names as the keys.\r\n             *\r\n             *     \"animationMap\":{\r\n             *         \"standing\": \"default-animation\"  // On receiving a \"standing\" event, or when this.owner.state.standing === true, the \"default\" animation will begin playing.\r\n             *         \"ground,moving\": \"walking\",  // Comma separated values have a special meaning when evaluating \"state-changed\" messages. The above example will cause the \"walking\" animation to play ONLY if the entity's state includes both \"moving\" and \"ground\" equal to true.\r\n             *         \"ground,striking\": \"swing!\", // Putting an exclamation after an animation name causes this animation to complete before going to the next animation. This is useful for animations that would look poorly if interrupted.\r\n             *         \"default\": \"default-animation\" // Optional. \"default\" is a special property that matches all states. If none of the above states are valid for the entity, it will use the default animation listed here.\r\n             *     }\r\n             *\r\n             * This data may also be used to create a RenderAnimator component on the entity if the `eventBased` or `stateBased` properties are set to `true`.\r\n             *\r\n             * @property animationMap\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            animationMap: null,\r\n\r\n            /**\r\n             * Optional. A mask definition that determines where the image should clip. A string can also be used to create more complex shapes via the PIXI graphics API like: \"mask\": \"r(10,20,40,40).drawCircle(30,10,12)\". Defaults to no mask or, if simply set to true, a rectangle using the entity's dimensions.\r\n             *\r\n             *  \"mask\": {\r\n             *      \"x\": 10,\r\n             *      \"y\": 10,\r\n             *      \"width\": 40,\r\n             *      \"height\": 40\r\n             *  },\r\n             *\r\n             *  -OR-\r\n             *\r\n             *  \"mask\": \"r(10,20,40,40).drawCircle(30,10,12)\"\r\n             *\r\n             * @property mask\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            mask: null,\r\n\r\n            /**\r\n             * Defines whether the entity will respond to touch and click events. Setting this value will create an Interactive component on this entity with these properties. For example:\r\n             *\r\n             *  \"interactive\": {\r\n             *      \"hover\": false,\r\n             *      \"hitArea\": {\r\n             *          \"x\": 10,\r\n             *          \"y\": 10,\r\n             *          \"width\": 40,\r\n             *          \"height\": 40\r\n             *      }\r\n             *  }\r\n             *\r\n             * @property interactive\r\n             * @type Boolean|Object\r\n             * @default false\r\n             * @since 0.9.0\r\n             */\r\n            interactive: false,\r\n\r\n            /**\r\n             * The offset of the x-axis position of the sprite from the entity's x-axis position.\r\n             *\r\n             * @property offsetX\r\n             * @type Number\r\n             * @default 0\r\n             * @since 0.11.0\r\n             */\r\n            offsetX: 0,\r\n\r\n            /**\r\n             * The offset of the y-axis position of the sprite from the entity's y-axis position.\r\n             *\r\n             * @property offsetY\r\n             * @type Number\r\n             * @default 0\r\n             * @since 0.11.0\r\n             */\r\n            offsetY: 0,\r\n\r\n            /**\r\n             * The z-index relative to other render components on the entity.\r\n             *\r\n             * @property offsetZ\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            offsetZ: 0,\r\n\r\n            /**\r\n             * Whether to restart a playing animation on event.\r\n             *\r\n             * @property restart\r\n             * @type Boolean\r\n             * @default true\r\n             * @since 0.9.2\r\n             */\r\n            restart: true,\r\n\r\n            /**\r\n             * Whether this object can be mirrored over X. To mirror it over X set the this.owner.rotation value to be > 90  and < 270.\r\n             *\r\n             * @property mirror\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            mirror: false,\r\n\r\n            /**\r\n             * Optional. Whether this object can be flipped over Y. To flip it over Y set the this.owner.rotation to be > 180.\r\n             *\r\n             * @property flip\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            flip: false,\r\n\r\n            /**\r\n             * Optional. Whether this object is visible or not. To change the visible value dynamically set this.owner.state.visible to true or false.\r\n             *\r\n             * @property visible\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            visible: true,\r\n\r\n            /**\r\n             * Optional. Specifies whether this component should create an RenderAnimator component to listen to events matching the animationMap to animate. Set this to true if the component should animate for on events. Default is `false`.\r\n             *\r\n             * @property eventBased\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            eventBased: false,\r\n\r\n            /**\r\n             * Optional. Specifies whether this component should create a RenderAnimator component to handle changes in the entity's state that match the animationMap to animate. Set this to true if the component should animate based on `this.owner.state`. Default is `true`.\r\n             *\r\n             * @property stateBased\r\n             * @type Boolean\r\n             * @default true\r\n             */\r\n            stateBased: true,\r\n\r\n            /**\r\n             * Optional. Whether this sprite should be cached into an entity with a `RenderTiles` component (like \"render-layer\"). The `RenderTiles` component must have its \"entityCache\" property set to `true`. Warning! This is a one-direction setting and will remove this component from the entity once the current frame has been cached.\r\n             *\r\n             * @property cache\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            cache: false,\r\n\r\n            /**\r\n             * Optional. When using state-based animations, forces animations to complete before starting a new animation. Defaults to false.\r\n             *\r\n             * @property forcePlayThrough\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            forcePlayThrough: false,\r\n\r\n            /**\r\n             * Optional. Ignores the opacity of the owner. Used when multiple RenderSprite components are on the same entity.\r\n             *\r\n             * @property ignoreOpacity\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            ignoreOpacity: false,\r\n\r\n            /**\r\n             * The scaling factor for this component.\r\n             *\r\n             * @property scale\r\n             * @type Number|Array|Object\r\n             * @default 1\r\n             */\r\n            scale: 1,\r\n\r\n            /**\r\n             * Optional. The X scaling factor for the image. Defaults to 1.\r\n             *\r\n             * @property scaleX\r\n             * @type Number\r\n             * @default 1\r\n             */\r\n            scaleX: 1,\r\n\r\n            /**\r\n             * Optional. The Y scaling factor for the entity. Defaults to 1.\r\n             *\r\n             * @property scaleY\r\n             * @type Number\r\n             * @default 1\r\n             */\r\n            scaleY: 1,\r\n            \r\n            /**\r\n            * The scaling factor for this sprite relative to the scale of the container.\r\n            *\r\n            * @property localScaleX\r\n            * @type Number|Array|Object\r\n            * @default 1\r\n            */\r\n            localScaleX: 1,\r\n\r\n           /**\r\n            * The scaling factor for this sprite relative to the scale of the container.\r\n            *\r\n            * @property localScaleY\r\n            * @type Number|Array|Object\r\n            * @default 1\r\n            */\r\n            localScaleY: 1,\r\n\r\n            /**\r\n             * The skew factor for this component.\r\n             *\r\n             * @property skew\r\n             * @type Number|Array|Object\r\n             * @default 0\r\n             */\r\n            skew: 0,\r\n\r\n            /**\r\n             * Optional. The X skew factor of the entity. Defaults to 0.\r\n             *\r\n             * @property skewX\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            skewX: 0,\r\n\r\n            /**\r\n             * Optional. The Y skew factor for the entity. Defaults to 0.\r\n             *\r\n             * @property skewY\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            skewY: 0\r\n        },\r\n\r\n        initialize: (function () {\r\n            var createAnimationMap = function (animationMap, ss) {\r\n                    var map  = null,\r\n                        anim = '';\r\n\r\n                    if (animationMap) {\r\n                        return animationMap;\r\n                    } else if (Array.isArray(ss.frames) && (ss.frames.length === 1)) {\r\n                        // This is a single frame animation, so no mapping is necessary\r\n                        return null;\r\n                    } else {\r\n                        // Create 1-to-1 animation map since none was defined\r\n                        map = {};\r\n                        for (anim in ss.animations) {\r\n                            if (ss.animations.hasOwnProperty(anim)) {\r\n                                map[anim] = anim;\r\n                            }\r\n                        }\r\n                        return map;\r\n                    }\r\n                },\r\n                animationEnded = function (animation) {\r\n                    /**\r\n                     * This event fires each time an animation completes.\r\n                     *\r\n                     * @event 'animation-ended'\r\n                     * @param animation {String} The id of the animation that ended.\r\n                     */\r\n                    this.owner.triggerEvent('animation-ended', animation);\r\n                };\r\n            \r\n            return function () {\r\n                var animation = '',\r\n                    definition = null,\r\n                    ss = _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].formatSpriteSheet(this.spriteSheet),\r\n                    map  = null;\r\n\r\n                if (ss === _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].EmptySpriteSheet) {\r\n                    platypus.debug.warn('Entity \"' + this.owner.type + '\": RenderSprite sprite sheet not defined.');\r\n                }\r\n                \r\n                map = createAnimationMap(this.animationMap, ss);\r\n                this.stateBased = map && this.stateBased;\r\n                this.eventBased = map && this.eventBased;\r\n                if (map) {\r\n                    animation = map.default || '';\r\n\r\n                    definition = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\r\n                        'animationEvents', this.eventBased ? this.animationEvents || map : null,\r\n                        'animationStates', this.stateBased ? this.animationStates || map : null,\r\n                        'forcePlayThrough', this.forcePlayThrough,\r\n                        'restart', this.restart,\r\n                        'component', this\r\n                    );\r\n                    this.owner.addComponent(new _RenderAnimator_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.owner, definition));\r\n                    definition.recycle();\r\n                }\r\n                \r\n                /*\r\n                 * PIXIAnimation created here:\r\n                 */\r\n                this.sprite = new _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](ss, animation);\r\n                this.sprite.onComplete = animationEnded.bind(this);\r\n                this.sprite.x = this.offsetX;\r\n                this.sprite.y = this.offsetY;\r\n                this.sprite.z = this.offsetZ;\r\n                this.sprite.scale.x = this.localScaleX;\r\n                this.sprite.scale.y = this.localScaleY;\r\n\r\n                if (!this.owner.container) {\r\n                    definition = _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\r\n                        'interactive', this.interactive,\r\n                        'mask', this.mask,\r\n                        'mirror', this.mirror,\r\n                        'flip', this.flip,\r\n                        'visible', this.visible,\r\n                        'cache', this.cache,\r\n                        'ignoreOpacity', this.ignoreOpacity,\r\n                        'scaleX', this.scaleX,\r\n                        'scaleY', this.scaleY,\r\n                        'skewX', this.skewX,\r\n                        'skewY', this.skewY\r\n                    );\r\n                    this.owner.addComponent(new _RenderContainer_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.owner, definition, this.addToContainer.bind(this)));\r\n                    definition.recycle();\r\n                } else {\r\n                    this.addToContainer();\r\n                }\r\n\r\n                ss.recycleSpriteSheet();\r\n            };\r\n        }()),\r\n        \r\n        events: {\r\n            /**\r\n             * The render update message updates the sprite. If a sprite doesn't have a container, it's removed.\r\n             *\r\n             * @method 'handle-render'\r\n             * @param renderData {Object} Data from the render handler\r\n             * @param renderData.container {PIXI.Container} The parent container.\r\n             */\r\n            \"handle-render\": function (renderData) {\r\n                if (this.sprite) {\r\n                    /**\r\n                     * This event is triggered each tick to check for animation updates.\r\n                     *\r\n                     * @event 'update-animation'\r\n                     * @param playing {Boolean} Whether the animation is in a playing or paused state.\r\n                     */\r\n                    this.owner.triggerEvent('update-animation', true);\r\n\r\n                    this.sprite.update(renderData.delta);\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * Stops the sprite's animation.\r\n             *\r\n             * @method 'stop-animation'\r\n             * @param [animation] {String} The animation to show and pause. If not specified, this method simply pauses the current animation.\r\n             * @since 0.9.0\r\n             */\r\n            \"stop-animation\": function (animation) {\r\n                this.stopAnimation(animation);\r\n            },\r\n            \r\n            /**\r\n             * Starts the sprite's animation.\r\n             *\r\n             * @method 'play-animation'\r\n             * @param [animation] {String} The animation to play. If not specified, this method simply unpauses the current animation.\r\n             * @since 0.9.0\r\n             */\r\n            \"play-animation\": function (animation, restart) {\r\n                this.playAnimation(animation, restart);\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            addToContainer: function () {\r\n                var container = this.owner.container;\r\n\r\n                container.addChild(this.sprite);\r\n                container.reorder = true;\r\n            },\r\n            \r\n            playAnimation: function (animation, restart) {\r\n                var sprite = this.sprite;\r\n\r\n                if (animation && sprite.has(animation)) {\r\n                    sprite.gotoAndPlay(animation, restart);\r\n                } else {\r\n                    sprite.play();\r\n                }\r\n            },\r\n\r\n            stopAnimation: function (animation) {\r\n                var sprite = this.sprite;\r\n\r\n                if (animation && sprite.has(animation)) {\r\n                    sprite.gotoAndStop(animation);\r\n                } else {\r\n                    sprite.stop();\r\n                }\r\n            },\r\n\r\n            destroy: function () {\r\n                this.owner.container.removeChild(this.sprite);\r\n                this.sprite.destroy();\r\n                this.sprite = null;\r\n            }\r\n        },\r\n        \r\n        getAssetList: (function () {\r\n            var\r\n                getImages = function (ss, spriteSheets) {\r\n                    if (ss) {\r\n                        if (typeof ss === 'string') {\r\n                            return getImages(spriteSheets[ss], spriteSheets);\r\n                        } else if (ss.images) {\r\n                            return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(ss.images);\r\n                        }\r\n                    }\r\n\r\n                    return _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                };\r\n            \r\n            return function (component, props, defaultProps) {\r\n                var arr = null,\r\n                    i = 0,\r\n                    images = null,\r\n                    spriteSheets = platypus.game.settings.spriteSheets,\r\n                    ss = component.spriteSheet || props.spriteSheet || (defaultProps && defaultProps.spriteSheet) || null;\r\n                \r\n                if (Array.isArray(ss)) {\r\n                    i = ss.length;\r\n                    images = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                    while (i--) {\r\n                        arr = getImages(ss[i], spriteSheets);\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(images, arr);\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\r\n                    }\r\n                    return images;\r\n                } else {\r\n                    return getImages(ss, spriteSheets);\r\n                }\r\n            };\r\n        }())\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderSprite.js?");

/***/ }),

/***/ "./src/components/RenderText.js":
/*!**************************************!*\
  !*** ./src/components/RenderText.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _RenderContainer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RenderContainer.js */ \"./src/components/RenderContainer.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_1__);\n/**\r\n * This component is attached to entities that should display text.\r\n *\r\n * @namespace platypus.components\r\n * @class RenderText\r\n * @uses platypus.Component\r\n * @since v0.11.9\r\n */\r\n/*global platypus */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \"use strict\";\r\n    \r\n    const\r\n        alignments = {\r\n            horizontal: {\r\n                left: 0,\r\n                middle: 0.5,\r\n                center: 0.5,\r\n                right: 1\r\n            },\r\n            vertical: {\r\n                top: 0,\r\n                middle: 0.5,\r\n                center: 0.5,\r\n                bottom: 1\r\n            }\r\n        };\r\n    \r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'RenderText',\r\n        \r\n        properties: {\r\n            /**\r\n             * The offset of the x-axis position of the text from the entity's x-axis position.\r\n             *\r\n             * @property offsetX\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            offsetX: 0,\r\n\r\n            /**\r\n             * The offset of the y-axis position of the text from the entity's y-axis position.\r\n             *\r\n             * @property offsetY\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            offsetY: 0,\r\n\r\n            /**\r\n             * The z-index relative to other render components on the entity.\r\n             *\r\n             * @property offsetZ\r\n             * @type Number\r\n             * @default 0\r\n             */\r\n            offsetZ: 0,\r\n\r\n            /**\r\n             * This is the text to display.\r\n             *\r\n             * @property text\r\n             * @type String\r\n             * @default \"\"\r\n             */\r\n            text: \"\",\r\n            \r\n            /**\r\n             * This is the text style to use. Use the following specification to define the style:\r\n             *\r\n             *     {\r\n             *         \"fontSize\": \"64px\",\r\n             *         \"fill\": \"#ffffff\",\r\n             *         \"align\": \"center\", // Can be `left`, `center`, or `right`\r\n             *         \"fontFamily\": \"arial\", // Any CSS font that has been loaded by the browser\r\n             *         \"verticalAlign\": \"bottom\" // Can be `top`, `center`, or `bottom`\r\n             *     }\r\n             *\r\n             * See [PIXI.TextStyle documentation](http://pixijs.download/dev/docs/PIXI.TextStyle.html) for a full list of available options.\r\n             *\r\n             * @property style\r\n             * @type Object\r\n             * @default null\r\n             */\r\n            style: null\r\n        },\r\n        \r\n        initialize: function (definition) {\r\n            var hAlign = alignments.horizontal[this.style.align],\r\n                vAlign = alignments.vertical[this.style.verticalAlign];\r\n\r\n            this.sprite = new pixi_js__WEBPACK_IMPORTED_MODULE_1__[\"Text\"](this.text, this.style);\r\n            \r\n            this.sprite.anchor.x = typeof hAlign === 'number' ? hAlign : 0.5;\r\n            this.sprite.anchor.y = typeof vAlign === 'number' ? vAlign : 1;\r\n            this.sprite.x = this.offsetX;\r\n            this.sprite.y = this.offsetY;\r\n            this.sprite.z = this.offsetZ;\r\n\r\n            if (!this.owner.container) {\r\n                this.owner.addComponent(new _RenderContainer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.owner, definition, this.addToContainer.bind(this)));\r\n            } else {\r\n                this.addToContainer();\r\n            }\r\n        },\r\n        \r\n        events: {\r\n            /**\r\n             * Sets the copy of the text.\r\n             *\r\n             * @method 'set-text'\r\n             * @param text {String} The text to insert.\r\n             */\r\n            \"set-text\": function (text) {\r\n                if (typeof text === 'string') {\r\n                    this.sprite.text = text;\r\n                } else {\r\n                    if (text.style) {\r\n                        const textStyle = this.sprite.style;\r\n                        for (const key in text.style) {\r\n                            if (text.style.hasOwnProperty(key)) {\r\n                                textStyle[key] = text.style[key];\r\n                            }\r\n                        }\r\n                    }\r\n                    if (typeof text.text === 'string') {\r\n                        this.sprite.text = text.text;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            addToContainer: function () {\r\n                var container = this.owner.container;\r\n\r\n                container.addChild(this.sprite);\r\n                container.reorder = true;\r\n            },\r\n            \r\n            destroy: function () {\r\n                this.owner.container.removeChild(this.sprite);\r\n                this.sprite.destroy();\r\n                this.sprite = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderText.js?");

/***/ }),

/***/ "./src/components/RenderTiles.js":
/*!***************************************!*\
  !*** ./src/components/RenderTiles.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../PIXIAnimation.js */ \"./src/PIXIAnimation.js\");\n/* harmony import */ var _RenderContainer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RenderContainer.js */ \"./src/components/RenderContainer.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\r\n * This component handles rendering tile map backgrounds.\r\n *\r\n * When rendering the background, this component figures out what tiles are being displayed and caches them so they are rendered as one image rather than individually.\r\n *\r\n * As the camera moves, the cache is updated by blitting the relevant part of the old cached image into a new cache and then rendering tiles that have shifted into the camera's view into the cache.\r\n *\r\n * @namespace platypus.components\r\n * @class RenderTiles\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var EDGE_BLEED = 1,\r\n        EDGES_BLEED = EDGE_BLEED * 2,\r\n        clearRenderTexture = function (renderer, renderTexture, clearColor) { // This is pulled from https://github.com/pixijs/pixi.js/pull/3647 and should be in a future build of PIXI\r\n            var baseTexture = renderTexture.baseTexture,\r\n                renderTarget = baseTexture._glRenderTargets[renderer.CONTEXT_UID];\r\n                \r\n            if (renderTarget) {\r\n                renderTarget.clear(clearColor);\r\n            }\r\n        },\r\n        doNothing = function () {\r\n            return null;\r\n        },\r\n        tempCache = _AABB_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(),\r\n        sort = function (a, b) {\r\n            return a.z - b.z;\r\n        },\r\n        getPowerOfTwo = function (amount) {\r\n            var x = 1;\r\n\r\n            while (x < amount) {\r\n                x *= 2;\r\n            }\r\n\r\n            return x;\r\n        },\r\n        transformCheck = function (value, tile) {\r\n            var v = +(value.substring(4)),\r\n                x = 0;\r\n\r\n            if (0x80000000 & v) {\r\n                tile.scale.x = -1;\r\n            }\r\n            if (0x40000000 & v) {\r\n                tile.scale.y = -1;\r\n            }\r\n            if (0x20000000 & v) {\r\n                x = tile.scale.x;\r\n                tile.scale.x = tile.scale.y;\r\n                tile.scale.y = -x;\r\n                tile.rotation = Math.PI / 2;\r\n            }\r\n\r\n            return 0x0fffffff & v;\r\n        },\r\n        Template = function (tile, id) {\r\n            this.id = id;\r\n            this.instances = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(tile);\r\n            this.index = 0;\r\n            tile.template = this; // backwards reference for clearing index later.\r\n        },\r\n        nullTemplate = {\r\n            getNext: doNothing,\r\n            destroy: doNothing\r\n        },\r\n        prototype = Template.prototype;\r\n\r\n    prototype.getNext = function () {\r\n        var instance = this.instances[this.index],\r\n            template = null;\r\n\r\n        if (!instance) {\r\n            template = this.instances[0];\r\n            instance = this.instances[this.index] = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"](template.texture);\r\n\r\n            // Copy properties\r\n            instance.scale    = template.scale;\r\n            instance.rotation = template.rotation;\r\n            instance.anchor   = template.anchor;\r\n        }\r\n\r\n        this.index += 1;\r\n\r\n        return instance;\r\n    };\r\n\r\n    prototype.clear = function () {\r\n        this.index = 0;\r\n    };\r\n    \r\n    prototype.destroy = function () {\r\n        var i = 0;\r\n        \r\n        for (i = 0; i < this.instances.length; i++) {\r\n            this.instances[i].destroy();\r\n        }\r\n        \r\n        _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.instances);\r\n        this.recycle();\r\n    };\r\n\r\n    recycle__WEBPACK_IMPORTED_MODULE_6__[\"default\"].add(Template, 'Template', Template, null, true, config__WEBPACK_IMPORTED_MODULE_5___default.a.dev);\r\n\r\n    return platypus.createComponentClass({\r\n\r\n        id: 'RenderTiles',\r\n\r\n        properties: {\r\n            /**\r\n             * The amount of space in pixels around the edge of the camera that we include in the buffered image. If not set, largest buffer allowed by maximumBuffer is used.\r\n             *\r\n             * @property buffer\r\n             * @type number\r\n             * @default 0\r\n             */\r\n            buffer: 0,\r\n\r\n            /**\r\n             * Determines whether to cache the entire map across one or more texture caches. By default this is `false`; however, if the entire map fits on one or two texture caches, this is set to `true` since it is more efficient than dynamic buffering.\r\n             *\r\n             * @property cacheAll\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            cacheAll: false,\r\n\r\n            /**\r\n             * Whether to cache entities on this layer if the entity's render component requests caching.\r\n             *\r\n             * @property entityCache\r\n             * @type boolean\r\n             * @default false\r\n             */\r\n            entityCache: false,\r\n\r\n            /**\r\n             * This is a two dimensional array of the spritesheet indexes that describe the map that you're rendering.\r\n             *\r\n             * @property imageMap\r\n             * @type Array\r\n             * @default []\r\n             */\r\n            imageMap: [],\r\n\r\n            /**\r\n             * The amount of space that is buffered. Defaults to 2048 x 2048 or a smaller area that encloses the tile layer.\r\n             *\r\n             * @property maximumBuffer\r\n             * @type number\r\n             * @default 2048\r\n             */\r\n            maximumBuffer: 2048,\r\n\r\n            /**\r\n             * The x-scale the tilemap is being displayed at.\r\n             *\r\n             * @property scaleX\r\n             * @type number\r\n             * @default 1\r\n             */\r\n            scaleX: 1,\r\n\r\n            /**\r\n             * The y-scale the tilemap is being displayed at.\r\n             *\r\n             * @property scaleY\r\n             * @type number\r\n             * @default 1\r\n             */\r\n            scaleY: 1,\r\n\r\n            /**\r\n             * A sprite sheet describing all the tile images.\r\n             *\r\n             * Accepts an array of sprite sheet data since 0.8.4\r\n             *\r\n             * @property spriteSheet\r\n             * @type Object|Array|String\r\n             * @default null\r\n             */\r\n            spriteSheet: null,\r\n\r\n            /**\r\n             * Whether to cache the tile map to a large texture.\r\n             *\r\n             * @property tileCache\r\n             * @type boolean\r\n             * @default true\r\n             * @since 0.6.4\r\n             */\r\n            tileCache: true,\r\n\r\n            /**\r\n             * This is the height in pixels of individual tiles.\r\n             *\r\n             * @property tileHeight\r\n             * @type number\r\n             * @default 10\r\n             */\r\n            tileHeight: 10,\r\n\r\n            /**\r\n             * This is the width in pixels of individual tiles.\r\n             *\r\n             * @property tileWidth\r\n             * @type number\r\n             * @default 10\r\n             */\r\n            tileWidth: 10,\r\n            \r\n            /**\r\n             * The map's top offset.\r\n             *\r\n             * @property top\r\n             * @type Number\r\n             * @default 0\r\n             * @since 0.7.5\r\n             */\r\n            top: 0,\r\n            \r\n            /**\r\n             * The map's left offset.\r\n             *\r\n             * @property left\r\n             * @type Number\r\n             * @default 0\r\n             * @since 0.7.5\r\n             */\r\n            left: 0\r\n        },\r\n\r\n        initialize: function (definition) {\r\n            var imgMap = this.imageMap;\r\n\r\n            this.doMap            = null; //list of display objects that should overlay tile map.\r\n            this.cachedDisplayObjects = null;\r\n            this.populate         = this.populateTiles;\r\n\r\n            this.tiles            = {};\r\n\r\n            this.renderer         = platypus.game.renderer;\r\n            this.tilesSprite      = null;\r\n            this.cacheTexture     = null;\r\n            this.mapContainer      = null;\r\n            this.laxCam = _AABB_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp();\r\n\r\n            // temp values\r\n            this.worldWidth    = this.tileWidth;\r\n            this.worldHeight   = this.tileHeight;\r\n\r\n            this.cache = _AABB_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp();\r\n            this.cachePixels = _AABB_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp();\r\n\r\n            // Set up containers\r\n            this.spriteSheet = _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].formatSpriteSheet(this.spriteSheet);\r\n            this.tileContainer = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"]();\r\n            this.mapContainer = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"]();\r\n            this.mapContainer.addChild(this.tileContainer);\r\n            \r\n            this.reorderedStage = false;\r\n            this.updateCache = false;\r\n\r\n            // Prepare map tiles\r\n            this.imageMap = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(this.createMap(imgMap));\r\n\r\n            this.tilesWidth  = this.imageMap[0].length;\r\n            this.tilesHeight = this.imageMap[0][0].length;\r\n            this.layerWidth  = this.tilesWidth  * this.tileWidth;\r\n            this.layerHeight = this.tilesHeight * this.tileHeight;\r\n\r\n            // Set up buffer cache size\r\n            this.cacheWidth  = Math.min(getPowerOfTwo(this.layerWidth  + EDGES_BLEED), this.maximumBuffer);\r\n            this.cacheHeight = Math.min(getPowerOfTwo(this.layerHeight + EDGES_BLEED), this.maximumBuffer);\r\n\r\n            if (!this.tileCache) {\r\n                this.buffer = 0; // prevents buffer logic from running if tiles aren't being cached.\r\n                this.cacheAll = false; // so tiles are updated as camera moves.\r\n            }\r\n\r\n            this.ready = false;\r\n\r\n            if (!this.owner.container) {\r\n                this.owner.addComponent(new _RenderContainer_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.owner, definition, this.addToContainer.bind(this)));\r\n            } else {\r\n                this.addToContainer();\r\n            }\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * If this component should cache entities, it checks peers for a \"renderCache\" display object and adds the display object to its list of objects to render on top of the tile set.\r\n             *\r\n             * @method 'cache-sprite'\r\n             * @param entity {platypus.Entity} This is the peer entity to be checked for a renderCache.\r\n             */\r\n            \"cache-sprite\": function (entity) {\r\n                this.cacheSprite(entity);\r\n            },\r\n\r\n            /**\r\n             * If this component should cache entities, it checks peers for a \"renderCache\" display object and adds the display object to its list of objects to render on top of the tile set.\r\n             *\r\n             * @method 'peer-entity-added'\r\n             * @param entity {platypus.Entity} This is the peer entity to be checked for a renderCache.\r\n             */\r\n            \"peer-entity-added\": function (entity) {\r\n                this.cacheSprite(entity);\r\n            },\r\n\r\n            /**\r\n             * This event adds a layer of tiles to render on top of the existing layer of rendered tiles.\r\n             *\r\n             * @method 'add-tiles'\r\n             * @param message.imageMap {Array} This is a 2D mapping of tile indexes to be rendered.\r\n             */\r\n            \"add-tiles\": function (definition) {\r\n                var map = definition.imageMap;\r\n\r\n                if (map) {\r\n                    this.imageMap.push(this.createMap(map));\r\n                    this.updateCache = true;\r\n                }\r\n            },\r\n\r\n            /**\r\n             * This event edits the tile index of a rendered tile.\r\n             *\r\n             * @method 'change-tile'\r\n             * @param tile {String} A string representing the name of the tile to switch to.\r\n             * @param x {Number} The column of the tile to edit.\r\n             * @param y {Number} The row of the tile to edit.\r\n             * @param [z] {Number} If RenderTiles has multiple layers, this value specifies the layer, with `0` being the bottom-most layer.\r\n             */\r\n            \"change-tile\": function (tile, x, y, z) {\r\n                var map = this.imageMap;\r\n\r\n                if (map) {\r\n                    this.updateTile(tile, map[z || 0], x, y);\r\n                    this.updateCache = true;\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Provides the width and height of the world.\r\n             *\r\n             * @method 'camera-loaded'\r\n             * @param camera {Object}\r\n             * @param camera.world {platypus.AABB} The dimensions of the world.\r\n             * @param camera.viewport {platypus.AABB} The AABB describing the camera viewport in world units.\r\n             */\r\n            \"camera-loaded\": function (camera) {\r\n                this.worldWidth  = camera.world.width;\r\n                this.worldHeight = camera.world.height;\r\n\r\n                if (this.buffer && !this.cacheAll) { // do this here to set the correct mask before the first caching.\r\n                    this.updateBufferRegion(camera.viewport);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Triggered when the camera moves, this function updates which tiles need to be rendered and caches the image.\r\n             *\r\n             * @method 'camera-update'\r\n             * @param camera {Object} Provides information about the camera.\r\n             * @param camera.viewport {platypus.AABB} The AABB describing the camera viewport in world units.\r\n             */\r\n            \"camera-update\": function (camera) {\r\n                if (this.ready) {\r\n                    this.updateCamera(camera);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * On receiving this message, determines whether to update which tiles need to be rendered and caches the image.\r\n             *\r\n             * @method 'handle-render'\r\n             */\r\n            \"handle-render\": function () {\r\n                if (this.updateCache) {\r\n                    this.updateCache = false;\r\n                    if (this.cacheGrid) {\r\n                        this.updateGrid();\r\n                    } else {\r\n                        this.update(this.cacheTexture, this.cache);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        methods: {\r\n            addToContainer: function () {\r\n                var container = this.container = this.owner.container,\r\n                    extrusionMargin = 2,\r\n                    mapContainer = this.mapContainer,\r\n                    sprite = null,\r\n                    z = this.owner.z;\r\n\r\n                container.reorder = true;\r\n\r\n                this.ready = true;\r\n\r\n                this.updateRegion(0);\r\n\r\n                if (!this.tileCache) {\r\n                    this.render = doNothing;\r\n\r\n                    mapContainer.scale.x = this.scaleX;\r\n                    mapContainer.scale.y = this.scaleY;\r\n                    mapContainer.x = this.left;\r\n                    mapContainer.y = this.top;\r\n                    mapContainer.z = z;\r\n                    container.addChild(mapContainer);\r\n                } else {\r\n                    this.mapContainerWrapper = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"]();\r\n                    this.mapContainerWrapper.addChild(mapContainer);\r\n\r\n                    if ((this.layerWidth <= this.cacheWidth) && (this.layerHeight <= this.cacheHeight)) { // We never need to recache.\r\n                        this.cacheAll   = true;\r\n\r\n                        this.render = this.renderCache;\r\n                        this.cacheTexture = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"RenderTexture\"].create(this.cacheWidth, this.cacheHeight);\r\n\r\n                        this.tilesSprite = sprite = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"](this.cacheTexture);\r\n                        sprite.scale.x = this.scaleX;\r\n                        sprite.scale.y = this.scaleY;\r\n                        sprite.z = z;\r\n\r\n                        this.cache.setBounds(0, 0, this.tilesWidth - 1, this.tilesHeight - 1);\r\n                        this.update(this.cacheTexture, this.cache);\r\n                        container.addChild(sprite);\r\n                    } else if (this.cacheAll || ((this.layerWidth <= this.cacheWidth * 2) && (this.layerHeight <= this.cacheHeight)) || ((this.layerWidth <= this.cacheWidth) && (this.layerHeight <= this.cacheHeight * 2))) { // We cache everything across several textures creating a cache grid.\r\n                        this.cacheAll = true;\r\n\r\n                        // Make sure there's room for the one-pixel extrusion around edges of caches\r\n                        this.cacheWidth = Math.min(getPowerOfTwo(this.layerWidth + extrusionMargin), this.maximumBuffer);\r\n                        this.cacheHeight = Math.min(getPowerOfTwo(this.layerHeight + extrusionMargin), this.maximumBuffer);\r\n                        this.updateRegion(extrusionMargin);\r\n\r\n                        this.render = this.renderCacheWithExtrusion;\r\n                        this.cacheGrid = this.createGrid(container);\r\n\r\n                        this.updateCache = true;\r\n                    } else {\r\n                        this.render = this.renderCache;\r\n                        this.cacheAll = false;\r\n\r\n                        this.cacheTexture = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"RenderTexture\"].create(this.cacheWidth, this.cacheHeight);\r\n\r\n                        this.tilesSprite = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"](this.cacheTexture);\r\n                        this.tilesSprite.scale.x = this.scaleX;\r\n                        this.tilesSprite.scale.y = this.scaleY;\r\n                        this.tilesSprite.z = z;\r\n\r\n                        // Set up copy buffer and circular pointers\r\n                        this.cacheTexture.alternate = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"RenderTexture\"].create(this.cacheWidth, this.cacheHeight);\r\n                        this.tilesSpriteCache = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"](this.cacheTexture.alternate);\r\n\r\n                        this.cacheTexture.alternate.alternate = this.cacheTexture;\r\n                        container.addChild(this.tilesSprite);\r\n                    }\r\n                }\r\n            },\r\n\r\n            cacheSprite: function (entity) {\r\n                var x = 0,\r\n                    y = 0,\r\n                    object = entity.cacheRender,\r\n                    bounds = null,\r\n                    top = 0,\r\n                    bottom = 0,\r\n                    right = 0,\r\n                    left = 0;\r\n\r\n                // Determine whether to merge this image with the background.\r\n                if (this.entityCache && object) { //TODO: currently only handles a single display object on the cached entity.\r\n                    if (!this.doMap) {\r\n                        this.doMap = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n                        this.cachedDisplayObjects = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n                        this.populate = this.populateTilesAndEntities;\r\n                    }\r\n                    this.cachedDisplayObjects.push(object);\r\n\r\n                    // Determine range:\r\n                    bounds = object.getBounds(object.transformMatrix);\r\n                    bounds.x -= this.left;\r\n                    bounds.y -= this.top;\r\n                    top    = Math.max(0, Math.floor(bounds.y / this.tileHeight));\r\n                    bottom = Math.min(this.tilesHeight, Math.ceil((bounds.y + bounds.height) / this.tileHeight));\r\n                    left   = Math.max(0, Math.floor(bounds.x / this.tileWidth));\r\n                    right  = Math.min(this.tilesWidth, Math.ceil((bounds.x + bounds.width) / this.tileWidth));\r\n\r\n                    // Find tiles that should include this display object\r\n                    for (x = left; x < right; x++) {\r\n                        if (!this.doMap[x]) {\r\n                            this.doMap[x] = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n                        }\r\n                        for (y = top; y < bottom; y++) {\r\n                            if (!this.doMap[x][y]) {\r\n                                this.doMap[x][y] = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n                            }\r\n                            this.doMap[x][y].push(object);\r\n                        }\r\n                    }\r\n\r\n                    // Prevent subsequent draws\r\n                    entity.removeComponent('RenderSprite');\r\n\r\n                    this.updateCache = true; //TODO: This currently causes a blanket cache update - may be worthwhile to only recache if this entity's location is currently in a cache (either cacheGrid or the current viewable area).\r\n                }\r\n            },\r\n\r\n            convertCamera: function (camera) {\r\n                var worldWidth  = this.worldWidth / this.scaleX,\r\n                    worldPosX   = worldWidth - camera.width,\r\n                    worldHeight = this.worldHeight / this.scaleY,\r\n                    worldPosY   = worldHeight - camera.height,\r\n                    laxCam      = this.laxCam;\r\n\r\n                if ((worldWidth === this.layerWidth) || !worldPosX) {\r\n                    laxCam.moveX(camera.x);\r\n                } else {\r\n                    laxCam.moveX((camera.left - this.left) * (this.layerWidth - camera.width) / worldPosX + camera.halfWidth + this.left);\r\n                }\r\n\r\n                if ((worldHeight === this.layerHeight) || !worldPosY) {\r\n                    laxCam.moveY(camera.y);\r\n                } else {\r\n                    laxCam.moveY((camera.top - this.top) * (this.layerHeight - camera.height) / worldPosY + camera.halfHeight + this.top);\r\n                }\r\n\r\n                if (camera.width !== laxCam.width || camera.height !== laxCam.height) {\r\n                    laxCam.resize(camera.width, camera.height);\r\n                }\r\n\r\n                return laxCam;\r\n            },\r\n\r\n            createTile: function (imageName) {\r\n                var tile = null,\r\n                    anim = '';\r\n\r\n                // \"tile-1\" is empty, so it remains a null reference.\r\n                if (imageName === 'tile-1') {\r\n                    return nullTemplate;\r\n                }\r\n\r\n                tile = new _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.spriteSheet);\r\n                anim = 'tile' + transformCheck(imageName, tile);\r\n                tile.gotoAndStop(anim);\r\n\r\n                return Template.setUp(tile, imageName);\r\n            },\r\n\r\n            createMap: function (mapDefinition) {\r\n                var x = 0,\r\n                    y = 0,\r\n                    index = '',\r\n                    map   = null;\r\n\r\n                if (typeof mapDefinition[0][0] !== 'string') { // This is not a map definition: it's an actual RenderTiles map.\r\n                    return mapDefinition;\r\n                }\r\n\r\n                map = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n                for (x = 0; x < mapDefinition.length; x++) {\r\n                    map[x] = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n                    for (y = 0; y < mapDefinition[x].length; y++) {\r\n                        index = mapDefinition[x][y];\r\n                        this.updateTile(index, map, x, y);\r\n                    }\r\n                }\r\n                \r\n                return map;\r\n            },\r\n            \r\n            updateCamera: function (camera) {\r\n                var x = 0,\r\n                    y = 0,\r\n                    inFrame = false,\r\n                    sprite  = null,\r\n                    ctw     = 0,\r\n                    cth     = 0,\r\n                    ctw2    = 0,\r\n                    cth2    = 0,\r\n                    cache   = this.cache,\r\n                    cacheP  = this.cachePixels,\r\n                    vp      = camera.viewport,\r\n                    resized = (this.buffer && ((vp.width !== this.laxCam.width) || (vp.height !== this.laxCam.height))),\r\n                    tempC   = tempCache,\r\n                    laxCam  = this.convertCamera(vp);\r\n\r\n                if (!this.cacheAll && (cacheP.empty || !cacheP.contains(laxCam)) && (this.imageMap.length > 0)) {\r\n                    if (resized) {\r\n                        this.updateBufferRegion(laxCam);\r\n                    }\r\n                    ctw     = this.cacheTilesWidth - 1;\r\n                    cth     = this.cacheTilesHeight - 1;\r\n                    ctw2    = ctw / 2;\r\n                    cth2    = cth / 2;\r\n\r\n                    //only attempt to draw children that are relevant\r\n                    tempC.setAll(Math.round((laxCam.x - this.left) / this.tileWidth - ctw2) + ctw2, Math.round((laxCam.y - this.top) / this.tileHeight - cth2) + cth2, ctw, cth);\r\n                    if (tempC.left < 0) {\r\n                        tempC.moveX(tempC.halfWidth);\r\n                    } else if (tempC.right > this.tilesWidth - 1) {\r\n                        tempC.moveX(this.tilesWidth - 1 - tempC.halfWidth);\r\n                    }\r\n                    if (tempC.top < 0) {\r\n                        tempC.moveY(tempC.halfHeight);\r\n                    } else if (tempC.bottom > this.tilesHeight - 1) {\r\n                        tempC.moveY(this.tilesHeight - 1 - tempC.halfHeight);\r\n                    }\r\n                    \r\n                    if (!this.tileCache) {\r\n                        this.update(null, tempC);\r\n                    } else if (cache.empty || !tempC.contains(cache)) {\r\n                        this.tilesSpriteCache.texture = this.cacheTexture;\r\n                        this.cacheTexture = this.cacheTexture.alternate;\r\n                        this.tilesSprite.texture = this.cacheTexture;\r\n                        this.update(this.cacheTexture, tempC, this.tilesSpriteCache, cache);\r\n                    }\r\n\r\n                    // Store pixel bounding box for checking later.\r\n                    cacheP.setAll((cache.x + 0.5) * this.tileWidth + this.left, (cache.y + 0.5) * this.tileHeight + this.top, (cache.width + 1) * this.tileWidth, (cache.height + 1) * this.tileHeight);\r\n                }\r\n\r\n                if (this.cacheGrid) {\r\n                    for (x = 0; x < this.cacheGrid.length; x++) {\r\n                        for (y = 0; y < this.cacheGrid[x].length; y++) {\r\n                            sprite = this.cacheGrid[x][y];\r\n                            cacheP.setAll((x + 0.5) * this.cacheClipWidth + this.left, (y + 0.5) * this.cacheClipHeight + this.top, this.cacheClipWidth, this.cacheClipHeight);\r\n\r\n                            inFrame = cacheP.intersects(laxCam);\r\n                            if (sprite.visible && !inFrame) {\r\n                                sprite.visible = false;\r\n                            } else if (!sprite.visible && inFrame) {\r\n                                sprite.visible = true;\r\n                            }\r\n                            \r\n                            if (sprite.visible && inFrame) {\r\n                                sprite.x = vp.left - laxCam.left + x * this.cacheClipWidth + this.left;\r\n                                sprite.y = vp.top  - laxCam.top  + y * this.cacheClipHeight + this.top;\r\n                            }\r\n                        }\r\n                    }\r\n                } else if (this.tileCache) {\r\n                    this.tilesSprite.x = vp.left - laxCam.left + cache.left * this.tileWidth + this.left;\r\n                    this.tilesSprite.y = vp.top  - laxCam.top  + cache.top  * this.tileHeight + this.top;\r\n                }\r\n            },\r\n\r\n            updateTile: function (index, map, x, y) {\r\n                var tile = null,\r\n                    tiles = this.tiles;\r\n                \r\n                if (index.id) {\r\n                    index = index.id;\r\n                }\r\n                tile = tiles[index];\r\n                if (!tile && (tile !== null)) { // Empty grid spaces are null, so we needn't create a new tile.\r\n                    tile = tiles[index] = this.createTile(index);\r\n                }\r\n                map[x][y] = tile;\r\n            },\r\n\r\n            createGrid: function (container) {\r\n                var ch = this.cacheHeight,\r\n                    cw = this.cacheWidth,\r\n                    cth = this.cacheTilesHeight,\r\n                    ctw = this.cacheTilesWidth,\r\n                    h = 0,\r\n                    w = 0,\r\n                    outerMargin = EDGES_BLEED,\r\n                    extrusion = EDGE_BLEED,\r\n                    rt = null,\r\n                    sx = this.scaleX,\r\n                    sy = this.scaleY,\r\n                    th = this.tileHeight,\r\n                    tw = this.tileWidth,\r\n                    tsh = this.tilesHeight,\r\n                    tsw = this.tilesWidth,\r\n                    x = 0,\r\n                    y = 0,\r\n                    z = this.owner.z,\r\n                    col = null,\r\n                    ct = null,\r\n                    cg = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n\r\n                for (x = 0; x < tsw; x += ctw) {\r\n                    col = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n                    cg.push(col);\r\n                    for (y = 0; y < tsh; y += cth) {\r\n                        // This prevents us from using too large of a cache for the right and bottom edges of the map.\r\n                        w = Math.min(getPowerOfTwo((tsw - x) * tw + outerMargin), cw);\r\n                        h = Math.min(getPowerOfTwo((tsh - y) * th + outerMargin), ch);\r\n\r\n                        rt = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"RenderTexture\"].create(w, h);\r\n                        rt.frame = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Rectangle\"](extrusion, extrusion, (((w - outerMargin) / tw) >> 0) * tw + extrusion, (((h - outerMargin) / th) >> 0) * th + extrusion);\r\n                        ct = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"](rt);\r\n                        ct.z = z;\r\n                        ct.scale.x = sx;\r\n                        ct.scale.y = sy;\r\n                        col.push(ct);\r\n                        container.addChild(ct);\r\n\r\n                        z -= 0.000001; // so that tiles of large caches overlap consistently.\r\n                    }\r\n                }\r\n                \r\n                return cg;\r\n            },\r\n            \r\n            updateRegion: function (margin) {\r\n                var tw = this.tileWidth * this.scaleX,\r\n                    th = this.tileHeight * this.scaleY,\r\n                    ctw = Math.min(this.tilesWidth,  ((this.cacheWidth - EDGES_BLEED)  / tw)  >> 0),\r\n                    cth = Math.min(this.tilesHeight, ((this.cacheHeight - EDGES_BLEED) / th) >> 0);\r\n\r\n                if (!ctw) {\r\n                    platypus.debug.warn('\"' + this.owner.type + '\" RenderTiles: The tiles are ' + tw + 'px wide which is larger than ' + (this.cacheWidth - EDGES_BLEED) + 'px (maximum cache size of ' + this.cacheWidth + 'px minus a 2px edge bleed). Increase the maximum cache size or reduce tile size.');\r\n                }\r\n                if (!cth) {\r\n                    platypus.debug.warn('\"' + this.owner.type + '\" RenderTiles: The tiles are ' + th + 'px high which is larger than ' + (this.cacheHeight - EDGES_BLEED) + 'px (maximum cache size of ' + this.cacheHeight + 'px minus a 2px edge bleed). Increase the maximum cache size or reduce tile size.');\r\n                }\r\n\r\n                this.cacheTilesWidth  = ctw;\r\n                this.cacheTilesHeight = cth;\r\n                this.cacheClipWidth   = ctw * tw;\r\n                this.cacheClipHeight  = cth * th;\r\n\r\n                if (this.tileCache) {\r\n                    this.mapContainer.mask = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"]().beginFill(0x000000).drawRect(0, 0, this.cacheClipWidth + margin, this.cacheClipHeight + margin).endFill();\r\n                }\r\n            },\r\n\r\n            updateBufferRegion: function (viewport) {\r\n                var tw = this.tileWidth * this.scaleX,\r\n                    th = this.tileHeight * this.scaleY;\r\n\r\n                this.cacheTilesWidth  = Math.min(this.tilesWidth,  Math.ceil((viewport.width  + this.buffer * 2) / tw), (this.cacheWidth  / tw) >> 0);\r\n                this.cacheTilesHeight = Math.min(this.tilesHeight, Math.ceil((viewport.height + this.buffer * 2) / th), (this.cacheHeight / th) >> 0);\r\n\r\n                this.cacheClipWidth   = this.cacheTilesWidth  * tw;\r\n                this.cacheClipHeight  = this.cacheTilesHeight * th;\r\n\r\n                this.mapContainer.mask = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"]().beginFill(0x000000).drawRect(0, 0, this.cacheClipWidth, this.cacheClipHeight).endFill();\r\n            },\r\n\r\n            update: function (texture, bounds, tilesSpriteCache, oldBounds) {\r\n                this.populate(bounds, oldBounds);\r\n\r\n                this.render(bounds, texture, this.mapContainer, this.mapContainerWrapper, tilesSpriteCache, oldBounds);\r\n\r\n                if (oldBounds) {\r\n                    oldBounds.set(bounds);\r\n                }\r\n            },\r\n            \r\n            populateTiles: function (bounds, oldBounds) {\r\n                var x = 0,\r\n                    y = 0,\r\n                    z = 0,\r\n                    layer = 0,\r\n                    tile  = null,\r\n                    tiles = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n\r\n                this.tileContainer.removeChildren();\r\n                for (x = bounds.left; x <= bounds.right; x++) {\r\n                    for (y = bounds.top; y <= bounds.bottom; y++) {\r\n                        if (!oldBounds || oldBounds.empty || (y > oldBounds.bottom) || (y < oldBounds.top) || (x > oldBounds.right) || (x < oldBounds.left)) {\r\n                            for (layer = 0; layer < this.imageMap.length; layer++) {\r\n                                tile = this.imageMap[layer][x][y].getNext();\r\n                                if (tile) {\r\n                                    if (tile.template) {\r\n                                        tiles.push(tile.template);\r\n                                    }\r\n                                    tile.x = (x + 0.5) * this.tileWidth;\r\n                                    tile.y = (y + 0.5) * this.tileHeight;\r\n                                    this.tileContainer.addChild(tile);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Clear out tile instances\r\n                for (z = 0; z < tiles.length; z++) {\r\n                    tiles[z].clear();\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(tiles);\r\n            },\r\n            \r\n            populateTilesAndEntities: function (bounds, oldBounds) {\r\n                var x = 0,\r\n                    y = 0,\r\n                    z = 0,\r\n                    layer   = 0,\r\n                    tile    = null,\r\n                    ent     = null,\r\n                    ents    = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\r\n                    tiles   = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\r\n                    oList   = null;\r\n\r\n                this.tileContainer.removeChildren();\r\n                for (x = bounds.left; x <= bounds.right; x++) {\r\n                    for (y = bounds.top; y <= bounds.bottom; y++) {\r\n                        if (!oldBounds || oldBounds.empty || (y > oldBounds.bottom) || (y < oldBounds.top) || (x > oldBounds.right) || (x < oldBounds.left)) {\r\n                            // draw tiles\r\n                            for (layer = 0; layer < this.imageMap.length; layer++) {\r\n                                tile = this.imageMap[layer][x][y].getNext();\r\n                                if (tile) {\r\n                                    if (tile.template) {\r\n                                        tiles.push(tile.template);\r\n                                    }\r\n                                    tile.x = (x + 0.5) * this.tileWidth;\r\n                                    tile.y = (y + 0.5) * this.tileHeight;\r\n                                    this.tileContainer.addChild(tile);\r\n                                }\r\n                            }\r\n\r\n                            // check for cached entities\r\n                            if (this.doMap[x] && this.doMap[x][y]) {\r\n                                oList = this.doMap[x][y];\r\n                                for (z = 0; z < oList.length; z++) {\r\n                                    if (!oList[z].drawn) {\r\n                                        oList[z].drawn = true;\r\n                                        ents.push(oList[z]);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.mapContainer.removeChildren();\r\n                this.mapContainer.addChild(this.tileContainer);\r\n\r\n                // Draw cached entities\r\n                if (ents.length) {\r\n                    ents.sort(sort);\r\n                    for (z = 0; z < ents.length; z++) {\r\n                        ent = ents[z];\r\n                        delete ent.drawn;\r\n                        this.mapContainer.addChild(ent);\r\n                        if (ent.mask) {\r\n                            this.mapContainer.addChild(ent.mask);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Clear out tile instances\r\n                for (z = 0; z < tiles.length; z++) {\r\n                    tiles[z].clear();\r\n                }\r\n                \r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(tiles);\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(ents);\r\n            },\r\n            \r\n            renderCache: function (bounds, dest, src, wrapper, oldCache, oldBounds) {\r\n                var renderer = this.renderer;\r\n\r\n                if (oldCache && !oldBounds.empty) {\r\n                    oldCache.x = oldBounds.left * this.tileWidth;\r\n                    oldCache.y = oldBounds.top * this.tileHeight;\r\n                    src.addChild(oldCache); // To copy last rendering over.\r\n                }\r\n\r\n                clearRenderTexture(renderer, dest);\r\n                src.x = -bounds.left * this.tileWidth;\r\n                src.y = -bounds.top * this.tileHeight;\r\n                renderer.render(wrapper, dest);\r\n                dest.requiresUpdate = true;\r\n            },\r\n\r\n            renderCacheWithExtrusion: function (bounds, dest, src, wrapper) {\r\n                var extrusion = 1,\r\n                    border = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"](),\r\n                    renderer = this.renderer;\r\n\r\n                // This mask makes only the extruded border drawn for the next 4 draws so that inner holes aren't extruded in addition to the outer rim.\r\n                border.lineStyle(1, 0x000000);\r\n                border.drawRect(0.5, 0.5, this.cacheClipWidth + 1, this.cacheClipHeight + 1);\r\n\r\n                clearRenderTexture(renderer, dest);\r\n\r\n                // There is probably a better way to do this. Currently for the extrusion, everything is rendered once offset in the n, s, e, w directions and then once in the middle to create the effect.\r\n                wrapper.mask = border;\r\n                src.x = -bounds.left * this.tileWidth;\r\n                src.y = -bounds.top * this.tileHeight + extrusion;\r\n                renderer.render(wrapper, dest);\r\n                src.x = -bounds.left * this.tileWidth + extrusion;\r\n                src.y = -bounds.top * this.tileHeight;\r\n                renderer.render(wrapper, dest);\r\n                src.x = -bounds.left * this.tileWidth + extrusion * 2;\r\n                src.y = -bounds.top * this.tileHeight + extrusion;\r\n                renderer.render(wrapper, dest);\r\n                src.x = -bounds.left * this.tileWidth + extrusion;\r\n                src.y = -bounds.top * this.tileHeight + extrusion * 2;\r\n                renderer.render(wrapper, dest);\r\n                wrapper.mask = null;\r\n                src.x = -bounds.left * this.tileWidth + extrusion;\r\n                src.y = -bounds.top * this.tileHeight + extrusion;\r\n                renderer.render(wrapper, dest);\r\n                dest.requiresUpdate = true;\r\n            },\r\n            \r\n            updateGrid: function () {\r\n                var cache = this.cache,\r\n                    cth = this.cacheTilesHeight,\r\n                    ctw = this.cacheTilesWidth,\r\n                    tsh = this.tilesHeight - 1,\r\n                    tsw = this.tilesWidth - 1,\r\n                    x = 0,\r\n                    y = 0,\r\n                    grid = this.cacheGrid;\r\n\r\n                for (x = 0; x < grid.length; x++) {\r\n                    for (y = 0; y < grid[x].length; y++) {\r\n                        cache.setBounds(x * ctw, y * cth, Math.min((x + 1) * ctw, tsw), Math.min((y + 1) * cth, tsh));\r\n                        this.update(grid[x][y].texture, cache);\r\n                    }\r\n                }\r\n            },\r\n\r\n            toJSON: function () {\r\n                var imageMap = this.imageMap[0],\r\n                    imgMap = [],\r\n                    x = imageMap.length,\r\n                    y = 0;\r\n                \r\n                while (x--) {\r\n                    y = imageMap[x].length;\r\n                    imgMap[x] = [];\r\n                    while (y--) {\r\n                        imgMap[x][y] = imageMap[x][y].id;\r\n                    }\r\n                }\r\n\r\n                return {\r\n                    type: 'RenderTiles',\r\n                    buffer: this.buffer,\r\n                    cacheAll: this.cacheAll,\r\n                    entityCache: this.entityCache,\r\n                    imageMap: imgMap,\r\n                    maximumBuffer: this.maximumBuffer,\r\n                    scaleX: this.scaleX,\r\n                    scaleY: this.scaleY,\r\n                    spriteSheet: this.spriteSheet,\r\n                    tileCache: this.tileCache,\r\n                    tileHeight: this.tileHeight,\r\n                    tileWidth: this.tileWidth,\r\n                    top: this.top,\r\n                    left: this.left\r\n                };\r\n            },\r\n\r\n            destroy: function () {\r\n                var x = 0,\r\n                    y = 0,\r\n                    key = '',\r\n                    grid = this.cacheGrid,\r\n                    map = this.doMap,\r\n                    img = this.imageMap;\r\n                    \r\n                if (grid) {\r\n                    for (x = 0; x < grid.length; x++) {\r\n                        for (y = 0; y < grid[x].length; y++) {\r\n                            grid[x][y].texture.destroy(true);\r\n                            this.container.removeChild(grid[x][y]);\r\n                        }\r\n                    }\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(grid, 2);\r\n                    delete this.cacheGrid;\r\n                } else if (this.tilesSprite) {\r\n                    if (this.tilesSprite.texture.alternate) {\r\n                        this.tilesSprite.texture.alternate.destroy(true);\r\n                    }\r\n                    this.tilesSprite.texture.destroy(true);\r\n                    this.container.removeChild(this.tilesSprite);\r\n                } else {\r\n                    this.container.removeChild(this.mapContainer);\r\n                }\r\n                \r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(img, 2);\r\n                \r\n                for (key in this.tiles) {\r\n                    if (this.tiles.hasOwnProperty(key)) {\r\n                        this.tiles[key].destroy();\r\n                    }\r\n                }\r\n                this.tiles = null;\r\n                this.container = null;\r\n                this.tilesSprite = null;\r\n                this.spriteSheet.recycleSpriteSheet();\r\n                \r\n                if (map) {\r\n                    for (x = 0; x < this.cachedDisplayObjects.length; x++) {\r\n                        this.cachedDisplayObjects[x].destroy();\r\n                    }\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(this.cachedDisplayObjects);\r\n\r\n                    for (x = 0; x < map.length; x++) {\r\n                        if (map[x]) {\r\n                            for (y = 0; y < map.length; y++) {\r\n                                if (map[x][y]) {\r\n                                    map[x][y].recycle();\r\n                                }\r\n                            }\r\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(map[x]);\r\n                        }\r\n                    }\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(map);\r\n                }\r\n                \r\n                this.laxCam.recycle();\r\n                this.cache.recycle();\r\n                this.cachePixels.recycle();\r\n            }\r\n        },\r\n        \r\n        getAssetList: (function () {\r\n            var\r\n                getImages = function (ss, spriteSheets) {\r\n                    if (ss) {\r\n                        if (typeof ss === 'string') {\r\n                            return getImages(spriteSheets[ss], spriteSheets);\r\n                        } else if (ss.images) {\r\n                            return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"greenSlice\"])(ss.images);\r\n                        }\r\n                    }\r\n\r\n                    return _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n                };\r\n            \r\n            return function (component, props, defaultProps) {\r\n                var arr = null,\r\n                    i = 0,\r\n                    images = null,\r\n                    spriteSheets = platypus.game.settings.spriteSheets,\r\n                    ss = component.spriteSheet || props.spriteSheet || defaultProps.spriteSheet;\r\n                \r\n                if (ss) {\r\n                    if (typeof ss === 'string' && (ss !== 'import')) {\r\n                        return getImages(ss, spriteSheets);\r\n                    } else if (Array.isArray(ss)) {\r\n                        i = ss.length;\r\n                        images = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n                        while (i--) {\r\n                            arr = getImages(ss[i], spriteSheets);\r\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"union\"])(images, arr);\r\n                            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(arr);\r\n                        }\r\n                        return images;\r\n                    } else if (ss.images) {\r\n                        return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"greenSlice\"])(ss.images);\r\n                    }\r\n                }\r\n                \r\n                return _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp();\r\n            };\r\n        }())\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/RenderTiles.js?");

/***/ }),

/***/ "./src/components/SceneChanger.js":
/*!****************************************!*\
  !*** ./src/components/SceneChanger.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/**\r\n * This component allows the entity to initiate a change from the current scene to another scene.\r\n *\r\n * @namespace platypus.components\r\n * @class SceneChanger\r\n * @extends platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    return platypus.createComponentClass({\r\n        id: 'SceneChanger',\r\n        \r\n        properties: {\r\n            /**\r\n             * Optional, but must be provided by a \"new-scene\" parameter if not defined here. This causes a \"new-scene\" event to load this scene.\r\n             *\r\n             * @property scene\r\n             * @type String\r\n             * @default \"\"\r\n             */\r\n            scene: \"\",\r\n\r\n            /**\r\n             * An object containing key/value pairs of information that should be passed into the new scene on the new scene's \"scene-loaded\" and \"scene-live\" events.\r\n             *\r\n             * @property persistentData\r\n             * @type platypus.Data|Object\r\n             * @default null\r\n             */\r\n            persistentData: null\r\n        },\r\n        \r\n        initialize: function () {\r\n            this.persistentData = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp(this.persistentData);\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * On receiving this message, a new scene is loaded according to provided parameters or previously determined component settings.\r\n             *\r\n             * @method 'new-scene'\r\n             * @param message.scene {String} This is a label corresponding with a predefined scene.\r\n             * @param message.persistentData {Object} Any values that should be passed to the next scene on the new scene's \"scene-loaded\" and \"scene-live\" events.\r\n             */\r\n            \"new-scene\": function (response) {\r\n                var resp       = response || this,\r\n                    scene      = resp.scene || this.scene,\r\n                    data       = resp.persistentData || this.persistentData;\r\n            \r\n                platypus.game.loadScene(scene, data);\r\n            },\r\n\r\n            /**\r\n             * On receiving this message, a scene value is stored, waiting for a `new-scene` to make the transition.\r\n             *\r\n             * @method 'set-scene'\r\n             * @param scene {String} This is a label corresponding with a predefined scene.\r\n             */\r\n            \"set-scene\": function (scene) {\r\n                this.scene = scene;\r\n            },\r\n\r\n            /**\r\n             * On receiving this message, persistent data is stored, waiting for a `new-scene` to make the transition.\r\n             *\r\n             * @method 'set-persistent-scene-data'\r\n             * @param persistentData {Object} Any values that should be passed to the next scene via the \"scene-loaded\" and \"scene-live\" events.\r\n             */\r\n            \"set-persistent-scene-data\": function (data) {\r\n                var thisData = this.persistentData,\r\n                    key = '';\r\n                \r\n                for (key in data) {\r\n                    if (data.hasOwnProperty(key)) {\r\n                        thisData[key] = data[key];\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            destroy: function () {\r\n                //data.recycle() - can't do this here since it may be in use by the next scene.\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/SceneChanger.js?");

/***/ }),

/***/ "./src/components/TiledLoader.js":
/*!***************************************!*\
  !*** ./src/components/TiledLoader.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AABB.js */ \"./src/AABB.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Entity.js */ \"./src/Entity.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Vector.js */ \"./src/Vector.js\");\n/**\r\n * This component is attached to a top-level entity (loaded by the [Scene](platypus.Scene.html)) and, once its peer components are loaded, ingests a JSON file exported from the [Tiled map editor](http://www.mapeditor.org/) and creates the tile maps and entities. Once it has finished loading the map, it removes itself from the list of components on the entity.\r\n *\r\n * This component requires an [EntityContainer](platypus.components.EntityContainer.html) since it calls `entity.addEntity()` on the entity, provided by `EntityContainer`.\r\n *\r\n * This component looks for the following entities, and if not found will load default versions:\r\n\r\n        {\r\n            \"render-layer\": {\r\n                \"id\": \"render-layer\",\r\n                \"components\":[{\r\n                    \"type\": \"RenderTiles\",\r\n                    \"spriteSheet\": \"import\",\r\n                    \"imageMap\":    \"import\",\r\n                    \"entityCache\": true\r\n                }]\r\n            },\r\n            \"collision-layer\": {\r\n                \"id\": \"collision-layer\",\r\n                \"components\":[{\r\n                    \"type\": \"CollisionTiles\",\r\n                    \"collisionMap\": \"import\"\r\n                }]\r\n            },\r\n            \"image-layer\": {\r\n                \"id\": \"image-layer\",\r\n                \"components\":[{\r\n                    \"type\": \"RenderTiles\",\r\n                    \"spriteSheet\": \"import\",\r\n                    \"imageMap\":    \"import\"\r\n                }]\r\n            }\r\n        }\r\n\r\n * @namespace platypus.components\r\n * @class TiledLoader\r\n * @uses platypus.Component\r\n */\r\n/*global atob, pako, platypus */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var FILENAME_TO_ID = /^(?:(\\w+:)\\/{2}(\\w+(?:\\.\\w+)*\\/?))?([\\/.]*?(?:[^?]+)?\\/)?(?:(([^\\/?]+)\\.(\\w+))|([^\\/?]+))(?:\\?((?:(?:[^&]*?[\\/=])?(?:((?:(?:[^\\/?&=]+)\\.(\\w+)))\\S*?)|\\S+))?)?$/,\r\n        maskId = 0x0fffffff,\r\n        maskJumpThrough = 0x10000000, // This is not passed in via Tiled - rather it's additional information sent to CollisionTiles.\r\n        maskXFlip = 0x80000000,\r\n        maskYFlip = 0x40000000,\r\n        decodeBase64 = (function () {\r\n            var decodeString = function (str, index) {\r\n                    return (((str.charCodeAt(index)) + (str.charCodeAt(index + 1) << 8) + (str.charCodeAt(index + 2) << 16) + (str.charCodeAt(index + 3) << 24 )) >>> 0);\r\n                },\r\n                decodeArray = function (arr, index) {\r\n                    return ((arr[index] + (arr[index + 1] << 8) + (arr[index + 2] << 16) + (arr[index + 3] << 24 )) >>> 0);\r\n                };\r\n            \r\n            return function (data, compression) {\r\n                var index = 4,\r\n                    arr   = [],\r\n                    step1 = atob(data.replace(/\\\\/g, ''));\r\n                    \r\n                if (compression === 'zlib') {\r\n                    step1 = pako.inflate(step1); //TODO: Need to fix this for sr2\r\n                    while (index <= step1.length) {\r\n                        arr.push(decodeArray(step1, index - 4));\r\n                        index += 4;\r\n                    }\r\n                } else {\r\n                    while (index <= step1.length) {\r\n                        arr.push(decodeString(step1, index - 4));\r\n                        index += 4;\r\n                    }\r\n                }\r\n                \r\n                return arr;\r\n            };\r\n        }()),\r\n        getImageId = function (path) {\r\n            var result = path.match(FILENAME_TO_ID);\r\n\r\n            return result[5] || result[7];\r\n        },\r\n        finishedLoading = function (level, x, y, width, height, tileWidth, tileHeight, callback) {\r\n            var message = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp(\r\n                    \"level\", null,\r\n                    \"world\", _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(),\r\n                    \"tile\", _AABB_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(),\r\n                    \"camera\", null\r\n                );\r\n\r\n            /**\r\n             * Once finished loading the map, this message is triggered on the entity to notify other components of completion.\r\n             *\r\n             * @event 'world-loaded'\r\n             * @param message {platypus.Data} World data.\r\n             * @param message.level {Object} The Tiled level data used to load the level.\r\n             * @param message.width {number} The width of the world in world units.\r\n             * @param message.height {number} The height of the world in world units.\r\n             * @param message.tile {platypus.AABB} Dimensions of the world tiles.\r\n             * @param message.world {platypus.AABB} Dimensions of the world.\r\n             * @param message.camera {platypus.Entity} If a camera property is found on one of the loaded entities, this property will point to the entity on load that a world camera should focus on.\r\n             */\r\n            message.level = level;\r\n            message.camera = this.followEntity; // TODO: in 0.9.0 this should probably be removed, using something like \"child-entity-added\" instead. Currently this is particular to TiledLoader and Camera and should be generalized. - DDD 3/15/2016\r\n            message.width = width;\r\n            message.height = height;\r\n            message.world.setBounds(x, y, x + width, y + height);\r\n            message.tile.setBounds(0, 0, tileWidth, tileHeight);\r\n            this.owner.triggerEvent('world-loaded', message);\r\n            message.world.recycle();\r\n            message.tile.recycle();\r\n            message.recycle();\r\n            \r\n            this.owner.removeComponent(this);\r\n\r\n            if (callback) {\r\n                callback();\r\n            }\r\n        },\r\n        getPowerOfTen = function (amount) {\r\n            var x = 1;\r\n\r\n            while (x < amount) {\r\n                x *= 10;\r\n            }\r\n\r\n            return x;\r\n        },\r\n        transform = {\r\n            x: 1,\r\n            y: 1,\r\n            id: -1\r\n        },\r\n        getProperty = function (obj, key) { // Handle Tiled map versions\r\n            var i = 0;\r\n\r\n            if (obj) {\r\n                if (Array.isArray(obj)) {\r\n                    i = obj.length;\r\n                    while (i--) {\r\n                        if (obj[i].name === key) {\r\n                            return obj[i].value;\r\n                        }\r\n                    }\r\n                    return null;\r\n                } else {\r\n                    return obj[key];\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        },\r\n        setProperty = function (obj, key, value) { // Handle Tiled map versions\r\n            var i = 0;\r\n\r\n            if (obj) {\r\n                if (Array.isArray(obj)) {\r\n                    i = obj.length;\r\n                    while (i--) {\r\n                        if (obj[i].name === key) {\r\n                            obj[i].type = typeof value;\r\n                            obj[i].value = value;\r\n                            return;\r\n                        }\r\n                    }\r\n                    obj.push({\r\n                        name: key,\r\n                        type: typeof value,\r\n                        value: value\r\n                    });\r\n                } else {\r\n                    obj[key] = value;\r\n                }\r\n            }\r\n        },\r\n        entityTransformCheck = function (v) {\r\n            var resp = transform,\r\n                b = !!(maskYFlip & v),\r\n                c = !!(maskXFlip & v);\r\n\r\n            resp.id = maskId & v;\r\n            resp.x = 1;\r\n            resp.y = 1;\r\n\r\n            if (b) {\r\n                resp.y = -1;\r\n            }\r\n            if (c) {\r\n                resp.x = -1;\r\n            }\r\n            return resp;\r\n        },\r\n        getEntityData = function (obj, tilesets) {\r\n            var x = 0,\r\n                gid = obj.gid || -1,\r\n                properties = {},\r\n                data = {\r\n                    gid: -1,\r\n                    transform: null,\r\n                    properties: properties,\r\n                    type: ''\r\n                },\r\n                props = null,\r\n                tileset = null,\r\n                entityTilesetIndex = 0;\r\n            \r\n            if (gid !== -1) {\r\n                data.transform = entityTransformCheck(gid);\r\n                gid = data.gid = transform.id;\r\n            }\r\n            \r\n            for (x = 0; x < tilesets.length; x++) {\r\n                if (tilesets[x].firstgid > gid) {\r\n                    break;\r\n                } else {\r\n                    tileset = tilesets[x];\r\n                }\r\n            }\r\n            \r\n            if (tileset) {\r\n                entityTilesetIndex = gid - tileset.firstgid;\r\n                if (tileset.tileproperties && tileset.tileproperties[entityTilesetIndex]) {\r\n                    props = tileset.tileproperties[entityTilesetIndex];\r\n                }\r\n                if (tileset.tiles && tileset.tiles[entityTilesetIndex]) {\r\n                    data.type = tileset.tiles[entityTilesetIndex].type || '';\r\n                }\r\n            }\r\n\r\n            // Check Tiled data to find this object's type\r\n            data.type = obj.type || data.type;\r\n            // Deprecating the following methods in v0.11 due to better \"type\" property support in Tiled 1.0.0\r\n            if (data.type === '') {\r\n                if (obj.name) {\r\n                    data.type = obj.name;\r\n                    platypus.debug.warn('Component TiledLoader (loading \"' + data.type + '\"): Defining the entity type using the \"name\" property has been deprecated. Define the type using the object\\'s \"type\" property in Tiled instead.');\r\n                } else if (props) {\r\n                    if (props.entity) {\r\n                        data.type = props.entity;\r\n                        platypus.debug.warn('Component TiledLoader (loading \"' + data.type + '\"): Defining the entity type using the \"entity\" property in the object properties has been deprecated. Define the type using the object\\'s \"type\" property in Tiled instead.');\r\n                    } else if (props.type) {\r\n                        data.type = props.type;\r\n                        platypus.debug.warn('Component TiledLoader (loading \"' + data.type + '\"): Defining the entity type in the object properties has been deprecated. Define the type using the object\\'s \"type\" property in Tiled instead.');\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!data.type) { // undefined entity\r\n                return null;\r\n            }\r\n            \r\n            //Copy properties from Tiled\r\n            if (data.transform) {\r\n                properties.scaleX = data.transform.x;\r\n                properties.scaleY = data.transform.y;\r\n            } else {\r\n                properties.scaleX = 1;\r\n                properties.scaleY = 1;\r\n            }\r\n            \r\n            mergeAndFormatProperties(props, data.properties);\r\n            mergeAndFormatProperties(obj.properties, data.properties);\r\n            \r\n            return data;\r\n        },\r\n        mergeAndFormatProperties = function (src, dest) {\r\n            var i = 0,\r\n                key = '';\r\n            \r\n            if (src && dest) {\r\n                if (Array.isArray(src)) {\r\n                    for (i = 0; i < src.length; i++) {\r\n                        setProperty(dest, src[i].name, formatProperty(src[i].value));\r\n                    }\r\n                } else {\r\n                    for (key in src) {\r\n                        if (src.hasOwnProperty(key)) {\r\n                            setProperty(dest, key, formatProperty(src[key]));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            return dest;\r\n        },\r\n        formatProperty = function (value) {\r\n            var numberProperty = 0;\r\n            \r\n            if (typeof value === 'string') {\r\n                //This is going to assume that if you pass in something that starts with a number, it is a number and converts it to one.\r\n                numberProperty = parseFloat(value) || parseInt(value); // to handle floats and 0x respectively.\r\n                if (numberProperty === 0 || (!!numberProperty)) {\r\n                    return numberProperty;\r\n                } else if (value === 'true') {\r\n                    return true;\r\n                } else if (value === 'false') {\r\n                    return false;\r\n                } else if ((value.length > 1) && (((value[0] === '{') && (value[value.length - 1] === '}')) || ((value[0] === '[') && (value[value.length - 1] === ']')))) {\r\n                    try {\r\n                        return JSON.parse(value);\r\n                    } catch (e) {\r\n                    }\r\n                }\r\n            }\r\n\r\n            return value;\r\n        },\r\n        checkLevel = function (level, ss) {\r\n            var i = 0,\r\n                j = 0,\r\n                tilesets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                arr = null,\r\n                assets = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                data = null,\r\n                entity = null,\r\n                entityAssets = null;\r\n\r\n            if (typeof level === 'string') {\r\n                level = platypus.game.settings.levels[level];\r\n            }\r\n\r\n            if (level) {\r\n                if (level.tilesets) {\r\n                    level.tilesets = importTilesetData(level.tilesets);\r\n                }\r\n\r\n                if (level.assets) { // Property added by a previous parse (so that this algorithm isn't run on the same level multiple times)\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, level.assets);\r\n                } else if (level.layers) {\r\n                    for (i = 0; i < level.layers.length; i++) {\r\n                        if (level.layers[i].type === 'objectgroup') {\r\n                            for (j = 0; j < level.layers[i].objects.length; j++) {\r\n                                entity = getEntityData(level.layers[i].objects[j], level.tilesets);\r\n                                if (entity) {\r\n                                    entityAssets = _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getAssetList(entity);\r\n                                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, entityAssets);\r\n                                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(entityAssets);\r\n                                }\r\n                            }\r\n                        } else if (level.layers[i].type === 'imagelayer') {\r\n                            Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, [level.layers[i].image]);\r\n                        } else {\r\n                            entity = getProperty(level.layers[i].properties, 'entity');\r\n                            if (entity) {\r\n                                data = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp('type', entity);\r\n                                arr = _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getAssetList(data);\r\n                                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, arr);\r\n                                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(arr);\r\n                                data.recycle();\r\n                            }\r\n                        }\r\n                    }\r\n                    if (!ss) { //We need to load the tileset images since there is not a separate spriteSheet describing them\r\n                        for (i = 0; i < level.tilesets.length; i++) {\r\n                            tilesets.push(level.tilesets[i].image);\r\n                        }\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, tilesets);\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(tilesets);\r\n                    }\r\n                    level.assets = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(assets); // Save for later in case this level is checked again.\r\n                }\r\n            }\r\n            \r\n            return assets;\r\n        },\r\n        // These are provided but can be overwritten by entities of the same name in the configuration.\r\n        standardEntityLayers = {\r\n            \"render-layer\": {\r\n                \"id\": \"render-layer\",\r\n                \"components\": [{\r\n                    \"type\": \"RenderTiles\",\r\n                    \"spriteSheet\": \"import\",\r\n                    \"imageMap\": \"import\",\r\n                    \"entityCache\": true\r\n                }]\r\n            },\r\n            \"collision-layer\": {\r\n                \"id\": \"collision-layer\",\r\n                \"components\": [{\r\n                    \"type\": \"CollisionTiles\",\r\n                    \"collisionMap\": \"import\"\r\n                }]\r\n            },\r\n            \"image-layer\": {\r\n                \"id\": \"image-layer\",\r\n                \"components\": [{\r\n                    \"type\": \"RenderTiles\",\r\n                    \"spriteSheet\": \"import\",\r\n                    \"imageMap\": \"import\"\r\n                }]\r\n            }\r\n        },\r\n        importTileset = function (tileset) {\r\n            var key = '',\r\n                source = platypus.game.settings.levels[tileset.source.replace('.json', '')];\r\n            \r\n            for (key in source) {\r\n                if (source.hasOwnProperty(key)) {\r\n                    tileset[key] = source[key];\r\n                }\r\n            }\r\n            \r\n            delete tileset.source; // We remove this so we never have to rerun this import. Note that we can't simply replace the tileset properties since the tileset's firstgid property may change from level to level.\r\n            \r\n            return tileset;\r\n        },\r\n        importTilesetData = function (tilesets) {\r\n            var i = 0;\r\n            \r\n            for (i = 0; i < tilesets.length; i++) {\r\n                if (tilesets[i].source) {\r\n                    tilesets[i] = importTileset(tilesets[i]);\r\n                }\r\n            }\r\n            \r\n            return tilesets;\r\n        };\r\n\r\n    return platypus.createComponentClass({\r\n        id: 'TiledLoader',\r\n\r\n        properties: {\r\n            /**\r\n             * This causes the entire map to be offset automatically by an order of magnitude higher than the height and width of the world so that the number of digits below zero is constant throughout the world space. This fixes potential floating point issues when, for example, 97 is added to 928.0000000000001 giving 1025 since a significant digit was lost when going into the thousands.\r\n             *\r\n             * @property offsetMap\r\n             * @type Boolean\r\n             * @default false\r\n             * @since 0.7.5\r\n             */\r\n            offsetMap: false,\r\n            \r\n            /**\r\n             * If set to `true` and if the game is running in debug mode, this causes the collision layer to appear.\r\n             *\r\n             * @property showCollisionTiles\r\n             * @type Boolean\r\n             * @default false\r\n             */\r\n            showCollisionTiles: false,\r\n\r\n            /**\r\n             * If specified, the referenced images are used as the game sprite sheets instead of the images referenced in the Tiled map. This is useful for using different or better quality art from the art used in creating the Tiled map.\r\n             *\r\n             * @property images\r\n             * @type Array\r\n             * @default null\r\n             */\r\n            images: null,\r\n\r\n            /**\r\n             * Adds a number to each additional Tiled layer's z coordinate to maintain z-order. Defaults to 1000.\r\n             *\r\n             * @property layerIncrement\r\n             * @type number\r\n             * @default 1000\r\n             */\r\n            layerIncrement: 1000,\r\n\r\n            /**\r\n             * Keeps the tile maps in separate render layers. Default is 'false' to for better optimization.\r\n             *\r\n             * @property separateTiles\r\n             * @type boolean\r\n             * @default false\r\n             */\r\n            separateTiles: false,\r\n            \r\n            /**\r\n             * If a particular sprite sheet should be used that's not defined by the level images themselves. This is useful for making uniquely-themed variations of the same level. This is overridden by `\"spriteSheet\": \"import\"` in the \"render-layer\" Entity definition, so be sure to remove that when setting this property.\r\n             *\r\n             * @property spriteSheet\r\n             * @type String | Object\r\n             * @default null\r\n             * @since 0.6.6\r\n             */\r\n            spriteSheet: null\r\n        },\r\n\r\n        publicProperties: {\r\n            /**\r\n             * Specifies the JSON level to load. Available on the entity as `entity.level`.\r\n             *\r\n             * @property level\r\n             * @type String\r\n             * @default null\r\n             */\r\n            level: null,\r\n\r\n            /**\r\n             * Can be \"left\", \"right\", or \"center\". Defines where entities registered X position should be when spawned. Available on the entity as `entity.entityPositionX`.\r\n             *\r\n             * @property entityPositionX\r\n             * @type String\r\n             * @default \"center\"\r\n             */\r\n            entityPositionX: \"center\",\r\n\r\n            /**\r\n             * Can be \"top\", \"bottom\", or \"center\". Defines where entities registered Y position should be when spawned. Available on the entity as `entity.entityPositionY`.\r\n             *\r\n             * @property entityPositionY\r\n             * @type String\r\n             * @default \"bottom\"\r\n             */\r\n            entityPositionY: \"bottom\",\r\n\r\n            /**\r\n             * Whether to wait for a \"load-level\" event before before loading. Available on the entity as `entity.manuallyLoad`.\r\n             *\r\n             * @property manuallyLoad\r\n             * @type boolean\r\n             * @default false\r\n             */\r\n            manuallyLoad: false\r\n        },\r\n\r\n        initialize: function () {\r\n            this.assetCache = platypus.assetCache;\r\n            this.layerZ = 0;\r\n            this.followEntity = false;\r\n        },\r\n\r\n        events: {\r\n\r\n            /**\r\n             * On receiving this message, the component commences loading the Tiled map JSON definition. Once finished, it removes itself from the entity's list of components.\r\n             *\r\n             * @method 'scene-loaded'\r\n             * @param persistentData {Object} Data passed from the last scene into this one.\r\n             * @param persistentData.level {Object} A level name or definition to load if the level is not already specified.\r\n             * @param holds {platypus.Data} An object that handles any holds on before making the scene live.\r\n             * @param holds.count {Number} The number of holds to wait for before triggering \"scene-live\"\r\n             * @param holds.release {Function} The method to trigger to let the scene loader know that one hold has been released.\r\n             */\r\n            \"scene-loaded\": function (persistentData, holds) {\r\n                if (!this.manuallyLoad) {\r\n                    holds.count += 1;\r\n                    this.loadLevel({\r\n                        level: this.level || persistentData.level,\r\n                        persistentData: persistentData\r\n                    }, holds.release);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * If `manuallyLoad` is set, the component will wait for this message before loading the Tiled map JSON definition.\r\n             *\r\n             * @method 'load-level'\r\n             * @param levelData {Object}\r\n             * @param levelData.level {String|Object} The level to load.\r\n             * @param [levelData.persistentData] {Object} Information passed from the last scene.\r\n             * @param callback {Function} The function to call once the level is loaded.\r\n             */\r\n            \"load-level\": function (levelData, callback) {\r\n                this.loadLevel(levelData, callback);\r\n            }\r\n        },\r\n\r\n        methods: {\r\n            createLayer: function (entityKind, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer, progress) {\r\n                var lastSet = null,\r\n                    props = null,\r\n                    width = layer.width,\r\n                    height = layer.height,\r\n                    tHeight = layer.tileheight || tileHeight,\r\n                    tWidth = layer.tilewidth || tileWidth,\r\n                    newWidth = 0,\r\n                    newHeight = 0,\r\n                    layerHeight = 0,\r\n                    layerWidth = 0,\r\n                    tileTypes = 0,\r\n                    tileDefinition = JSON.parse(JSON.stringify(platypus.game.settings.entities[entityKind] || standardEntityLayers[entityKind])), //TODO: a bit of a hack to copy an object instead of overwrite values\r\n                    importAnimation = {},\r\n                    importCollision = [],\r\n                    importFrames = [],\r\n                    importRender = [],\r\n                    importSpriteSheet = {\r\n                        images: (layer.image ? [layer.image] : images),\r\n                        frames: importFrames,\r\n                        animations: importAnimation\r\n                    },\r\n                    renderTiles = false,\r\n                    tileset = null,\r\n                    jumpthroughs = null,\r\n                    index = 0,\r\n                    x = 0,\r\n                    y = 0,\r\n                    prop = \"\",\r\n                    data = null,\r\n                    createFrames = function (frames, index, tileset, modifier) {\r\n                        var margin = tileset.margin || 0,\r\n                            spacing = tileset.spacing || 0,\r\n                            tileWidth = tileset.tilewidth,\r\n                            tileHeight = tileset.tileheight,\r\n                            tileWidthHalf = tileWidth / 2,\r\n                            tileHeightHalf = tileHeight / 2,\r\n                            tileWidthSpace = tileWidth + spacing,\r\n                            tileHeightSpace = tileHeight + spacing,\r\n                            margin2 = margin * 2,\r\n                            marginSpace = margin2 - spacing,\r\n                            cols = tileset.columns || (((tileset.imagewidth / tileWidthSpace) + marginSpace) >> 0),\r\n                            rows = /* Tiled tileset def doesn't seem to have rows */ (((tileset.imageheight / tileHeightSpace) + marginSpace) >> 0),\r\n                            x = 0,\r\n                            y = 0;\r\n                        \r\n                        // deprecated unit/image resizing\r\n                        tileWidth = tileWidth * modifier;\r\n                        tileHeight = tileHeight * modifier;\r\n                        tileWidthHalf = tileWidthHalf * modifier;\r\n                        tileHeightHalf = tileHeightHalf * modifier;\r\n                        tileWidthSpace = tileWidthSpace * modifier;\r\n                        tileHeightSpace = tileHeightSpace * modifier;\r\n\r\n                        for (y = 0; y < rows; y++) {\r\n                            for (x = 0; x < cols; x++) {\r\n                                frames.push([\r\n                                    margin + x * tileWidthSpace,\r\n                                    margin + y * tileHeightSpace,\r\n                                    tileWidth,\r\n                                    tileHeight,\r\n                                    index,\r\n                                    tileWidthHalf,\r\n                                    tileHeightHalf\r\n                                ]);\r\n                            }\r\n                        }\r\n                    };\r\n                \r\n                this.decodeLayer(layer);\r\n                data = layer.data;\r\n                mapOffsetX += layer.offsetx || 0;\r\n                mapOffsetY += layer.offsety || 0;\r\n\r\n                tileDefinition.properties = tileDefinition.properties || {};\r\n\r\n                //This builds in parallaxing support by allowing the addition of width and height properties into Tiled layers so they pan at a separate rate than other layers.\r\n                if (layer.properties) {\r\n\r\n                    layerWidth = getProperty(layer.properties, 'width');\r\n                    if (layerWidth) {\r\n                        newWidth  = parseInt(layerWidth,  10);\r\n                    }\r\n\r\n                    layerHeight = getProperty(layer.properties, 'height');\r\n                    if (layerHeight) {\r\n                        newHeight = parseInt(layerHeight, 10);\r\n                    }\r\n\r\n                    if (newWidth || newHeight) {\r\n                        newWidth  = newWidth  || width;\r\n                        newHeight = newHeight || height;\r\n                        data      = [];\r\n                        for (x = 0; x < newWidth; x++) {\r\n                            for (y = 0; y < newHeight; y++) {\r\n                                if ((x < width) && (y < height)) {\r\n                                    data[x + y * newWidth] = layer.data[x + y * width];\r\n                                } else {\r\n                                    data[x + y * newWidth] = 0;\r\n                                }\r\n                            }\r\n                        }\r\n                        width  = newWidth;\r\n                        height = newHeight;\r\n                    }\r\n                    \r\n                    mergeAndFormatProperties(layer.properties, tileDefinition.properties);\r\n                }\r\n\r\n                if (entityKind === 'collision-layer') {\r\n                    jumpthroughs = [];\r\n                    for (x = 0; x < tilesets.length; x++) {\r\n                        tileset = tilesets[x];\r\n                        if (tileset.tileproperties) {\r\n                            for (prop in tileset.tileproperties) {\r\n                                if (tileset.tileproperties.hasOwnProperty(prop)) {\r\n                                    if (tileset.tileproperties[prop].jumpThrough) {\r\n                                        jumpthroughs.push(tileset.firstgid + parseInt(prop, 10));\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                tileDefinition.properties.width = tWidth * width;\r\n                tileDefinition.properties.height = tHeight * height;\r\n                tileDefinition.properties.columns = width;\r\n                tileDefinition.properties.rows = height;\r\n                tileDefinition.properties.tileWidth = tWidth;\r\n                tileDefinition.properties.tileHeight = tHeight;\r\n                tileDefinition.properties.scaleX = 1;\r\n                tileDefinition.properties.scaleY = 1;\r\n                tileDefinition.properties.layerZ = this.layerZ;\r\n                tileDefinition.properties.left = tileDefinition.properties.x || mapOffsetX;\r\n                tileDefinition.properties.top = tileDefinition.properties.y || mapOffsetY;\r\n                tileDefinition.properties.z = tileDefinition.properties.z || this.layerZ;\r\n\r\n                if (tilesets.length) {\r\n                    for (x = 0; x < tilesets.length; x++) {\r\n                        createFrames(importFrames, x, tilesets[x], 1);\r\n                    }\r\n\r\n                    lastSet = tilesets[tilesets.length - 1];\r\n                    tileTypes = lastSet.firstgid + lastSet.tilecount;\r\n                    for (x = -1; x < tileTypes; x++) {\r\n                        importAnimation['tile' + x] = x;\r\n                    }\r\n                }\r\n                for (x = 0; x < width; x++) {\r\n                    importCollision[x] = [];\r\n                    importRender[x] = [];\r\n                    for (y = 0; y < height; y++) {\r\n                        index = +data[x + y * width] - 1; // -1 from original src to make it zero-based.\r\n                        importRender[x][y] = 'tile' + index;\r\n                        index += 1; // So collision map matches original src indexes. Render (above) should probably be changed at some point as well. DDD 3/30/2016\r\n                        if (jumpthroughs && jumpthroughs.length && (jumpthroughs[0] === (maskId & index))) {\r\n                            index = maskJumpThrough | index;\r\n                        }\r\n                        importCollision[x][y] = index;\r\n                    }\r\n                }\r\n                for (x = 0; x < tileDefinition.components.length; x++) {\r\n                    if (tileDefinition.components[x].type === 'RenderTiles') {\r\n                        renderTiles = tileDefinition.components[x];\r\n                    }\r\n                    if (tileDefinition.components[x].spriteSheet === 'import') {\r\n                        tileDefinition.components[x].spriteSheet = importSpriteSheet;\r\n                    } else if (tileDefinition.components[x].spriteSheet) {\r\n                        if (typeof tileDefinition.components[x].spriteSheet === 'string' && platypus.game.settings.spriteSheets[tileDefinition.components[x].spriteSheet]) {\r\n                            tileDefinition.components[x].spriteSheet = platypus.game.settings.spriteSheets[tileDefinition.components[x].spriteSheet];\r\n                        }\r\n                        if (!tileDefinition.components[x].spriteSheet.animations) {\r\n                            tileDefinition.components[x].spriteSheet.animations = importAnimation;\r\n                        }\r\n                    }\r\n                    if (tileDefinition.components[x].collisionMap === 'import') {\r\n                        tileDefinition.components[x].collisionMap = importCollision;\r\n                    }\r\n                    if (tileDefinition.components[x].imageMap === 'import') {\r\n                        tileDefinition.components[x].imageMap = importRender;\r\n                    }\r\n                }\r\n                this.layerZ += this.layerIncrement;\r\n\r\n                if ((entityKind === 'render-layer') && (!this.separateTiles) && combineRenderLayer && (combineRenderLayer.tileHeight === tHeight) && (combineRenderLayer.tileWidth === tWidth) && (combineRenderLayer.columns === width) && (combineRenderLayer.rows === height)) {\r\n                    combineRenderLayer.triggerEvent('add-tiles', renderTiles);\r\n                    this.updateLoadingProgress(progress);\r\n                    return combineRenderLayer;\r\n                } else {\r\n                    props = {};\r\n                    if ((entityKind === 'render-layer') && this.spriteSheet) {\r\n                        if (typeof this.spriteSheet === 'string') {\r\n                            props.spriteSheet = platypus.game.settings.spriteSheets[this.spriteSheet];\r\n                        } else {\r\n                            props.spriteSheet = this.spriteSheet;\r\n                        }\r\n                        if (!props.spriteSheet.animations) {\r\n                            props.spriteSheet.animations = importAnimation;\r\n                        }\r\n                    }\r\n                    return this.owner.addEntity(new _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](tileDefinition, {\r\n                        properties: props\r\n                    }, this.updateLoadingProgress.bind(this, progress), this.owner));\r\n                }\r\n            },\r\n            \r\n            convertImageLayer: function (imageLayer) {\r\n                var asset = null,\r\n                    i = 0,\r\n                    dataCells = 0,\r\n                    imageId = '',\r\n                    props = imageLayer.properties || {},\r\n                    repeat = getProperty(props, 'repeat'),\r\n                    repeatX = getProperty(props, 'repeat-x'),\r\n                    repeatY = getProperty(props, 'repeat-y'),\r\n                    tileLayer = {\r\n                        data: [],\r\n                        image: '',\r\n                        height: 1,\r\n                        name: imageLayer.name,\r\n                        type: 'tilelayer',\r\n                        width: 1,\r\n                        tileheight: 1,\r\n                        tilewidth: 1,\r\n                        x: imageLayer.x,\r\n                        y: imageLayer.y,\r\n                        properties: props\r\n                    };\r\n\r\n                if (repeat) {\r\n                    tileLayer.width = +repeat;\r\n                    tileLayer.height = +repeat;\r\n                }\r\n                if (repeatX) {\r\n                    tileLayer.width = +repeatX;\r\n                }\r\n                if (repeatY) {\r\n                    tileLayer.height = +repeatY;\r\n                }\r\n                dataCells = tileLayer.width * tileLayer.height;\r\n                for (i = 0; i < dataCells; i++) {\r\n                    tileLayer.data.push(1);\r\n                }\r\n\r\n                asset = this.assetCache.get(imageLayer.name);\r\n                if (asset) { // Prefer to have name in tiled match image id in game\r\n                    tileLayer.image = imageLayer.name;\r\n                    tileLayer.tileheight = asset.height;\r\n                    tileLayer.tilewidth = asset.width;\r\n                } else {\r\n                    imageId = getImageId(imageLayer.image);\r\n                    asset = this.assetCache.get(imageId);\r\n                    if (asset) {\r\n                        platypus.debug.warn('Component TiledLoader: Did not find a spritesheet for \"' + imageLayer.name + '\", so using \"' + imageLayer.image + '\" instead.');\r\n                        tileLayer.image = imageId;\r\n                        tileLayer.tileheight = asset.height;\r\n                        tileLayer.tilewidth = asset.width;\r\n                    } else {\r\n                        platypus.debug.warn('Component TiledLoader: Cannot find the \"' + imageLayer.name + '\" sprite sheet. Add it to the list of assets in config.json and give it the id \"' + imageLayer.name + '\".');\r\n                        tileLayer.image = imageLayer.image;\r\n                    }\r\n                }\r\n\r\n                tileLayer.tileset = {\r\n                    \"columns\": 1,\r\n                    \"image\": tileLayer.image,\r\n                    \"imageheight\": tileLayer.tileheight,\r\n                    \"imagewidth\": tileLayer.tilewidth,\r\n                    \"margin\": 0,\r\n                    \"name\": imageLayer.name,\r\n                    \"spacing\": 0,\r\n                    \"tilecount\": 1,\r\n                    \"tileheight\": tileLayer.tileheight,\r\n                    \"tilewidth\": tileLayer.tilewidth,\r\n                    \"type\": \"tileset\"\r\n                };\r\n                \r\n                return tileLayer;\r\n            },\r\n            \r\n            loadLevel: function (levelData, callback) {\r\n                var actionLayerCollides = true,\r\n                    asset = null,\r\n                    layers = null,\r\n                    level = null,\r\n                    height = 0,\r\n                    i = 0,\r\n                    imageId = '',\r\n                    images = null,\r\n                    layer = null,\r\n                    layerDefinition = null,\r\n                    tileset = null,\r\n                    tilesets = null,\r\n                    tileWidth = 0,\r\n                    tileHeight = 0,\r\n                    progress = _Data_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setUp('count', 0, 'progress', 0, 'total', 0),\r\n                    width = 0,\r\n                    x = 0,\r\n                    y = 0;\r\n                \r\n                //format level appropriately\r\n                if (typeof levelData.level === 'string') {\r\n                    level = platypus.game.settings.levels[levelData.level];\r\n                } else {\r\n                    level = levelData.level;\r\n                }\r\n                layers = level.layers;\r\n                tilesets = importTilesetData(level.tilesets);\r\n                tileWidth = level.tilewidth;\r\n                tileHeight = level.tileheight;\r\n\r\n                if (level.properties) {\r\n                    mergeAndFormatProperties(level.properties, this.owner);\r\n                }\r\n                \r\n                if (this.images) {\r\n                    images = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(this.images);\r\n                } else {\r\n                    images = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                }\r\n                if (images.length === 0) {\r\n                    for (i = 0; i < tilesets.length; i++) {\r\n                        tileset = tilesets[i];\r\n                        asset = this.assetCache.get(tileset.name);\r\n                        if (asset) { // Prefer to have name in tiled match image id in game\r\n                            images.push(tileset.name);\r\n                        } else {\r\n                            imageId = getImageId(tileset.image);\r\n                            asset = this.assetCache.get(imageId);\r\n                            if (asset) {\r\n                                platypus.debug.warn('Component TiledLoader: Did not find a spritesheet for \"' + tileset.name + '\", so using \"' + tileset.image + '\" instead.');\r\n                                images.push(imageId);\r\n                            } else {\r\n                                platypus.debug.warn('Component TiledLoader: Cannot find the \"' + tileset.name + '\" sprite sheet. Add it to the list of assets in config.json and give it the id \"' + tileset.name + '\".');\r\n                                images.push(tileset.image);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                width = level.width * tileWidth;\r\n                height = level.height * tileHeight;\r\n\r\n                if (this.offsetMap) {\r\n                    x = getPowerOfTen(width);\r\n                    y = getPowerOfTen(height);\r\n                }\r\n\r\n                progress.total = i = layers.length;\r\n                while (i--) { // Preparatory pass through layers.\r\n                    if (layers[i].type === 'objectgroup') {\r\n                        progress.total += layers[i].objects.length;\r\n                    } else if (actionLayerCollides && ((layers[i].name === 'collision') || (getProperty(layers[i].properties, 'entity') === 'collision-layer'))) {\r\n                        actionLayerCollides = false;\r\n                    }\r\n                }\r\n\r\n                this.finishedLoading = finishedLoading.bind(this, level, x, y, width, height, tileWidth, tileHeight, callback);\r\n\r\n                for (i = 0; i < layers.length; i++) {\r\n                    layerDefinition = layers[i];\r\n                    switch (layerDefinition.type) {\r\n                    case 'imagelayer':\r\n                        layer = this.convertImageLayer(layerDefinition);\r\n                        layer = this.createLayer('image-layer', layer, x, y, layer.tilewidth, layer.tileheight, [layer.tileset], images, layer, progress);\r\n                        break;\r\n                    case 'objectgroup':\r\n                        this.setUpEntities(layerDefinition, x, y, tileWidth, tileHeight, tilesets, progress);\r\n                        layer = null;\r\n                        this.updateLoadingProgress(progress);\r\n                        break;\r\n                    case 'tilelayer':\r\n                        layer = this.setupLayer(layerDefinition, actionLayerCollides, layer, x, y, tileWidth, tileHeight, tilesets, images, progress);\r\n                        break;\r\n                    default:\r\n                        platypus.debug.warn('Component TiledLoader: Platypus does not support Tiled layers of type \"' + layerDefinition.type + '\". This layer will not be loaded.');\r\n                        this.updateLoadingProgress(progress);\r\n                    }\r\n                }\r\n            },\r\n            \r\n            setUpEntities: (function () {\r\n                const\r\n                    getPolyShape = function (type, points, decomposed) {\r\n                        const\r\n                            shape = {\r\n                                type: type,\r\n                                points: points.slice()\r\n                            };\r\n\r\n                        if (decomposed) {\r\n                            const decomposedPoints = [];\r\n                            let p = 0;\r\n\r\n                            for (p = 0; p < decomposed.length; p++) {\r\n                                decomposedPoints.push(decomposed[p].slice());\r\n                            }\r\n    \r\n                            shape.decomposedPolygon = decomposedPoints;\r\n                        }\r\n\r\n                        return shape;\r\n                    };\r\n\r\n                return function (layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, progress) {\r\n                    var clamp = 1000,\r\n                        widthOffset = 0,\r\n                        heightOffset = 0,\r\n                        x = 0,\r\n                        w = 0,\r\n                        h = 0,\r\n                        a = 0,\r\n                        v = null,\r\n                        obj = 0,\r\n                        entity = null,\r\n                        entityDefinition = null,\r\n                        entityDefProps = null,\r\n                        entityPositionX = getProperty(layer.properties, 'entityPositionX') || this.entityPositionX,\r\n                        entityPositionY = getProperty(layer.properties, 'entityPositionY') || this.entityPositionY,\r\n                        entityType = '',\r\n                        gid = -1,\r\n                        smallestX = Infinity,\r\n                        largestX = -Infinity,\r\n                        smallestY = Infinity,\r\n                        largestY = -Infinity,\r\n                        entityData = null,\r\n                        properties = null,\r\n                        polyPoints = null,\r\n                        fallbackWidth = 0,\r\n                        fallbackHeight = 0;\r\n    \r\n                    mapOffsetX += layer.offsetx || 0;\r\n                    mapOffsetY += layer.offsety || 0;\r\n    \r\n                    for (obj = 0; obj < layer.objects.length; obj++) {\r\n                        entity     = layer.objects[obj];\r\n                        entityData = getEntityData(entity, tilesets);\r\n                        if (entityData) {\r\n                            gid = entityData.gid;\r\n                            entityType = entityData.type;\r\n                            entityDefinition = platypus.game.settings.entities[entityType];\r\n                            if (entityDefinition) {\r\n                                entityDefProps = entityDefinition.properties || null;\r\n                            } else {\r\n                                entityDefProps = null;\r\n                            }\r\n                            properties = entityData.properties;\r\n    \r\n                            if (entity.polygon || entity.polyline) {\r\n                                //Figuring out the width of the polygon and shifting the origin so it's in the top-left.\r\n                                smallestX = Infinity;\r\n                                largestX = -Infinity;\r\n                                smallestY = Infinity;\r\n                                largestY = -Infinity;\r\n    \r\n                                polyPoints = null;\r\n                                if (entity.polygon) {\r\n                                    polyPoints = entity.polygon;\r\n                                } else if (entity.polyline) {\r\n                                    polyPoints = entity.polyline;\r\n                                }\r\n    \r\n                                for (x = 0; x < polyPoints.length; x++) {\r\n                                    if (polyPoints[x].x > largestX) {\r\n                                        largestX = polyPoints[x].x;\r\n                                    }\r\n                                    if (polyPoints[x].x < smallestX) {\r\n                                        smallestX = polyPoints[x].x;\r\n                                    }\r\n                                    if (polyPoints[x].y > largestY) {\r\n                                        largestY = polyPoints[x].y;\r\n                                    }\r\n                                    if (polyPoints[x].y < smallestY) {\r\n                                        smallestY = polyPoints[x].y;\r\n                                    }\r\n                                }\r\n                                properties.width = largestX - smallestX;\r\n                                properties.height = largestY - smallestY;\r\n                                properties.x = entity.x + mapOffsetX;\r\n                                properties.y = entity.y + mapOffsetY;\r\n    \r\n                                widthOffset = 0;\r\n                                heightOffset = 0;\r\n    \r\n                                if (entity.polygon) {\r\n                                    properties.shape = getPolyShape('polygon', polyPoints, properties.decomposedPolygon);\r\n                                } else if (entity.polyline) {\r\n                                    properties.shape = getPolyShape('polyline', polyPoints, null);\r\n                                }\r\n\r\n                                if (entity.rotation) {\r\n                                    properties.rotation = entity.rotation;\r\n                                }\r\n                            } else {\r\n                                fallbackWidth = tileWidth;\r\n                                fallbackHeight = tileHeight;\r\n                                widthOffset = 0;\r\n                                heightOffset = 0;\r\n                                properties.width = entity.width || 0;\r\n                                properties.height = entity.height || 0;\r\n    \r\n                                if (entityDefProps) {\r\n                                    if (typeof entityDefProps.width === 'number') {\r\n                                        properties.width = entityDefProps.width;\r\n                                        widthOffset = fallbackWidth;\r\n                                    }\r\n                                    if (typeof entityDefProps.height === 'number') {\r\n                                        properties.height = entityDefProps.height;\r\n                                        heightOffset = fallbackHeight;\r\n                                    }\r\n                                }\r\n    \r\n                                if (!entity.point) {\r\n                                    if (!properties.width) {\r\n                                        properties.width = fallbackWidth;\r\n                                    }\r\n                                    if (!properties.height) {\r\n                                        properties.height = fallbackHeight;\r\n                                    }\r\n                                    widthOffset = widthOffset || properties.width;\r\n                                    heightOffset = heightOffset || properties.height;\r\n                                }\r\n    \r\n                                properties.x = entity.x;\r\n                                properties.y = entity.y;\r\n    \r\n                                if (entity.rotation) {\r\n                                    w = (entity.width || fallbackWidth) / 2;\r\n                                    h = (entity.height || fallbackHeight) / 2;\r\n                                    a = ((entity.rotation / 180) % 2) * Math.PI;\r\n                                    v = _Vector_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(w, -h).rotate(a);\r\n                                    properties.rotation = entity.rotation;\r\n                                    properties.x = Math.round((properties.x + v.x - w) * clamp) / clamp;\r\n                                    properties.y = Math.round((properties.y + v.y + h) * clamp) / clamp;\r\n                                    v.recycle();\r\n                                }\r\n    \r\n                                if (entityPositionX === 'left') {\r\n                                    properties.regX = 0;\r\n                                } else if (entityPositionX === 'center') {\r\n                                    properties.regX = properties.width / 2;\r\n                                    properties.x += widthOffset / 2;\r\n                                } else if (entityPositionX === 'right') {\r\n                                    properties.regX = properties.width;\r\n                                    properties.x += widthOffset;\r\n                                }\r\n                                properties.x += mapOffsetX;\r\n    \r\n                                if (gid === -1) {\r\n                                    properties.y += properties.height;\r\n                                }\r\n                                if (entityPositionY === 'bottom') {\r\n                                    properties.regY = properties.height;\r\n                                } else if (entityPositionY === 'center') {\r\n                                    properties.regY = properties.height / 2;\r\n                                    properties.y -= heightOffset / 2;\r\n                                } else if (entityPositionY === 'top') {\r\n                                    properties.regY = 0;\r\n                                    properties.y -= heightOffset;\r\n                                }\r\n                                properties.y += mapOffsetY;\r\n    \r\n                                if (entity.ellipse) {\r\n                                    properties.shape = {};\r\n                                    properties.shape.type = 'circle';//'ellipse';\r\n                                    properties.shape.width = properties.width;\r\n                                    properties.shape.height = properties.height;\r\n    \r\n                                    // Tiled has ellipses, but Platypus only accepts circles. Setting a radius based on the average of width and height in case a non-circular ellipse is imported.\r\n                                    properties.shape.radius = (properties.width + properties.height) / 4;\r\n                                } else if (entity.width && entity.height) {\r\n                                    properties.shape = {};\r\n                                    properties.shape.type = 'rectangle';\r\n                                    properties.shape.width = properties.width;\r\n                                    properties.shape.height = properties.height;\r\n                                }\r\n                            }\r\n    \r\n                            if (entityDefProps) {\r\n                                properties.scaleX *= (entityDefProps.scaleX || 1);\r\n                                properties.scaleY *= (entityDefProps.scaleY || 1);\r\n                            }\r\n                            properties.layerZ = this.layerZ;\r\n    \r\n                            //Setting the z value. All values are getting added to the layerZ value.\r\n                            if (properties.z) {\r\n                                properties.z += this.layerZ;\r\n                            } else if (entityDefProps && (typeof entityDefProps.z === 'number')) {\r\n                                properties.z = this.layerZ + entityDefProps.z;\r\n                            } else {\r\n                                properties.z = this.layerZ;\r\n                            }\r\n    \r\n                            entity = this.owner.addEntity(new _Entity_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](entityDefinition, {\r\n                                properties: properties\r\n                            }, this.updateLoadingProgress.bind(this, progress), this.owner));\r\n                            if (entity) {\r\n                                if (entity.camera) {\r\n                                    this.followEntity = {\r\n                                        entity: entity,\r\n                                        mode: entity.camera\r\n                                    }; //used by camera\r\n                                }\r\n                                this.owner.triggerEvent('entity-created', entity);\r\n                            }\r\n                        } else {\r\n                            this.updateLoadingProgress(progress);\r\n                        }\r\n                    }\r\n                    this.layerZ += this.layerIncrement;\r\n                };\r\n            }()),\r\n\r\n            setupLayer: function (layer, layerCollides, combineRenderLayer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, progress) {\r\n                var canCombine = false,\r\n                    specified = getProperty(layer.properties, 'entity'),\r\n                    entity = specified || 'render-layer', // default\r\n                    entityDefinition = null,\r\n                    i = 0;\r\n                \r\n                // First determine which type of entity this layer should behave as:\r\n                if (!specified) {\r\n                    if (layer.name === \"collision\") {\r\n                        entity = 'collision-layer';\r\n                    } else if (layer.name === \"action\") {\r\n                        if (layerCollides) {\r\n                            entity = 'tile-layer';\r\n                        } else {\r\n                            entity = 'render-layer';\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (entity === 'tile-layer' || (this.showCollisionTiles && platypus.game.settings.debug)) {\r\n                    progress.count += 1; // to compensate for creating 2 layers. The \"tile-layer\" option should probably be deprecated as soon as support for Tiled's tile collision is added.\r\n                    this.createLayer('collision-layer', layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer, progress);\r\n                    return this.createLayer('render-layer', layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer, progress);\r\n                } else if (entity === 'collision-layer') {\r\n                    this.createLayer('collision-layer', layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer, progress);\r\n                    return null;\r\n                } else {\r\n                    // Need to check whether the entity can be combined for optimization. This combining of tile layers might be a nice addition to the compilation tools so it's not happening here.\r\n                    entityDefinition = platypus.game.settings.entities[entity];\r\n                    if (entityDefinition) {\r\n                        i = entityDefinition.components.length;\r\n                        while (i--) {\r\n                            if (entityDefinition.components[i].type === \"RenderTiles\") {\r\n                                canCombine = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (canCombine) {\r\n                        return this.createLayer(entity, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer, progress);\r\n                    } else {\r\n                        this.createLayer(entity, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer, progress);\r\n                        return null;\r\n                    }\r\n                }\r\n            },\r\n            \r\n            updateLoadingProgress: function (progress) {\r\n                progress.count += 1;\r\n                progress.progress = progress.count / progress.total;\r\n\r\n                /**\r\n                 * As a level is loaded, this event is triggered to show progress.\r\n                 *\r\n                 * @event 'level-loading-progress'\r\n                 * @param message {platypus.Data} Contains progress data.\r\n                 * @param message.count {Number} The number of loaded entities.\r\n                 * @param message.progress {Number} A fraction of count / total.\r\n                 * @param message.total {Number} The total number of entities being loaded by this component.\r\n                 * @since 0.8.3\r\n                 */\r\n                this.owner.triggerEvent('level-loading-progress', progress);\r\n\r\n                if (progress.count === progress.total) {\r\n                    progress.recycle();\r\n                    this.finishedLoading();\r\n                }\r\n            },\r\n\r\n            destroy: function () {\r\n            }\r\n        },\r\n        \r\n        publicMethods: {\r\n            /**\r\n             * This method decodes a Tiled layer and sets its data to CSV format.\r\n             *\r\n             * @method decodeLayer\r\n             * @param layer {Object} An object describing a Tiled JSON-exported layer.\r\n             * @return {Object} The same object provided, but with the data field updated.\r\n             * @chainable\r\n             * @since 0.7.1\r\n             */\r\n            decodeLayer: function (layer) {\r\n                if (layer.encoding === 'base64') {\r\n                    layer.data = decodeBase64(layer.data, layer.compression);\r\n                    layer.encoding = 'csv'; // So we won't have to decode again.\r\n                }\r\n                return layer;\r\n            }\r\n        },\r\n        \r\n        getAssetList: function (def, props, defaultProps) {\r\n            var ps = props || {},\r\n                dps = defaultProps || {},\r\n                ss     = def.spriteSheet || ps.spriteSheet || dps.spriteSheet,\r\n                images = def.images || ps.images || dps.images,\r\n                assets = checkLevel(def.level || ps.level || dps.level, ss);\r\n            \r\n            if (ss) {\r\n                if (typeof ss === 'string') {\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, platypus.game.settings.spriteSheets[ss].images);\r\n                } else {\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, ss.images);\r\n                }\r\n            }\r\n            \r\n            if (images) {\r\n                Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"union\"])(assets, images);\r\n            }\r\n            \r\n            return assets;\r\n        },\r\n        \r\n        getLateAssetList: function (def, props, defaultProps, data) {\r\n            var ps  = props || {},\r\n                dps = defaultProps || {},\r\n                ss  = def.spriteSheet || ps.spriteSheet || dps.spriteSheet;\r\n\r\n            if (data && data.level) {\r\n                return checkLevel(data.level, ss);\r\n            } else {\r\n                return _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            }\r\n        }\r\n    });\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://platypus/./src/components/TiledLoader.js?");

/***/ }),

/***/ "./src/components/Timeline.js":
/*!************************************!*\
  !*** ./src/components/Timeline.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/**\r\n * Timeline enables the scheduling of events based on a linear timeline\r\n *\r\n * @class Timeline\r\n * @uses platypus.Component\r\n * @since 0.8.7\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var pause = function () {\r\n            this.active--;\r\n        },\r\n        play = function () {\r\n            this.active++;\r\n        },\r\n        timelineTrigger = function (timelineId) {\r\n            this.timelineInstances.push(this.createTimeStampedTimeline(this.timelines[timelineId]));\r\n        },\r\n        updateLogic = function (tick) {\r\n            var delta = tick.delta,\r\n                instance = null,\r\n                instances = this.timelineInstances,\r\n                i = instances.length;\r\n            \r\n            while (i--) {\r\n                instance = instances[i];\r\n                if (instance.remove) {\r\n                    Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(instances, i);\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(instance.timeline);\r\n                    instance.recycle();\r\n                } else if (instance.active) {\r\n                    if (instance.timeline.length === 0) {\r\n                        Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSplice\"])(instances, i);\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(instance.timeline);\r\n                        instance.recycle();\r\n                    } else {\r\n                        this.progressTimeline(instance, delta);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    \r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'Timeline',\r\n        \r\n        properties: {\r\n            /**\r\n             * Defines the set of timelines. Triggering the key for one of the events will run the timeline. A timeline can contain three different types integers >= 0, strings, and objects. Integers are interpreted as waits and define\r\n             * pauses between events. Strings are intepreted as event calls. Objects can contain several parameters: entity, event, message. The entity is the id of the entity that\r\n             * the event will be fired on. The event can be a string or array. If a string, it will call that event on the entity or owner. If an array, the value will be passed\r\n             * to the event handling system.\r\n             *\r\n             *  \"timelines\": {\r\n             *      \"sample-timeline-1\": [\r\n             *          500,\r\n             *          \"sample-event\",\r\n             *          {\"event\": \"sample-event\", \"message\": \"sample-message\"},\r\n             *          {\"entity\": \"entity-id-to-trigger-event-on\", \"event\": \"sample-event\"},\r\n             *          {\"event\": [\"sample-event\", \"sample-event-2\", {\"event\": \"sample-event-3\", \"message\": \"sample-message\"}]},\r\n             *      ],\r\n             *      \"sample-timeline-2\": [\r\n             *          200,\r\n             *          \"sample-event\"\r\n             *      ]\r\n             * }\r\n             *\r\n             * @property timelines\r\n             * @type Object\r\n             * @default {}\r\n             */\r\n            \"timelines\": {}\r\n        },\r\n        \r\n        initialize: function () {\r\n            var x = 0;\r\n            \r\n            this.timelineInstances = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            for (x in this.timelines) {\r\n                if (this.timelines.hasOwnProperty(x)) {\r\n                    this.addEventListener(x, timelineTrigger.bind(this, x));\r\n                }\r\n            }\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * Checks game clock against timelines and triggers events as needed.\r\n             *\r\n             * @method 'handle-logic'\r\n             * @param tick.delta {Number} The length of the tick.\r\n             */\r\n            \"handle-logic\": updateLogic,\r\n\r\n            /**\r\n             * Stops all timelines.\r\n             *\r\n             * @method 'stop-active-timelines'\r\n             * @since v0.12.0\r\n             */\r\n            \"stop-active-timelines\": function () {\r\n                var instances = this.timelineInstances,\r\n                    i = instances.length;\r\n\r\n                while (i--) {\r\n                    instances[i].remove = true;\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {\r\n            createTimeStampedTimeline: function (timeline) {\r\n                var timeStampedTimeline = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                    x = 0,\r\n                    timeOffset = 0,\r\n                    entry = null;\r\n                \r\n                for (x = 0; x < timeline.length; x++) {\r\n                    entry = timeline[x];\r\n                    if (typeof entry === 'number') {\r\n                        timeOffset += entry;\r\n                    } else {\r\n                        timeStampedTimeline.push(_Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\r\n                            \"time\", timeOffset,\r\n                            \"value\", entry\r\n                        ));\r\n                    }\r\n                }\r\n                timeStampedTimeline.reverse();\r\n                return _Data_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(\r\n                    \"timeline\", timeStampedTimeline,\r\n                    \"time\", 0,\r\n                    \"active\", 1,\r\n                    \"pause\", pause,\r\n                    \"play\", play,\r\n                    \"remove\", false\r\n                );\r\n            },\r\n            progressTimeline: function (instance, delta) {\r\n                var timeline = instance.timeline,\r\n                    i = timeline.length,\r\n                    entry = null,\r\n                    value = null,\r\n                    triggerOn = this.owner;\r\n                \r\n                instance.time += delta;\r\n                \r\n                //Go through the timeline playing events if the time has progressed far enough to trigger them.\r\n                while (i--) {\r\n                    entry = timeline[i];\r\n                    if (entry.time <= instance.time) {\r\n                        value = entry.value;\r\n                        if (typeof value === 'string') {\r\n                            this.owner.triggerEvent(value);\r\n                        } else {\r\n                            if (value.entity) {\r\n                                if (this.owner.getEntityById) {\r\n                                    triggerOn = this.owner.getEntityById(value.entity);\r\n                                } else {\r\n                                    triggerOn = this.owner.parent.getEntityById(value.entity);\r\n                                }\r\n                                \r\n                                if (!triggerOn) {\r\n                                    platypus.debug.warn('No entity of that id');\r\n                                    triggerOn = this.owner;\r\n                                }\r\n                            }\r\n                            \r\n                            if (value.message) {\r\n                                triggerOn.triggerEvent(value.event, value.message);\r\n                            } else {\r\n                                triggerOn.trigger(value.event);\r\n                            }\r\n                        }\r\n                        \r\n                        entry.recycle();\r\n                        timeline.pop(); //Remove the entry.\r\n                        if (!instance.active) {\r\n                            return; //We bail until the callback.\r\n                        }\r\n                    } else {\r\n                        return;\r\n                    }\r\n                    \r\n                    entry = null;\r\n                    value = null;\r\n                    triggerOn = this.owner;\r\n                }\r\n            },\r\n            destroy: function () {\r\n                var instance = null,\r\n                    instances = this.timelineInstances,\r\n                    i = instances.length;\r\n                \r\n                while (i--) {\r\n                    instance = instances[i];\r\n                    _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(instance.timeline);\r\n                    instance.recycle();\r\n                }\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(instances);\r\n                this.timelineInstances = null;\r\n            }\r\n        }\r\n    });\r\n}());\n\n//# sourceURL=webpack://platypus/./src/components/Timeline.js?");

/***/ }),

/***/ "./src/components/Tutorial.js":
/*!************************************!*\
  !*** ./src/components/Tutorial.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n * Tutorial provides a framework for playing tutorials. It allows the user to define things such as under what conditions tutorials will play, how often they play, and which tutorials have priority.\r\n *\r\n * @class Tutorial\r\n * @uses platypus.Component\r\n * @since 0.8.7\r\n */\r\n/*global platypus */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var entityAdded = function (entity) {\r\n            var entityType = null;\r\n                \r\n            for (entityType in this.watchedEntities) {\r\n                if (entity.type === entityType) {\r\n                    this.watchedEntities[entityType].push(entity);\r\n                }\r\n            }\r\n        },\r\n        entityRemoved = function (entity) {\r\n            var x = 0,\r\n                entityType = entity.type;\r\n\r\n            for (x = this.watchedEntities[entityType].length - 1; x >= 0; x--) {\r\n                if (this.watchedEntities[entityType][x] === entity) {\r\n                    this.watchedEntities[entityType].splice(x, 1);\r\n                    break;\r\n                }\r\n            }\r\n        },\r\n        updateLogic = function (tick) {\r\n            var delta = tick.delta,\r\n                x = 0,\r\n                tut = null,\r\n                toPlay = null,\r\n                toPlayIndex = -1,\r\n                keepChecking = false,\r\n                tutorial = null;\r\n            \r\n            for (x = 0; x < this.tutorials.length; x++) {\r\n                keepChecking = false;\r\n                tut = this.tutorials[x];\r\n\r\n                if (!this.playing && this.theQueue.length === 0) {\r\n                    keepChecking = true;\r\n                } else if ((!this.playing && this.theQueue.length > 0) && (tut.priority > this.theQueue[0].priority)) {\r\n                    keepChecking = true;\r\n                } else if (this.playing && (this.playing.priority < tut.priority)) {\r\n                    keepChecking = true;\r\n                } else if (tut.queue) {\r\n                    keepChecking = true;\r\n                }\r\n\r\n                if (!keepChecking) {\r\n                    continue;\r\n                }\r\n\r\n                if (this.checkRequirements(tut.requirements)) {\r\n                    if (tut.replayDelay && tut.replayDelayTimer > 0) {\r\n                        tut.replayDelayTimer -= delta;\r\n                        if (tut.replayDelayTimer > 0) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                    \r\n                    if (!toPlay || toPlay.priority < tut.priority) {\r\n                        //TML - If we only have one item we try to play, then we may prevent certain audio from playing if it's only valid for a single tick.\r\n                        toPlay = tut;\r\n                        toPlayIndex = x;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (toPlay) {\r\n                tutorial = this.tutorials.splice(toPlayIndex, 1)[0];\r\n                if (this.playing) {\r\n                    if (tutorial.priority > this.playing.priority) {\r\n                        this.owner.triggerEvent('stop-audio');\r\n                        this.play(tutorial);\r\n                    } else {\r\n                        this.queue(tutorial);\r\n                    }\r\n                } else if (this.theQueue.length > 0) {\r\n                    if (tutorial.priority > this.theQueue[0].priority) {\r\n                        this.play(tutorial);\r\n                    } else {\r\n                        this.play(this.theQueue.splice(0, 1)[0]);\r\n                        this.queue(tutorial);\r\n                    }\r\n                } else {\r\n                    this.play(tutorial);\r\n                }\r\n            } else if (!this.playing && this.theQueue.length > 0) {\r\n                this.play(this.theQueue.splice(0, 1)[0]);\r\n            }\r\n        };\r\n\r\n    return platypus.createComponentClass({\r\n        \r\n        id: 'Tutorial',\r\n        \r\n        properties: {\r\n            \r\n            /* An array of tutorial definition objects. These objects define what events will be called by the tutorial, the priority of the tutorial, how often and how many times it will fire, the required conditions for it to fire, and more.\r\n             *\r\n             * \"tutorialDefs\": [\r\n             *      {\r\n             *          \"events\": [\"example-vo-event\"],         //An Array of Strings. Defines the events to fire when all the conditions for this tutorial are met. If there are multiple events, one is chosen at random. All events in the array will play before any repeat.\r\n             *          \"priority\": 5,                          //The priorioty of the tutorial. Higher numbered tutorials interrupt lower numbered. Default: 0.\r\n             *          \"queue\": true,                          //Will the tutorial queue up if played while another tutorial is playing? Default: false.\r\n             *          \"timesToReplay\": 3,                     //The number of times a tutorial will replay. Set to 0 to make a tutorial play only once. Default: Infinity.\r\n             *          \"replayDelay\": 10000,                   //While the conditions are met, the tutorial will replay at this interval in milliseconds. If set to null, it will not repeat. Default: null.\r\n             *          \"level\": \"example-level\",               //Tutorial will only play when this level is the currently loaded level.\r\n             *          \"requirements\": {                       //The requirements is a collection of entities types that are watched by the tutorial to determine if the conditions to play this tutorial are true.\r\n             *              \"example-entity-type\": [\"example-entity-state\"]     //The requirements is a set of key-value pairs. The keys are entity types that the tutorial will watch. The values are arrays of states of that entity type which must be true for the tutorial to play.\r\n             *          }\r\n             *      }\r\n             * ]\r\n             *\r\n             * @property tutorialDefs\r\n             * @type Array [Object]\r\n             * @default []\r\n             */\r\n            \"tutorialDefs\": []\r\n        },\r\n         \r\n        publicProperties: {\r\n            \r\n        },\r\n        \r\n        initialize: function () {\r\n            var x = 0,\r\n                entityType = null,\r\n                tutDef = null,\r\n                tutorial = null;\r\n                \r\n            this.playing = null;\r\n            this.theQueue = [];\r\n            this.watchedEntities = {};\r\n            this.tutorials = [];\r\n\r\n                \r\n            for (x = 0; x < this.tutorialDefs.length; x++) {\r\n                tutDef = this.tutorialDefs[x];\r\n                tutorial = {};\r\n                if (!tutDef.events) {\r\n                    platypus.debug.warn(\"Tutorial definition lacks events.\");\r\n                    continue;\r\n                }\r\n                tutorial.events = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(tutDef.events);\r\n                tutorial.originalEvents = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(tutDef.events);\r\n                tutorial.priority = tutDef.priority || 0;\r\n                tutorial.queue = tutDef.queue || false;\r\n                tutorial.timesToReplay = (typeof tutDef.timesToReplay === 'number') ? tutDef.timesToReplay : Infinity;\r\n                tutorial.replayDelay = tutDef.replayDelay || null;\r\n                tutorial.replayDelayTimer = tutorial.replayDelay;\r\n                tutorial.level = tutDef.level;\r\n                tutorial.requirements = {};\r\n                for (entityType in tutDef.requirements) {\r\n                    if (tutDef.requirements.hasOwnProperty(entityType)) {\r\n                        tutorial.requirements[entityType] = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(tutDef.requirements[entityType]);\r\n                        if (!this.watchedEntities[entityType]) {\r\n                            this.watchedEntities[entityType] = [];\r\n                        }\r\n                    }\r\n                }\r\n                this.tutorials.push(tutorial);\r\n            }\r\n            \r\n        },\r\n\r\n        events: {// These are messages that this component listens for\r\n            \r\n            /**\r\n             * Checks added entity to determine if it is one of the conditions for one of the tutorials. If so, we track it.\r\n             *\r\n             * @method 'child-entity-added'\r\n             * @param entity {Object} The added entity.\r\n             */\r\n            \"child-entity-added\": entityAdded,\r\n\r\n            /**\r\n             * Checks added entity to determine if it is one of the conditions for one of the tutorials. If so, we track it.\r\n             *\r\n             * @method 'peer-entity-added'\r\n             * @param entity {Object} The added entity.\r\n             */\r\n            \"peer-entity-added\": entityAdded,\r\n\r\n            /**\r\n             * Removes entities from the watch list when they are destroyed.\r\n             *\r\n             * @method 'child-entity-removed'\r\n             * @param entity {Object} The removed entity.\r\n             */\r\n            \"child-entity-removed\": entityRemoved,\r\n\r\n            /**\r\n             * Removes entities from the watch list when they are destroyed.\r\n             *\r\n             * @method 'peer-entity-removed'\r\n             * @param entity {Object} The removed entity.\r\n             */\r\n            \"peer-entity-removed\": entityRemoved,\r\n            \r\n            /**\r\n             * Checks tutorials to determine if they should play.\r\n             *\r\n             * @method 'handle-logic'\r\n             * @param tick.delta {Number} The length of the tick.\r\n             */\r\n            \"handle-logic\": updateLogic,\r\n\r\n            /**\r\n             * Fired when audioVO finishes. Clears the playing tutorial returning it to the internal list of tutorials if it will be played again.\r\n             *\r\n             * @method 'sequence-complete'\r\n             */\r\n            \"sequence-complete\": function () {\r\n                if (this.playing.timesToReplay >= 0) {\r\n                    this.tutorials.push(this.playing);\r\n                }\r\n                this.playing = null;\r\n            }\r\n        },\r\n        \r\n        methods: {// These are internal methods that are invoked by this component.\r\n            play: function (tutorial) {\r\n                var toCall = null;\r\n\r\n                this.playing = tutorial;\r\n                if (this.playing.events.length === 0) {\r\n                    this.playing.events = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(this.playing.originalEvents);\r\n                }\r\n\r\n                toCall = this.playing.events.splice(Math.floor(Math.random() * this.playing.events.length), 1)[0];\r\n\r\n                this.owner.triggerEvent(toCall);\r\n\r\n                tutorial.timesToReplay -= 1;\r\n                tutorial.replayDelayTimer = tutorial.replayDelay;\r\n            },\r\n            queue: function (tutorial) {\r\n                var x = 0,\r\n                    added = false;\r\n\r\n                for (x = 0; x < this.theQueue.length; x++) {\r\n                    if (this.theQueue[x].priority < tutorial.priority) {\r\n                        this.theQueue.splice(x, 0, tutorial);\r\n                        added = true;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                if (!added) {\r\n                    this.theQueue.push(tutorial);\r\n                }\r\n            },\r\n            checkRequirements: function (requirements) {\r\n                var x = 0,\r\n                    y = 0,\r\n                    entityType = null,\r\n                    states = null,\r\n                    anEntity = null,\r\n                    metRequirement = true;\r\n\r\n                for (entityType in requirements) { //Going through the types of entities\r\n                    if (requirements.hasOwnProperty(entityType)) {\r\n                        states = requirements[entityType];\r\n                        for (y = this.watchedEntities[entityType].length - 1; y >= 0; y--) {  //Going through the instances of those entities\r\n                            anEntity = this.watchedEntities[entityType][y];\r\n                            metRequirement = true;\r\n                            for (x = 0; x < states.length; x++) {   //Going through the required states of an entity instance\r\n                                if (!anEntity.state.get(states[x])) {\r\n                                    metRequirement = false;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (metRequirement) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!metRequirement) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n            },\r\n            destroy: function () {\r\n                this.watchedEntities = null;\r\n                this.theQueue = null;\r\n                this.playing = null;\r\n                this.tutorials = null;\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/Tutorial.js?");

/***/ }),

/***/ "./src/components/Tween.js":
/*!*********************************!*\
  !*** ./src/components/Tween.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Data.js */ \"./src/Data.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tweenjs/tween.js */ \"@tweenjs/tween.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/**\r\n * This component takes a list of tween definitions and plays them as needed. This component requires TweenJS.\r\n *\r\n * @namespace platypus.components\r\n * @class Tween\r\n * @uses platypus.Component\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\nconst\r\n    Easing = _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1___default.a.Easing,\r\n    Group = _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1___default.a.Group,\r\n    Interpolation = _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1___default.a.Interpolation,\r\n    Tween = _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1___default.a.Tween,\r\n    eases = (function () {\r\n        const easing = {};\r\n\r\n        for (const key in Easing) {\r\n            if (Easing.hasOwnProperty(key)) {\r\n                for (const type in Easing[key]) {\r\n                    if (Easing[key].hasOwnProperty(type)) {\r\n                        easing[key + '.' + type] = Easing[key][type];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return easing;\r\n    }()),\r\n    trigger = function () {\r\n        this.trigger.apply(this, arguments);\r\n    };\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (platypus.createComponentClass({\r\n    id: 'Tween',\r\n\r\n    properties: {\r\n        /**\r\n         * Required. A key/value list of events and an array or object representing the tween they should trigger.\r\n         *\r\n         *      {\r\n         *          \"begin-flying\": { // When \"begin-flying\" is triggered on this entity, the following tween begins. Tween definitions adhere to a similar structure outlined by the [TweenJS documentation](https://github.com/tweenjs/tween.js/blob/master/docs/user_guide.md).\r\n         *              \"target\": \"entityId\", // This defaults to the entity that this component is on, but can be the id of any entity in this layer.\r\n         *              \"to\": { // Specifies the values to change and what they should tween to.\r\n         *                  \"scaleY\": 1,\r\n         *                  \"y\": [400, 450, 425]\r\n         *              },\r\n         *              \"time\": 1000, // Time in MS to make transition.\r\n         *              \"easing\": \"Quadratic.In\", Easing function to use.\r\n         *              \"onUpdate\": \"flying\", // Event to trigger while transition is running.\r\n         *              \"onStart\": \"wave\", // Event to trigger when tween begins (after delay).\r\n         *              \"onStop\": \"whoa\", // Event to trigger when tween is stopped (not completed normally).\r\n         *              \"onComplete\": \"done\", // Event to trigger when tween is complete.\r\n         *              \"onRepeat\": \"going-again\", // Event to trigger when tween is beginning again.\r\n         *              \"chain\": \"stop-flying\", // Specifies a tween to use next.\r\n         *              \"repeat\": 0, // Sets how many times to repeat this tween once it completes.\r\n         *              \"yoyo\": false, // If this tween repeats, yoyo makes it transition back-and-forth.\r\n         *              \"delay\": 500, // Time in MS to delay before starting transition.\r\n         *              \"repeatDelay\": 0, // Time in MS that the transition should wait between repeats if it shouldn't be the `delay` value.\r\n         *              \"interpolation\": \"Linear\" // Interpolation method to use for an array of values.\r\n         *          },\r\n         *\r\n         *          \"stop-flying\": [{ // May also chain tweens by specifying an array.\r\n         *              \"to\": {\"y\": 100},\r\n         *              \"time\": 250\r\n         *          }, {\r\n         *              \"to\": {\"y\": 0},\r\n         *              \"time\": 250\r\n         *          }]\r\n         *      }\r\n         *\r\n         * @property events\r\n         * @type Object\r\n         * @default null\r\n         */\r\n        events: null\r\n    },\r\n    \r\n    initialize: function () {\r\n        var event = '',\r\n            events = this.events;\r\n\r\n        this.group = new Group();\r\n\r\n        this.waitingToChain = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\r\n        this.tweens = _Data_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\r\n\r\n        this.time = 0;\r\n        \r\n        if (events) {\r\n            for (event in events) {\r\n                if (events.hasOwnProperty(event)) {\r\n                    const tween = this.tweens[event] = this.createTweens(events[event]);\r\n                    this.addEventListener(event, this.runTween.bind(this, event));\r\n\r\n                    if (this.waitingToChain[event]) {\r\n                        const waits = this.waitingToChain[event];\r\n\r\n                        for (let i = 0; i < waits.length; i++) {\r\n                            waits[i].chain(tween);\r\n                        }\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].recycle(waits);\r\n                        delete this.waitingToChain[event];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    events: {\r\n        'tween': function (tween) {\r\n            this.runTween(tween);\r\n        },\r\n\r\n        'handle-logic': function (tick) {\r\n            this.time += tick.delta;\r\n            this.group.update(this.time);\r\n        }\r\n    },\r\n\r\n    methods: {\r\n        createTween: function (tweenDefinition, chainable) {\r\n            const owner = this.owner,\r\n                entity = tweenDefinition.target ? (typeof tweenDefinition.target === 'string' ? owner.parent.getEntityById(tweenDefinition.target) : tweenDefinition.target) : owner;\r\n\r\n            if (!entity) {\r\n                platypus.debug.warn('Component Tween: Could not find entity as specified by `target` - ' + tweenDefinition.target);\r\n                return null;\r\n            } else if (!tweenDefinition.to || !tweenDefinition.time) {\r\n                platypus.debug.warn('Component Tween: Both `time` and `to` must be specified to create tween.');\r\n                return null;\r\n            } else {\r\n                const tween = new Tween(entity, this.group);\r\n\r\n                tween.to(tweenDefinition.to, tweenDefinition.time);\r\n\r\n                if (tweenDefinition.onUpdate) {\r\n                    tween.onUpdate((typeof tweenDefinition.onUpdate !== 'function') ? trigger.bind(owner, tweenDefinition.onUpdate) : tweenDefinition.onUpdate);\r\n                }\r\n                if (tweenDefinition.onStart) {\r\n                    tween.onStart((typeof tweenDefinition.onStart !== 'function') ? trigger.bind(owner, tweenDefinition.onStart) : tweenDefinition.onStart);\r\n                }\r\n                if (tweenDefinition.onStop) {\r\n                    tween.onStop((typeof tweenDefinition.onStop !== 'function') ? trigger.bind(owner, tweenDefinition.onStop) : tweenDefinition.onStop);\r\n                }\r\n                if (tweenDefinition.onComplete) {\r\n                    tween.onComplete((typeof tweenDefinition.onComplete !== 'function') ? trigger.bind(owner, tweenDefinition.onComplete) : tweenDefinition.onComplete);\r\n                }\r\n                if (tweenDefinition.onRepeat) {\r\n                    tween.onRepeat((typeof tweenDefinition.onRepeat !== 'function') ? trigger.bind(owner, tweenDefinition.onRepeat) : tweenDefinition.onRepeat);\r\n                }\r\n\r\n                if (tweenDefinition.chain) {\r\n                    if (!chainable) {\r\n                        platypus.debug.warn('Component Tween: ignoring `chain` on tween since it is part of an array of tweens.');\r\n                    } else if (typeof tweenDefinition.chain === 'string') {\r\n                        if (this.tweens[tweenDefinition.chain]) {\r\n                            tween.chain(this.tweens[tweenDefinition.chain]);\r\n                        } else {\r\n                            if (!this.waitingToChain[tweenDefinition.chain]) {\r\n                                this.waitingToChain[tweenDefinition.chain] = _utils_array_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCache\"].setUp();\r\n                            }\r\n                            this.waitingToChain[tweenDefinition.chain].push(tween);\r\n                        }\r\n                    } else {\r\n                        tween.chain(tweenDefinition.chain);\r\n                    }\r\n                }\r\n\r\n                if (tweenDefinition.repeat) {\r\n                    tween.repeat(tweenDefinition.repeat);\r\n                }\r\n                if (tweenDefinition.yoyo) {\r\n                    tween.yoyo();\r\n                }\r\n                if (tweenDefinition.delay) {\r\n                    tween.delay(tweenDefinition.delay);\r\n                }\r\n                if (tweenDefinition.repeatDelay) {\r\n                    tween.repeatDelay(tweenDefinition.repeatDelay);\r\n                }\r\n                \r\n                if (tweenDefinition.interpolation) {\r\n                    if (typeof tweenDefinition.interpolation === 'function') {\r\n                        tween.interpolation(tweenDefinition.interpolation);\r\n                    } else if (Interpolation[tweenDefinition.interpolation]) {\r\n                        tween.interpolation(Interpolation[tweenDefinition.interpolation]);\r\n                    } else {\r\n                        platypus.debug.warn('Component Tween: \"' + tweenDefinition.interpolation + '\" is not a valid interpolation value; must be \"Linear\", \"Bezier\", or \"CatmullRom\".');\r\n                    }\r\n                }\r\n           \r\n                if (tweenDefinition.easing) {\r\n                    if (typeof tweenDefinition.easing === 'function') {\r\n                        tween.easing(tweenDefinition.easing);\r\n                    } else if (eases[tweenDefinition.easing]) {\r\n                        tween.easing(eases[tweenDefinition.easing]);\r\n                    } else {\r\n                        let str = '\".',\r\n                            join = '\", or \"';\r\n\r\n                        for (const key in eases) {\r\n                            if (eases.hasOwnProperty(key)) {\r\n                                str = join + key + str;\r\n                                join = '\", \"';\r\n                            }\r\n                        }\r\n                        platypus.debug.warn('Component Tween: \"' + tweenDefinition.easing + '\" is not a valid easing value; must be ' + str.substring(3));\r\n                    }\r\n                }\r\n\r\n                return tween;\r\n            }\r\n        },\r\n\r\n        createTweens: function (tween) {\r\n            if (Array.isArray(tween)) {\r\n                let i = tween.length,\r\n                    lastTween = null;\r\n\r\n                while (i--) {\r\n                    const newTween = this.createTween(tween[i], !lastTween);\r\n\r\n                    if (lastTween) {\r\n                        newTween.chain(lastTween);\r\n                    }\r\n                    lastTween = newTween;\r\n                }\r\n\r\n                return lastTween;\r\n            } else {\r\n                return this.createTween(tween, true);\r\n            }\r\n        },\r\n\r\n        destroy: function () {\r\n            this.group.removeAll();\r\n        },\r\n\r\n        runTween: function (tweenDefinition) {\r\n            var tween = typeof tweenDefinition === 'string' ? this.tweens[tweenDefinition] : this.createTweens(tweenDefinition);\r\n\r\n            if (tween) {\r\n                tween.start(this.time);\r\n            } else {\r\n                platypus.debug.warn('Component Tween: Unable to run requested tween.', tweenDefinition);\r\n            }\r\n        }\r\n    }\r\n}));\r\n\n\n//# sourceURL=webpack://platypus/./src/components/Tween.js?");

/***/ }),

/***/ "./src/components/VoiceOver.js":
/*!*************************************!*\
  !*** ./src/components/VoiceOver.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Async_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Async.js */ \"./src/Async.js\");\n/* harmony import */ var _AudioVO_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AudioVO.js */ \"./src/components/AudioVO.js\");\n/* harmony import */ var _RenderSprite_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RenderSprite.js */ \"./src/components/RenderSprite.js\");\n/**\r\n * This component uses its definition to load an AudioVO component and a RenderSprite component. These work in an interconnected way to render animations corresponding to one or more audio tracks.\r\n *\r\n * In addition to its own properties, this component also accepts all properties accepted by [RenderSprite](platypus.components.RenderSprite.html) and [AudioVO](platypus.components.AudioVO.html) and passes them along when it creates those components.\r\n *\r\n * @namespace platypus.components\r\n * @class VoiceOver\r\n * @uses platypus.Component\r\n * @uses platypus.AudioVO\r\n * @uses platypus.RenderSprite\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var getEventName = function (msg, VO) {\r\n            if (VO === ' ') {\r\n                return msg + 'default';\r\n            } else {\r\n                return msg + VO;\r\n            }\r\n        },\r\n        componentInit = function (Component, definition, callback) {\r\n            this.owner.addComponent(new Component(this.owner, definition, callback));\r\n        },\r\n        createAudioDefinition = function (sound, events, message, frameLength) {\r\n            var i          = 0,\r\n                key        = '',\r\n                definition = {},\r\n                time       = 0,\r\n                lastFrame  = '',\r\n                thisFrame  = '',\r\n                voice = sound.voice,\r\n                mouthCues = sound.mouthCues;\r\n\r\n            if (typeof sound === 'string') {\r\n                definition.sound = sound;\r\n                definition.events = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            } else if (typeof sound.sound === 'string') {\r\n                definition.sound = sound.sound;\r\n                definition.events = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            } else {\r\n                for (key in sound.sound) {\r\n                    if (sound.sound.hasOwnProperty(key)) {\r\n                        definition[key] = sound.sound[key];\r\n                    }\r\n                }\r\n\r\n                if (definition.events) {\r\n                    definition.events = Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(definition.events);\r\n                } else {\r\n                    definition.events = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                }\r\n            }\r\n\r\n            if (!voice && !mouthCues && platypus.game.app.config.mouthCues) {\r\n                mouthCues = platypus.game.app.config.mouthCues[definition.sound];\r\n            }\r\n\r\n            if (voice) {\r\n                voice += ' ';\r\n\r\n                for (i = 0; i < voice.length; i++) {\r\n                    thisFrame = voice[i];\r\n                    if (thisFrame !== lastFrame) {\r\n                        lastFrame = thisFrame;\r\n                        definition.events.push({\r\n                            \"time\": time,\r\n                            \"event\": getEventName(message, thisFrame)\r\n                        });\r\n                    }\r\n                    time += frameLength;\r\n                }\r\n            } else if (mouthCues) {\r\n                for (i = 0; i < mouthCues.length; i++) {\r\n                    thisFrame = mouthCues[i];\r\n                    definition.events.push({\r\n                        \"time\": thisFrame.start * 1000,\r\n                        \"event\": getEventName(message, thisFrame.value)\r\n                    });\r\n                    time += frameLength;\r\n                }\r\n            }\r\n\r\n            return definition;\r\n        },\r\n        createVO = function (sound, events, message, frameLength) {\r\n            var i = 0,\r\n                definitions = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n\r\n            if (!events[' ']) {\r\n                events[' '] = events.default;\r\n            }\r\n\r\n            if (Array.isArray(sound)) {\r\n                for (i = 0; i < sound.length; i++) {\r\n                    if (typeof sound[i] === 'number') {\r\n                        definitions.push(sound[i]);\r\n                    } else {\r\n                        definitions.push(createAudioDefinition(sound[i], events, message, frameLength));\r\n                    }\r\n                }\r\n                return definitions;\r\n            } else {\r\n                return createAudioDefinition(sound, events, message, frameLength);\r\n            }\r\n        };\r\n\r\n    return platypus.createComponentClass({\r\n        id: 'VoiceOver',\r\n        \r\n        properties: {\r\n            /**\r\n             * Sets the pairing between letters in the voice-over strings and the animation frame to play.\r\n             *\r\n             *       \"animationMap\": {\r\n             *         \"default\": \"mouth-closed\"\r\n             *         // Required. Specifies animation of default position.\r\n             *\r\n             *         \"w\": \"mouth-o\",\r\n             *         \"a\": \"mouth-aah\",\r\n             *         \"t\": \"mouth-t\"\r\n             *         // Optional. Also list single characters that should map to a given voice-over animation frame.\r\n             *       }\r\n             *\r\n             * @property animationMap\r\n             * @type Object\r\n             * @default: {\"default\": \"default\"}\r\n             */\r\n            animationMap: {\"default\": \"default\"},\r\n\r\n            /**\r\n             * Specifies the type of component to add to handle VO lip-sync animation.\r\n             *\r\n             * @property renderComponent\r\n             * @type String\r\n             * @default 'renderSprite'\r\n             */\r\n            renderComponent: '',\r\n\r\n            /**\r\n             * Specifies how long a described voice-over frame should last in milliseconds.\r\n             *\r\n             * @property frameLength\r\n             * @type Number\r\n             * @default 100\r\n             */\r\n            frameLength: 100,\r\n\r\n            /**\r\n             * Specifies the prefix that messages between the render and Audio components should use. This will cause the audio to trigger events like \"i-say-w\" and \"i-say-a\" (characters listed in the animationMap), that the RenderSprite uses to show the proper frame.\r\n             *\r\n             * @property messagePrefix\r\n             * @type String\r\n             * @default \"\"\r\n             */\r\n            messagePrefix: \"\",\r\n\r\n            /**\r\n             * This maps events to audio clips and voice over strings.\r\n             *\r\n             *      \"voiceOverMap\": {\r\n             *          \"message-triggered\": [{\r\n             *              \"sound\": \"audio-id\",\r\n             *              // Required. This is the audio clip to play when \"message-triggered\" is triggered. It may be a string as shown or an object of key/value pairs as described in an [[audio]] component definition.\r\n             *              \"voice\": \"waat\"\r\n             *              // Optional. This string defines the voice-over sequence according to the frames defined by animationMap. Each character lasts the length specified by \"frameLength\" above. If not specified, voice will be the default frame.\r\n             *          }]\r\n             *      }\r\n             *\r\n             * @property voiceOverMap\r\n             * @type Object\r\n             * @default {}\r\n             */\r\n            voiceOverMap: {}\r\n        },\r\n\r\n        initialize: function (definition, callback) {\r\n            var i = '',\r\n                componentInits = _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp(),\r\n                audioDefinition     = {\r\n                    audioMap: {},\r\n                    aliases: definition.aliases\r\n                },\r\n                animationDefinition = {\r\n                    acceptInput: definition.acceptInput,\r\n                    aliases: definition.aliases,\r\n                    animation: definition.animation,\r\n                    animationMap: {},\r\n                    eventBased: true, // VO triggers events for changing lip-sync frames.\r\n                    flip: definition.flip,\r\n                    hidden: definition.hidden,\r\n                    interactive: definition.interactive,\r\n                    mask: definition.mask,\r\n                    mirror: definition.mirror,\r\n                    offsetZ: definition.offsetZ,\r\n                    regX: definition.regX,\r\n                    regY: definition.regY,\r\n                    restart: definition.restart,\r\n                    scaleX: definition.scaleX,\r\n                    scaleY: definition.scaleY,\r\n                    spriteSheet: definition.spriteSheet,\r\n                    stateBased: definition.stateBased || false\r\n                };\r\n            \r\n            if (this.messagePrefix) {\r\n                this.message = this.messagePrefix + '-';\r\n            } else {\r\n                this.message = '';\r\n            }\r\n            \r\n            for (i in this.animationMap) {\r\n                if (this.animationMap.hasOwnProperty(i)) {\r\n                    animationDefinition.animationMap[getEventName(this.message, i)] = this.animationMap[i];\r\n                }\r\n            }\r\n            animationDefinition.animationMap.default = this.animationMap.default;\r\n            if (this.renderComponent) {\r\n                componentInits.push(componentInit.bind(this, platypus.components[this.renderComponent], animationDefinition));\r\n            } else {\r\n                componentInits.push(componentInit.bind(this, _RenderSprite_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"], animationDefinition));\r\n            }\r\n\r\n            for (i in this.voiceOverMap) {\r\n                if (this.voiceOverMap.hasOwnProperty(i)) {\r\n                    audioDefinition.audioMap[i] = createVO(this.voiceOverMap[i], this.animationMap, this.message, this.frameLength);\r\n                }\r\n            }\r\n            componentInits.push(componentInit.bind(this, _AudioVO_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], audioDefinition));\r\n\r\n            _Async_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setUp(componentInits, callback);\r\n\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(componentInits);\r\n\r\n            return true;\r\n        },\r\n\r\n        events: {\r\n            /**\r\n             * On receiving this message, this component removes itself from the entity. (It creates the [[RenderSprite]] and [[AudioVO]] components in its constructor.)\r\n             *\r\n             * @method 'load'\r\n             */\r\n            \"load\": function () {\r\n                this.owner.removeComponent(this);\r\n            }\r\n        },\r\n        \r\n        getAssetList: function (component, props, defaultProps) {\r\n            var ss = component.spriteSheet || props.spriteSheet || (defaultProps && defaultProps.spriteSheet);\r\n            \r\n            if (typeof ss === 'string') {\r\n                return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(platypus.game.settings.spriteSheets[ss].images);\r\n            } else if (ss) {\r\n                return Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(ss.images);\r\n            } else {\r\n                return _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/VoiceOver.js?");

/***/ }),

/***/ "./src/components/XHR.js":
/*!*******************************!*\
  !*** ./src/components/XHR.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * This component provides component-based XHR communication with a server.\r\n *\r\n * @namespace platypus.components\r\n * @class XHR\r\n * @uses platypus.Component\r\n */\r\n/* global platypus, window */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    \r\n    \r\n    var XMLHttpRequest = window.XMLHttpRequest;\r\n\r\n    return platypus.createComponentClass({\r\n        id: 'XHR',\r\n        \r\n        properties: {\r\n            /**\r\n             * Sets the XHR method to use.\r\n             *\r\n             * @property method\r\n             * @type String\r\n             * @default \"GET\"\r\n             */\r\n            method: \"GET\",\r\n            \r\n            /**\r\n             * Sets the path to connect to the server.\r\n             *\r\n             * @property path\r\n             * @type String\r\n             * @default \"\"\r\n             */\r\n            path: \"\",\r\n            \r\n            /**\r\n             * Sets the XHR response type.\r\n             *\r\n             * @property responseType\r\n             * @type String\r\n             * @default \"text\"\r\n             */\r\n            responseType: \"text\",\r\n            \r\n            /**\r\n             * Whether cookies should be retained on cross-domain calls.\r\n             *\r\n             * @property withCredentials\r\n             * @type boolean\r\n             * @default false\r\n             */\r\n            withCredentials: false\r\n        },\r\n        \r\n        initialize: function (definition) {\r\n            this.setProperties(definition);\r\n        },\r\n\r\n        events: {// These are messages that this component listens for\r\n            /**\r\n             * On receiving this message, this component makes a request from the server using the provided information. Note that properties set here will reset the properties set by this component's JSON definition.\r\n             *\r\n             * @method 'request'\r\n             * @param message {Object}\r\n             * @param message.method {String} XHR method to use: must be \"GET\" or \"POST\".\r\n             * @param message.path {String} The path to the server resource.\r\n             * @param [message.responseType=\"text\"] {String} Response type expected.\r\n             * @param [message.data] {Object} An object of string key/value pairs to be transmitted to the server.\r\n             * @param message.onload {Function} A function that should be run on receiving a response from the server. This defaults to triggering a \"response\" message containing the responseText value.\r\n             */\r\n            \"request\": function (resp) {\r\n                this.setProperties(resp);\r\n                \r\n                if (this.method === \"GET\") {\r\n                    this.get();\r\n                } else if (this.method === \"POST\") {\r\n                    this.post();\r\n                } else {\r\n                    throw \"Method must be GET or POST\";\r\n                }\r\n            }\r\n        },\r\n        \r\n        methods: {// These are methods that are called on the component\r\n            setProperties: function (properties) {\r\n                var key     = '',\r\n                    divider = '',\r\n                    props   = properties || this;\r\n                \r\n                this.method       = props.method       || this.method       || \"GET\";\r\n                this.path         = props.path         || this.path         || null;\r\n                this.responseType = props.responseType || this.responseType || \"text\";\r\n                this.withCredentials = props.withCredentials || this.withCredentials || false;\r\n                \r\n                if ((props !== this) && props.data) {\r\n                    this.data = '';\r\n                    for (key in props.data) {\r\n                        if (props.data.hasOwnProperty(key)) {\r\n                            this.data += divider + key + '=' + props.data[key];\r\n                            divider = '&';\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.data = '';\r\n                }\r\n                \r\n                this.onload = props.onload || this.onload || function () {\r\n                    if (this.status === 200) {\r\n                        /**\r\n                         * This message is triggered on receiving a response from the server (if \"onload\" is not set by the original \"request\" message).\r\n                         *\r\n                         * @event 'response'\r\n                         * @param message {String} The message contains the responseText returned by the server.\r\n                         */\r\n                        this.owner.triggerEvent('response', this.responseText);\r\n                    }\r\n                }.bind(this);\r\n            },\r\n            get: function () {\r\n                var xhr  = new XMLHttpRequest(),\r\n                    path = this.path;\r\n                \r\n                if (this.data) {\r\n                    path += '?' + this.data;\r\n                }\r\n                \r\n                xhr.open(this.method, path, true);\r\n                xhr.withCredentials = this.withCredentials;\r\n                xhr.responseType = this.responseType;\r\n                xhr.onload = this.onload;\r\n                xhr.send();\r\n            },\r\n            post: function () {\r\n                var xhr = new XMLHttpRequest();\r\n                \r\n                xhr.open(this.method, this.path, true);\r\n                xhr.withCredentials = this.withCredentials;\r\n                xhr.responseType = this.responseType;\r\n                xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\r\n                xhr.onload = this.onload;\r\n                xhr.send(this.data);\r\n            }\r\n        }\r\n    });\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/components/XHR.js?");

/***/ }),

/***/ "./src/config/development.js":
/*!***********************************!*\
  !*** ./src/config/development.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* global module, require */\r\nconst pkg = __webpack_require__(/*! ../../package.json */ \"./package.json\");\r\n\r\nmodule.exports = {\r\n    dev: true,\r\n    buildDate: new Date().toGMTString(),\r\n    version: pkg.version + '-dev'\r\n};\n\n//# sourceURL=webpack://platypus/./src/config/development.js?");

/***/ }),

/***/ "./src/factory.js":
/*!************************!*\
  !*** ./src/factory.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _Component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Component.js */ \"./src/Component.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_2__);\n/**\r\n * The component factory takes in component definitions and creates component classes that can be used to create components by entities.  It adds properties and methods that are common to all components so that component definitions can focus on unique properties and methods.\r\n *\r\n * To create an extended component class, use the following syntax:\r\n *\r\n *      platypus.createComponentClass(componentDefinition, prototype);\r\n *\r\n *  * `componentDefinition` is list of key/value pairs that describe the component's behavior.\r\n *  * `prototype` is an optional prototype that this component extends.\r\n * See ComponentExample.js for an example componentDefinition that can be sent into this component class factory.\r\n *\r\n */\r\n/* global platypus */\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var debug = config__WEBPACK_IMPORTED_MODULE_2___default.a.dev,\r\n        priority = 0,\r\n        doNothing = function () {},\r\n        setupProperty = function (property, component, owner) {\r\n            Object.defineProperty(component, property, {\r\n                get: function () {\r\n                    return owner[property];\r\n                },\r\n                set: function (value) {\r\n                    owner[property] = value;\r\n                },\r\n                enumerable: true\r\n            });\r\n        };\r\n        \r\n    return function (componentDefinition) {\r\n        var func  = null,\r\n            proto = null;\r\n        \r\n        class NewComponent extends _Component_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n            constructor (owner, definition, callback) {\r\n                var prop  = '',\r\n                    func  = '',\r\n                    name  = '',\r\n                    alias = '';\r\n                    \r\n                super(componentDefinition.id, owner);\r\n\r\n                // Set up properties, prioritizing component settings, entity settings, and finally defaults.\r\n                if (componentDefinition.properties) {\r\n                    for (prop in componentDefinition.properties) {\r\n                        if (componentDefinition.properties.hasOwnProperty(prop)) {\r\n                            if (definition && (typeof definition[prop] !== 'undefined')) {\r\n                                this[prop] = definition[prop];\r\n                            } else if (typeof this.owner[prop] !== 'undefined') {\r\n                                this[prop] = this.owner[prop];\r\n                            } else {\r\n                                this[prop] = componentDefinition.properties[prop];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // These component properties are equivalent with `entity.property`\r\n                if (componentDefinition.publicProperties) {\r\n                    for (prop in componentDefinition.publicProperties) {\r\n                        if (componentDefinition.publicProperties.hasOwnProperty(prop)) {\r\n                            setupProperty(prop, this, owner);\r\n                            if (definition && (typeof definition[prop] !== 'undefined')) {\r\n                                this[prop] = definition[prop];\r\n                            } else if (typeof this.owner[prop] !== 'undefined') {\r\n                                this[prop] = this.owner[prop];\r\n                            } else {\r\n                                this[prop] = componentDefinition.publicProperties[prop];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (componentDefinition.events) {\r\n                    priority -= 1; // So event priority remains in order of component addition.\r\n                    for (func in componentDefinition.events) {\r\n                        if (componentDefinition.events.hasOwnProperty(func)) {\r\n                            this.addEventListener(func, componentDefinition.events[func], priority);\r\n                            if (definition && definition.aliases) {\r\n                                for (alias in definition.aliases) {\r\n                                    if (definition.aliases.hasOwnProperty(alias) && (definition.aliases[alias] === func)) {\r\n                                        this.addEventListener(alias, componentDefinition.events[func], priority);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (componentDefinition.publicMethods) {\r\n                    for (func in componentDefinition.publicMethods) {\r\n                        if (componentDefinition.publicMethods.hasOwnProperty(func)) {\r\n                            name = func;\r\n                            if (definition && definition.aliases) {\r\n                                for (alias in definition.aliases) {\r\n                                    if (definition.aliases.hasOwnProperty(alias) && (definition.aliases[alias] === func)) {\r\n                                        name = alias;\r\n                                    }\r\n                                }\r\n                            }\r\n                            this.addMethod(name, componentDefinition.publicMethods[func]);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!this.initialize(definition, callback) && callback) { // whether the callback will be used; if not, we run immediately.\r\n                    callback();\r\n                }\r\n            }\r\n        }\r\n        \r\n        proto = NewComponent.prototype;\r\n\r\n        proto.initialize = componentDefinition.initialize || doNothing;\r\n        \r\n        // This can be overridden by a \"toJSON\" method in the component definition. This is by design.\r\n        proto.toJSON = (function () {\r\n            var validating = false,\r\n                valid = function (value, depthArray) {\r\n                    var depth = null,\r\n                        root = false,\r\n                        key = '',\r\n                        invalid = false,\r\n                        i = 0,\r\n                        type = typeof value;\r\n                    \r\n                    if (!validating) { // prevents endless validation during recursion.\r\n                        validating = true;\r\n                        root = true;\r\n                    }\r\n\r\n                    if (type === 'function') {\r\n                        invalid = true;\r\n                    } else if ((type === 'object') && (value !== null)) {\r\n                        if (value.toJSON) { // We know it's valid but we run this for the depth check to make sure that there is no recursion.\r\n                            depth = depthArray ? Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(depthArray) : _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                            depth.push(value);\r\n                            if (!valid(value.toJSON(), depth)) {\r\n                                invalid = true;\r\n                            }\r\n                        } else if (Array.isArray(value)) {\r\n                            i = value.length;\r\n                            while (i--) {\r\n                                if (depthArray && depthArray.indexOf(value[i]) >= 0) {\r\n                                    invalid = true;\r\n                                    break;\r\n                                }\r\n                                depth = depthArray ? Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(depthArray) : _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                                depth.push(value[i]);\r\n                                if (!valid(value[i], depth)) {\r\n                                    invalid = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            for (key in value) {\r\n                                if (value.hasOwnProperty(key)) {\r\n                                    if (depthArray && depthArray.indexOf(value[key]) >= 0) {\r\n                                        invalid = true;\r\n                                        break;\r\n                                    }\r\n                                    depth = depthArray ? Object(_utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"greenSlice\"])(depthArray) : _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n                                    depth.push(value[key]);\r\n                                    if (!valid(value[key], depth)) {\r\n                                        invalid = true;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (depthArray) {\r\n                        _utils_array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].recycle(depthArray);\r\n                    }\r\n\r\n                    if (root) {\r\n                        validating = false;\r\n                    }\r\n\r\n                    return !invalid;\r\n                };\r\n\r\n            // We only perform validation in debug mode since it may impact performance.\r\n            if (debug) {\r\n                return function (propertiesDefinition) {\r\n                    var properties = componentDefinition.properties,\r\n                        publicProperties = componentDefinition.publicProperties,\r\n                        component = {\r\n                            type: this.type\r\n                        },\r\n                        key = '';\r\n                    \r\n                    for (key in properties) {\r\n                        if (properties.hasOwnProperty(key) && (properties[key] !== this[key])) {\r\n                            if (!validating && !valid(this[key])) {\r\n                                platypus.debug.warn('Component \"' + this.type + '\" includes a non-JSON property value for \"' + key + '\" (type \"' + (typeof this[key]) + '\"). You may want to create a custom `toJSON` method for this component.', this[key]);\r\n                            }\r\n                            component[key] = this[key];\r\n                        }\r\n                    }\r\n\r\n                    for (key in publicProperties) {\r\n                        if (publicProperties.hasOwnProperty(key) && (publicProperties[key] !== this.owner[key]) && (typeof propertiesDefinition[key] === 'undefined')) {\r\n                            if (!validating && !valid(this.owner[key])) {\r\n                                platypus.debug.warn('Component \"' + this.type + '\" includes a non-JSON public property value for \"' + key + '\" (type \"' + (typeof this.owner[key]) + '\"). You may want to create a custom `toJSON` method for this component.', this.owner[key]);\r\n                            }\r\n                            propertiesDefinition[key] = this.owner[key];\r\n                        }\r\n                    }\r\n\r\n                    return component;\r\n                };\r\n            } else {\r\n                return function (propertiesDefinition) {\r\n                    var properties = componentDefinition.properties,\r\n                        publicProperties = componentDefinition.publicProperties,\r\n                        component = {\r\n                            type: this.type\r\n                        },\r\n                        key = '';\r\n                    \r\n                    for (key in properties) {\r\n                        if (properties.hasOwnProperty(key) && (properties[key] !== this[key])) {\r\n                            component[key] = this[key];\r\n                        }\r\n                    }\r\n\r\n                    for (key in publicProperties) {\r\n                        if (publicProperties.hasOwnProperty(key) && (publicProperties[key] !== this.owner[key])) {\r\n                            propertiesDefinition[key] = this.owner[key];\r\n                        }\r\n                    }\r\n\r\n                    return component;\r\n                };\r\n            }\r\n        }());\r\n\r\n        if (componentDefinition.methods) {\r\n            for (func in componentDefinition.methods) {\r\n                if (componentDefinition.methods.hasOwnProperty(func)) {\r\n                    if (func === 'destroy') {\r\n                        proto._destroy = componentDefinition.methods[func];\r\n                    } else {\r\n                        proto[func] = componentDefinition.methods[func];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (componentDefinition.publicMethods) {\r\n            for (func in componentDefinition.publicMethods) {\r\n                if (componentDefinition.publicMethods.hasOwnProperty(func)) {\r\n                    proto[func] = componentDefinition.publicMethods[func];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (componentDefinition.getAssetList) {\r\n            NewComponent.getAssetList = componentDefinition.getAssetList;\r\n        }\r\n        if (componentDefinition.getLateAssetList) {\r\n            NewComponent.getLateAssetList = componentDefinition.getLateAssetList;\r\n        }\r\n\r\n        return NewComponent;\r\n    };\r\n}());\r\n\n\n//# sourceURL=webpack://platypus/./src/factory.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: recycle, AABB, ActionState, Async, CollisionData, CollisionDataContainer, CollisionShape, Component, Data, DataMap, Entity, Game, Messenger, PIXIAnimation, Scene, StateMap, Vector, createComponentClass, default, arrayCache, union, greenSlice, greenSplice, greenSplit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _DataMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataMap.js */ \"./src/DataMap.js\");\n/* harmony import */ var springroll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! springroll */ \"springroll\");\n/* harmony import */ var springroll__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(springroll__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Game_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Game.js */ \"./src/Game.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./factory.js */ \"./src/factory.js\");\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"arrayCache\", function() { return _utils_array_js__WEBPACK_IMPORTED_MODULE_5__[\"arrayCache\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"union\", function() { return _utils_array_js__WEBPACK_IMPORTED_MODULE_5__[\"union\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"greenSlice\", function() { return _utils_array_js__WEBPACK_IMPORTED_MODULE_5__[\"greenSlice\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"greenSplice\", function() { return _utils_array_js__WEBPACK_IMPORTED_MODULE_5__[\"greenSplice\"]; });\n\n/* harmony import */ var _utils_string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/string.js */ \"./src/utils/string.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"greenSplit\", function() { return _utils_string_js__WEBPACK_IMPORTED_MODULE_6__[\"greenSplit\"]; });\n\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"recycle\", function() { return recycle__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; });\n\n/* harmony import */ var _AABB_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./AABB.js */ \"./src/AABB.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AABB\", function() { return _AABB_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; });\n\n/* harmony import */ var _ActionState_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ActionState.js */ \"./src/ActionState.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ActionState\", function() { return _ActionState_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]; });\n\n/* harmony import */ var _Async_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Async.js */ \"./src/Async.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Async\", function() { return _Async_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]; });\n\n/* harmony import */ var _CollisionData_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./CollisionData.js */ \"./src/CollisionData.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CollisionData\", function() { return _CollisionData_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]; });\n\n/* harmony import */ var _CollisionDataContainer_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./CollisionDataContainer.js */ \"./src/CollisionDataContainer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CollisionDataContainer\", function() { return _CollisionDataContainer_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"]; });\n\n/* harmony import */ var _CollisionShape_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./CollisionShape.js */ \"./src/CollisionShape.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CollisionShape\", function() { return _CollisionShape_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"]; });\n\n/* harmony import */ var _Component_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Component.js */ \"./src/Component.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return _Component_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"]; });\n\n/* harmony import */ var _Data_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Data.js */ \"./src/Data.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Data\", function() { return _Data_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DataMap\", function() { return _DataMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Entity.js */ \"./src/Entity.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Entity\", function() { return _Entity_js__WEBPACK_IMPORTED_MODULE_16__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Game\", function() { return _Game_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _Messenger_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Messenger.js */ \"./src/Messenger.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Messenger\", function() { return _Messenger_js__WEBPACK_IMPORTED_MODULE_17__[\"default\"]; });\n\n/* harmony import */ var _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./PIXIAnimation.js */ \"./src/PIXIAnimation.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PIXIAnimation\", function() { return _PIXIAnimation_js__WEBPACK_IMPORTED_MODULE_18__[\"default\"]; });\n\n/* harmony import */ var _Scene_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./Scene.js */ \"./src/Scene.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return _Scene_js__WEBPACK_IMPORTED_MODULE_19__[\"default\"]; });\n\n/* harmony import */ var _StateMap_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./StateMap.js */ \"./src/StateMap.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StateMap\", function() { return _StateMap_js__WEBPACK_IMPORTED_MODULE_20__[\"default\"]; });\n\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./Vector.js */ \"./src/Vector.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vector\", function() { return _Vector_js__WEBPACK_IMPORTED_MODULE_21__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createComponentClass\", function() { return _factory_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/**\r\n * @module platypus\r\n * @namespace platypus\r\n */\r\n/* global global, navigator, require, window */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var platypus = global.platypus = {},\r\n        debugWrapper = springroll__WEBPACK_IMPORTED_MODULE_1__[\"Debugger\"] ? function (method, ...args) {\r\n            springroll__WEBPACK_IMPORTED_MODULE_1__[\"Debugger\"].log(method, ...args);\r\n        } : function (method, ...args) {\r\n            window.console[method](...args);\r\n        },\r\n        log = config__WEBPACK_IMPORTED_MODULE_3___default.a.dev ? debugWrapper : function () {},\r\n        uagent    = navigator.userAgent.toLowerCase(),\r\n        isEdge    = (uagent.search('edge')    > -1),\r\n        isIPod    = (uagent.search('ipod')    > -1),\r\n        isIPhone  = (uagent.search('iphone')  > -1),\r\n        isIPad    = (uagent.search('ipad')    > -1),\r\n        isAndroid = (uagent.search('android') > -1),\r\n        isSilk    = (uagent.search('silk')    > -1),\r\n        isIOS     = isIPod || isIPhone  || isIPad,\r\n        isMobile  = isIOS  || isAndroid || isSilk,\r\n        importAll = function (r) {\r\n            r.keys().forEach((key) => {\r\n                var arr = key.split('/'),\r\n                    last = arr.length - 1;\r\n                \r\n                platypus.components[arr[last].substring(0, arr[last].length - 3)] = r(key).default;\r\n            });\r\n        };\r\n\r\n    platypus.components = {};\r\n    platypus.createComponentClass = _factory_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\r\n\r\n    importAll(__webpack_require__(\"./src/components sync recursive .*\\\\.js\"));\r\n\r\n    /**\r\n     * This is an object of boolean key/value pairs describing the current browser's properties.\r\n     * @property supports\r\n     * @type Object\r\n     **/\r\n    platypus.supports = {\r\n        touch: (window.ontouchstart !== 'undefined'),\r\n        edge: isEdge,\r\n        iPod: isIPod,\r\n        iPhone: isIPhone,\r\n        iPad: isIPad,\r\n        safari: (uagent.search('safari')  > -1) && !isEdge,\r\n        ie: (uagent.search('msie')    > -1) || (uagent.search('trident') > -1),\r\n        firefox: (uagent.search('firefox') > -1),\r\n        android: isAndroid,\r\n        chrome: (uagent.search('chrome')  > -1) && !isEdge,\r\n        silk: isSilk,\r\n        iOS: isIOS,\r\n        mobile: isMobile,\r\n        desktop: !isMobile\r\n    };\r\n    \r\n    /**\r\n     * This method defines platypus.debug and uses springroll.Debug if available. If springroll.Debug is not loaded, platypus.debug provides inactive stubs for console methods.\r\n     *\r\n     * @property debug\r\n     * @type Object\r\n     */\r\n    platypus.debug = {\r\n        general: log.bind(null, 'log'),\r\n        log: log.bind(null, 'log'),\r\n        warn: log.bind(null, 'warn'),\r\n        debug: log.bind(null, 'debug'),\r\n        error: log.bind(null, 'error'),\r\n        olive: log.bind(null, 'log') // Backwards compatibility - need to deprecate.\r\n    };\r\n\r\n    platypus.assetCache = _DataMap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].setUp();\r\n\r\n    /**\r\n     * The version string for this release.\r\n     * @property version\r\n     * @type String\r\n     * @static\r\n     **/\r\n    platypus.version = config__WEBPACK_IMPORTED_MODULE_3___default.a.version;\r\n\r\n    /**\r\n     * The build date for this release in UTC format.\r\n     * @property buildDate\r\n     * @type String\r\n     * @static\r\n     **/\r\n    platypus.buildDate = config__WEBPACK_IMPORTED_MODULE_3___default.a.buildDate;\r\n\r\n    platypus.Game = _Game_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\r\n\r\n    return platypus;\r\n}());\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://platypus/./src/index.js?");

/***/ }),

/***/ "./src/polyfills/Map.js":
/*!******************************!*\
  !*** ./src/polyfills/Map.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * @namespace window\r\n */\r\n/**\r\n * This class defines a limited polyfill for Map. If the browser supports Map, this class is not used.\r\n *\r\n * @class Map\r\n * @since 0.8.0\r\n */\r\n/* global window */\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (Object) {\r\n    var mapDefinition = null,\r\n        Map = null,\r\n        proto = null;\r\n    \r\n    if (!window.Map) {\r\n        mapDefinition = {\r\n            value: null\r\n        };\r\n        Map = function () {\r\n            /**\r\n             * This is an object containing a list of key/value pairs. This property should not be used directly.\r\n             *\r\n             * @property map\r\n             * @type Object\r\n             * @private\r\n             * @default {}\r\n             */\r\n            mapDefinition.value = {};\r\n            Object.defineProperty(this, 'map', mapDefinition);\r\n        };\r\n        proto = Map.prototype;\r\n\r\n        Object.defineProperties(proto, {\r\n\r\n            /**\r\n             * Returns the value of the provided key.\r\n             *\r\n             * @method get\r\n             * @param key {String} The key to lookup.\r\n             * @return value {any} The value of the provded key.\r\n             */\r\n            get: {\r\n                value: function (key) {\r\n                    return this.map[key];\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Determines whether the provided key is available in this Map.\r\n             *\r\n             * @method has\r\n             * @param key {String} The key to lookup.\r\n             * @return value {Boolean} Whether the key is listed in this Map.\r\n             */\r\n            has: {\r\n                value: function (key) {\r\n                    return this.map.hasOwnProperty(key);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Sets a value to a key in the Map.\r\n             *\r\n             * @method set\r\n             * @param key {String} The key to associate with the provided value.\r\n             * @param value {any} The value to be stored by the Map.\r\n             * @chainable\r\n             */\r\n            set: {\r\n                value: function (key, value) {\r\n                    this.map[key] = value;\r\n                    return this;\r\n                }\r\n            },\r\n            \r\n            /**\r\n             * Deletes a key (and value) from the Map.\r\n             *\r\n             * @method delete\r\n             * @param key {String} The key to delete from the Map.\r\n             * @return value {any} The value of the key is returned.\r\n             */\r\n            delete: {\r\n                value: function (key) {\r\n                    var value = this.map[key];\r\n                    \r\n                    delete this.map[key];\r\n                    return value;\r\n                }\r\n            }\r\n        });\r\n        \r\n        window.Map = Map;\r\n    }\r\n}(Object));\n\n//# sourceURL=webpack://platypus/./src/polyfills/Map.js?");

/***/ }),

/***/ "./src/sayHello.js":
/*!*************************!*\
  !*** ./src/sayHello.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/array.js */ \"./src/utils/array.js\");\n/* harmony import */ var _utils_string_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/string.js */ \"./src/utils/string.js\");\n/* global console, document, platypus */\r\n\r\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (function () {\r\n    var getPortion = function (num, max) {\r\n            var min = 204;\r\n        \r\n            return Math.floor(min * num / max);\r\n        },\r\n        getStyle = function (title, version) {\r\n            var max = 0,\r\n                min = 0,\r\n                style = 'color: #ffffff; line-height: 1.5em; border-radius: 6px;',\r\n                r = 0,\r\n                g = 0,\r\n                b = 0,\r\n                v = null;\r\n                \r\n            if (version) {\r\n                v = Object(_utils_string_js__WEBPACK_IMPORTED_MODULE_2__[\"greenSplit\"])(version, '.');\r\n            }\r\n            \r\n            if (version && (v.length === 3)) {\r\n                r = parseInt(v[0], 10);\r\n                g = parseInt(v[1], 10);\r\n                b = parseInt(v[2], 10);\r\n            } else {\r\n                r = title.charCodeAt(0) || 0;\r\n                g = title.charCodeAt(1) || 0;\r\n                b = title.charCodeAt(2) || 0;\r\n                min = Math.min(r, g, b);\r\n                r -= min;\r\n                g -= min;\r\n                b -= min;\r\n            }\r\n            \r\n            if (v) {\r\n                _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(v);\r\n            }\r\n            \r\n            max = Math.max(r, g, b, 1);\r\n\r\n            return style + ' background-color: rgb(' + getPortion(r, max) + ',' + getPortion(g, max) + ',' + getPortion(b, max) + ');';\r\n        },\r\n        getVersions = function (text, title, arr) {\r\n            var i = 0,\r\n                str = '',\r\n                versions = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(text);\r\n            \r\n            for (i = 0; i < arr.length; i++) {\r\n                str = arr[i];\r\n                versions.push(getStyle(str, str.substr(str.lastIndexOf(' ') - str.length + 1)), 'line-height: 1.5em;');\r\n            }\r\n            \r\n            return versions;\r\n        };\r\n\r\n    // Over-riding the pixi.js hello since we're creating our own.\r\n    pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"utils\"].skipHello();\r\n    \r\n    return function (app) {\r\n        var options = app.options,\r\n            authorTag = document.getElementsByName('author'),\r\n            docAuth = authorTag.length ? authorTag[0].getAttribute('content') || '' : '',\r\n            author  = (docAuth ? 'by ' + docAuth : ''),\r\n            title   = options.name || app.name || document.title || '',\r\n            engine  = 'Platypus ' + platypus.version,\r\n            version = options.version || '(?)',\r\n            using   = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\r\n            usingV  = _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].setUp(),\r\n            sr      = platypus.springroll, //TODO: Figure out how to detect SR.\r\n            supports = platypus.supports;\r\n        \r\n        if (sr) {\r\n            using.push('SpringRoll ' + sr.version);\r\n        }\r\n        \r\n        using.push('Pixi.js ' + pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"VERSION\"]);\r\n        \r\n        if (version !== '(?)') {\r\n            title += ' ' + version;\r\n        }\r\n        \r\n        if (supports.firefox || supports.chrome) {\r\n            console.log('%c ' + title + ' %c ' + author, getStyle(title, title.substr(title.lastIndexOf(' ') - title.length + 1)), 'line-height: 1.5em;');\r\n            using.push(engine);\r\n            usingV = getVersions('Using %c ' + using.join(' %c %c ') + ' %c ', title, using);\r\n            console.log.apply(console, usingV);\r\n            _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(usingV);\r\n        } else {\r\n            console.log('--- \"' + title + '\" ' + author + ' - Using ' + using.join(', ') + ', and ' + engine + ' ---');\r\n        }\r\n\r\n        _utils_array_js__WEBPACK_IMPORTED_MODULE_1__[\"arrayCache\"].recycle(using);\r\n    };\r\n}());\n\n//# sourceURL=webpack://platypus/./src/sayHello.js?");

/***/ }),

/***/ "./src/utils/array.js":
/*!****************************!*\
  !*** ./src/utils/array.js ***!
  \****************************/
/*! exports provided: arrayCache, union, greenSlice, greenSplice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"arrayCache\", function() { return arrayCache; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"union\", function() { return union; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"greenSlice\", function() { return greenSlice; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"greenSplice\", function() { return greenSplice; });\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! config */ \"./src/config/development.js\");\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(config__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var recycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! recycle */ \"./node_modules/recycle/recycle.js\");\n/**\r\n * @namespace window\r\n */\r\n\r\n\r\n\r\nconst arrayCache = recycle__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(Array, 'Array', null, null, false, config__WEBPACK_IMPORTED_MODULE_0___default.a.dev);\r\n\r\n/**\r\n * Merges items from one array into the other, making sure to not duplicate identical entries.\r\n *\r\n * @method union\r\n * @param arrayTo {Array} The array into which items will be inserted.\r\n * @param arrayFrom {Array} The array containing items to be merged.\r\n * @return Array\r\n */\r\nfunction union (arrayTo, arrayFrom) {\r\n    var i = 0,\r\n        bL = arrayFrom.length;\r\n        \r\n    for (i = 0; i < bL; i++) {\r\n        if (arrayTo.indexOf(arrayFrom[i]) === -1) {\r\n            arrayTo.push(arrayFrom[i]);\r\n        }\r\n    }\r\n    \r\n    return arrayTo;\r\n}\r\n\r\n/**\r\n * Slices, but uses a recycled array. Note that this slice does not accept parameters and makes a shallow copy of the original array.\r\n *\r\n * @method greenSlice\r\n * @param array {Array} The array to copy.\r\n * @return Array\r\n */\r\nfunction greenSlice (array) {\r\n    var arr = arrayCache.setUp(),\r\n        i = 0,\r\n        length = array.length;\r\n        \r\n    for (i = 0; i < length; i++) {\r\n        arr[i] = array[i];\r\n    }\r\n    \r\n    return arr;\r\n}\r\n\r\n/**\r\n * Splices, but only removes a single item and returns the item itself, not an array.\r\n *\r\n * @method greenSplice\r\n * @param array {Array} The array from which an item is to be extracted.\r\n * @param index {Number} The index of the item to extract.\r\n * @return {any}\r\n */\r\nfunction greenSplice (array, index) {\r\n    var i = 0,\r\n        item = array[index],\r\n        length = array.length;\r\n        \r\n    if ((index < 0) || (index >= length)) {\r\n        return null;\r\n    }\r\n    \r\n    for (i = index + 1; i < length; i++) {\r\n        array[i - 1] = array[i];\r\n    }\r\n    \r\n    if (length) {\r\n        array.length -= 1;\r\n    }\r\n    \r\n    return item;\r\n}\n\n//# sourceURL=webpack://platypus/./src/utils/array.js?");

/***/ }),

/***/ "./src/utils/string.js":
/*!*****************************!*\
  !*** ./src/utils/string.js ***!
  \*****************************/
/*! exports provided: greenSplit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"greenSplit\", function() { return greenSplit; });\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ \"./src/utils/array.js\");\n/**\r\n * @namespace window\r\n */\r\n\r\n\r\n/**\r\n * Splits a string, but populates an array from the array cache instead of creating a new one.\r\n *\r\n * @method greenSplit\r\n * @param str {String} String to split.\r\n * @param [splitter] {String} String demarking where to split. If not provided, each character in the split string becomes an array item.\r\n * @return Array\r\n */\r\nfunction greenSplit (str, splitter) {\r\n    var str = str.toString(),\r\n        d = 0,\r\n        i = 0,\r\n        arr = _array_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCache\"].setUp();\r\n    \r\n    if (splitter) {\r\n        i = str.indexOf(splitter);\r\n        d = splitter.length;\r\n\r\n        while (i >= 0) {\r\n            arr.push(str.substr(0, i));\r\n            str = str.substr(i + d);\r\n            i = str.indexOf(splitter);\r\n        }\r\n        \r\n        arr.push(str);\r\n    } else {\r\n        i = str.length;\r\n        d = i - 1;\r\n\r\n        while (i--) {\r\n            arr.push(str[d - i]);\r\n        }\r\n    }\r\n    \r\n    return arr;\r\n}\n\n//# sourceURL=webpack://platypus/./src/utils/string.js?");

/***/ }),

/***/ "@tweenjs/tween.js":
/*!************************************!*\
  !*** external "@tweenjs/tween.js" ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = @tweenjs/tween.js;\n\n//# sourceURL=webpack://platypus/external_%22@tweenjs/tween.js%22?");

/***/ }),

/***/ "pixi-sound":
/*!*****************************!*\
  !*** external "pixi-sound" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = pixi-sound;\n\n//# sourceURL=webpack://platypus/external_%22pixi-sound%22?");

/***/ }),

/***/ "pixi-spine":
/*!*****************************!*\
  !*** external "pixi-spine" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = pixi-spine;\n\n//# sourceURL=webpack://platypus/external_%22pixi-spine%22?");

/***/ }),

/***/ "pixi.js":
/*!**************************!*\
  !*** external "pixi.js" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = pixi.js;\n\n//# sourceURL=webpack://platypus/external_%22pixi.js%22?");

/***/ }),

/***/ "springroll":
/*!*****************************!*\
  !*** external "springroll" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = springroll;\n\n//# sourceURL=webpack://platypus/external_%22springroll%22?");

/***/ })

/******/ });